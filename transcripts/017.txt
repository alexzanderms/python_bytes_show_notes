Michael KENNEDY: Hey everyone, Michael here. Just a quick show note before we get started on this episode. I think we have a great set of topics to cover but unfortunately, something went crazy with my computer and pinned all the cores and made the recording of my high-quality version fall apart. So, when you listen to this there will be a little bit of static on my end. I just want to say, sorry about that. We had some back up audio but it also got messed up. Basically, I’ve tried to make it as good as possible but there’s a little bit of issue with the audio. If you can handle it, there’s some great news and if you want to skip this one and wait for next week, I totally understand as well. 
Alright, without further ado, let’s get to the news. Thanks.
This is Python Bytes, Python news delivered directly to your earbuds. It’s Monday, March 13th, 2017. This is your host, Michael Kennedy, here with my co-host, Brian Okken. 
Hey, Brian. Are you ready to share the Python news with the world?
Brian OKKEN: I’m very ready and excited. 
KENNEDY: Would you say that you’re on fire? 
OKKEN: I am on fire, yeah.
KENNEDY: Awesome. Google’s on fire, too, right?
OKKEN: Yeah, I’m actually a little confused about where this is coming from but the first topic was suggested by several listeners – we got it through email and through Twitter – to cover a tool called Python Fire. I don’t know where it’s from. It’s on the Google Repo on GitHub but at the bottom it says it’s not a Google product. I don’t know what that means. 
KENNEDY: I think it means it might have been created by somebody at Google but it’s not supported in anyway. It’s just, ‘Hey, this is a cool thing we made. The world should have it.’
OKKEN: Yeah, I downloaded it and gave it a shot. It’s a command line interface utility. At the top of the Repo it says:
“Python Fire is a library for automatically generating command line interfaces (CLIs) from absolutely any Python object.” 
It is pretty cool. Another thing it says in the list of benefits: A simple way to create a CLI in Python. You can use it for exploring and debugging existing Python code. And it makes transitioning between Bash and Python easier. 
So, I tried it out, downloaded it, wrote a couple little tools. It was pretty fun but I don’t think I would use it for a shippable Python command line interface because it’s pretty big. 
KENNEDY: Yeah, and by big you mean it has some heavyweight dependencies, right?
OKKEN: Yeah, it includes all of iPython. That’s quite a bit. It also includes 6 but that’s not really that big of a deal. 
KENNEDY: Yeah, 6 is basically one little module. But iPython, that can be one of those things that’s really hard to solve for some people. You give that to somebody on a Windows machine, they don’t have a complier set up, that can be quite challenging. 
OKKEN: I’ll have to see. I’m going to install it on a Windows machine this week. To try that out. 
KENNEDY: But it does look really great. You basically have a class. For your main you just call “fire” and you pass it the class and boom that thing is CLI callable, right?
OKKEN: Yeah, but you don’t have to use a class. You can have a set of functions you can put together and add those as the interface. There can be multiple entry points as well. I tried throwing in 2 or 3 functions and then listing those as all things that you can call from the command line. 
It picks up doc strings pretty well, so you kind of have help built in as well. I’m going to use it for test instruments that we try to communicate with. Writing to and from the instrument from Python is really easy; from Bash, not so easy. I think I’m going to use this to try to do that at work.
KENNEDY: You totally have to give us a report of your experience.
The next thing I want to talk about is Simon. Not “Simon Says” but a cool menubar application for MacOS. If you don’t care about MacOS, maybe you don’t care too much about this. One of my pet peeves is, I think we need more full-on native cross platform GUI things. We’ve had PyQt and the PySide and QT framework. That’s one option that we’ve had that’s pretty good. But there’s a lot of versioning, licensing funkiness going on, maybe until the end of this year actually until they come out with PySide 2. Maybe that becomes a really great option. We have thing like PyObjC, similar stuff for Windows, similar stuff for Linux, where you can basically – somebody already has – wrap the truly native OS elements So, with this thing called PyObjC you can basically create, using Python, what is indistinguishable from a native app. The controls literally are the same if you’ve done it with X Code and Objective C or Swift. 
That’s pretty cool. Right? 
OKKEN: Yeah, I hadn’t heard of this. This is neat.
KENNEDY So, this Simon thing is not like a framework, it’s an app. Some guy is like, ‘Hey, I really want to have a little thing I can click on that will tell me my network usage, my CP usage, my battery usage…” And he did it as one of those little menubar things that runs on the top right by the clock on the MacOS. You click and it drops down info about your system. If you look at the code, it depends on PyObjC but beyond that is 150 lines for a full implementation of the app.
OKKEN: That’s pretty cool.
KENNEDY: If you need just a little simple something run on the menubar app or the notification tray in Windows or something like this, this is a really cool option. I mostly wanted to pull out, ‘Hey here’s an example that you could mostly clone or tweak the ideas of this and go. You create an app, you derive from MS Application which comes from PyObjC, you implement a few methods and boom, you’ve got a nice, native GUI app.
OKKEN: I’m going to have to try this one out, too. That’s neat.
KENNEDY: It’s neat, right? The final mix would be to use something like py2app where you bundle it in a distributable way so it’s not like, ‘Well, make sure you pip install this thing before you can run it.’ That’s probably not going to fly so well for end users, but still pretty excellent. 
OKKEN: Is this PyObjC? So, that’s just a Mac only thing?
KENNEDY: Yes, exactly. But we can do some other stuff in the other frameworks, I believe. On the Windows side, you can use WPF (Windows Presentation Foundation), which is kind of way more heavyweight. You can build the Python stuff using iPython and I’m sure there’s something with GDK (GIMP Drawing Kit) and Linux as well.
OKKEN: Neat.
KENNEDY: It’s kind of lunch time and I’m getting hungry. I wish I had some free food.
OKKEN: Well, I was amused. I don’t know what these are used for or not, but I was amused reading Reddit this last week. There were a couple of things that popped and one of them was actually useful. “Finding free food with Python.” It’s actually an article talking about using web scraping. Apparently, there’s a couple places that have food delivery places that sometimes run specials where they’ll actually deliver free food to you, but you have to be paying attention to have that work. Somebody wrote an app with web scraping in Twilio to occasionally check on this then and then text him information about the free specials. 
I probably won’t do this but I think it’s a nice example of combining Twilio with web scraping.
KENNEDY: It’s cool. Do you know what I like about it? It’s taking these techy, digital, API-type things and it’s making the real stuff happen. You’re integrating Twilio and screen scraping and have free food. How cool is that, right? 
OKKEN: Yeah, definitely real world with the free food. I’ve been thinking about doing a similar thing, monitoring. We have build machines and stuff; I wouldn’t mind having something that sat around and monitored that then texted me the results. I don’t know how to do that.
KENNEDY: Yeah, it’s cool. Definitely some cool Twilio integration there. 
OKKEN: The next article just amused the heck out of me. It’s called, “Notification When Friends Order Pizza.” I don’t know if this is a great thing or not for Dominos to do but there’s apparently a way that you can plug in phone numbers and find out if those numbers ordered pizza recently. So, somebody wrote a script to put in all of their friends’ phone numbers to text them or let them know when one of their friends is ordering pizza. I guess another way to get free food is to mooch off your friends when they order food.
KENNEDY: Yeah, that’s a… I’m not sure how I feel about that actually. That’s a little creepy, man. (Laughs)
OKKEN: (Laughs) It actually is creepy. I was wondering whether or not I should include that, but it amused me. I don’t think it really ought to be that easy to find out whether or not somebody ordered some pizza. 
KENNEDY: Well, if all your friends start showing up every time you have Dominos…
Dominos is trying some funky stuff, man. They also have a bot. You can order pizza just by chatting with Dominos, which is also kind of funky.
OKKEN: Yeah, but you could order food for other people then, or something. I don’t know. It seems like they’re playing with scary interfaces, but at least they’re playing with interfaces. 
KENNEDY: Exactly, it is pretty cool. 
Speaking of food, I want to talk about pie. HTTPie, which is a little utility written in Python that is kind of like wget or curl, except for that it’s awesome. 
The reason it’s awesome is it runs on the command line, so if I wanted to call a JSON API, I could say, ‘HTTP (space)’ and give it the URL or whatever that is; maybe some additional data, you could post data from the command line and so on. It comes back formatted, pre-printed, color-coded, everything. It’s quite glorious. You can create sessions, like authentic sessions and have them persist across multiple calls. You can do XML You can do JSON. You can do HTTP, HTML, all these different things that it knows about will color-code and format pretty for you on the command line.
OKKEN: That’s great. This is multiple operating systems. 
KENNEDY: Yes, absolutely. This works everywhere. This is just a Python 3.x little library and that’s the Pie part the Python. So, I’ve spoken about Postman before as being a cool way to test APIs and play around with them. This is kind of like the CLI version because if you do that with curl or even Python and Request and you spit it out, it shows you it but it’s usually not well formatted. It’s not minified, it’s not color-coded, so this is pretty tricky. 
OKKEN: The color coding actually makes it really readable, it’s nice.
KENNEDY: So, if you’ve been using curl or wget a lot, check out HTTPie. The link is in the show notes and it’s on GitHub. It’s got a cool interface. I put the link to the homepage in there, just click on that and you’ll see a screenshot comparison of that versus curl. It’s night and day; it’s great.
OKKEN: The last thing I’ve got is, speaking of command lines and hard to pronounce packages, it’s “pipdeptree.” 
There’s a little utility that you can do with pip install, I think it’s pipdeptree all together.
KENNEDY: Yeah, as in Pip Dependency Tree.
OKKEN: Yes, and it is a godsend for me. Since for this podcast I’m trying out stuff all the time, trying out new packages. Also, for work right now I’m working on the plug-in chapter in the PyTest book and I’m installing a lot of stuff. I am using virtual environments but I don’t really want to throw them away all the time, so I want to clean them out. But if you just do a pip list, often I see a bunch of stuff I don’t remember installing because of all the dependencies. This pipdeptree just shows all of the things you’ve installed and what depends on what. When I look up and I don’t know what arrow is or where it came from, pipdeptree shows me that I installed cookie cutter, and cookie cutter installed Jinja 2 and now I know. 
KENNEDY: That’s very cool. 
OKKEN: Yeah, it’s nice. I like it. It should just be an option in pip list, I think. 
KENNEDY: Yeah, it really should be part of pip, shouldn’t it. It’s not and so we have pipdeptree. You can reverse it as well and say, ‘This thing depends upon this.’ And it will say, ‘These 3 packages, through some sort of transitive closure of their dependency graph, these are the things that you need.’ Or you can do it the other way and say, ‘What is installed?’ Or, ‘What does this thing depend upon?’ It’s pretty cool. You can view it from either direction. 
OKKEN: Oh, cool. I didn’t know that. Neat.
KENNEDY: There’s a -R (dash R) for reverse, so hit it with a -R.
So, the final thing we have for today is a real testament to Python 3.x, to modern Python, to asynchrony. We’ve been hitting this Async08, power of asynchrony a couple of times, so I want to come back with a few comments from what people have talked about. But I also want to feature an article. 
There’s a really great article but the folks at SignifiAI, which is an AI platform that uses Python. The title of what we’re going to talk about is “Not Your Father’s Python: Amazing Python Frameworks.” They went through what they had been thinking about when they created this company and said, ‘Look, we all know Python and we like Python. But it’s super important that we can do crazy amounts of data processing.’ Their product and infrastructure have to handle hundreds of thousands of events per second. They’ve been hearing the drumbeat that, ‘You can’t scale with Python, you need to switch to Go, etc.’ They said, ‘Alright, let’s have a look and let’s see how this is going to work out.’ They evaluated Go, what the good and the bad of it was, they evaluated Python and said, ‘Let’s look at not traditional Python, the way the synchronous style of programming.’ But there’s a number of really powerful Asynch frameworks that we’ve covered, I think; at least 2 out of 3 of them. There’s UVLoop, which is pretty awesome, there’s Sanic and there’s Japronto. 
So, Sanic and Japronto, these are the web things that we’ve talked about tons. They’re build on AsynchIO, just like UVLoop is but UVLoop is actually a reimplementation and syphon to the compiled version of Python, that’s more than twice as fast as what’s built into Python itself. 
OKKEN: Very interesting.
KENNEDY: Maye we should just bring that feature into Python in some way to make AsyncIO twice as fast. 
So, they said, ‘Let’s look at this and evaluate and decide if this scalability thing is going to work.’ They said, ‘We all know about the GIL. Is this a real problem?’ They ran some comparisons and did some work and it turns out they’ve got some graphs of UVLoop and other frameworks just blowing away things like Node.JS in terms of performance, keeping up with Go. In some cases, faster and in some slower, but very high performance. 
So, after this really detailed write-up with numbers and everything, graphs and analysis, they said: 
“The future of Python is here: Overall, it looks fast, asynchronous Python may be here to stay. Now that AsyncIO appears to be a default in Python and the async/await syntax has found favor among developers, the GIL doesn’t seem like such a roadblock anymore and speed doesn’t need to be a sacrifice.”  
OKKEN: Cool.
KENNEDY: They said, ‘It’s working out great for us, Python 3.x, and we’ve got the scalability we need, no problem. We’re happy we didn’t abandon because traditionally, it hadn’t been fast enough.’ 
OKKEN: Somehow, I’m missing this where they looked at Japronto and Sanic and UVLoop. Are they deciding on anything here?
KENNEDY: I don’t know which one they decided upon. I think UVLoop is a little more established. UVLoop is actually the foundation for Japronto and Sanic. So, there’s a bit of a mixing. Japronto and Sanic are extending these. Pretty cool.
There’s a nice comment, which I linked in the show notes section. There’s somebody in there saying, ‘Hey. We went through the same basic thinking and here’s how it worked out for us.’ They said, ‘We’re also doing this async Python 3.x thing which is cool.’
On Twitter, we got a message from Sasha Cuerda. He said, ‘Hey, Michael. Hey, Brian. I have this example where I was doing a bunch of HTTP client stuff.’ Remember, we talked about aiohttp, the client side stuff, how much faster that can make it. He said, ‘That’s cool. I was doing some scraping and whatnot and my particular project went from over 8 minutes doing requests to less than 45 seconds using the Async08stuff with aiohttp. Basically, the same code. He was blown away. 
OKKEN: That’s really cool and I’m glad that he shared that with us. 
KENNEDY: Of course, you do the correct conclusion from this conversation. Look at the ten time increase in productivity that you get from listening to Python Bytes. 
OKKEN: Yes, definitely. You save your company money too from listening to us. 
KENNEDY: Well, that’s it for this week’s news. Do you have anything that you want to share.
OKKEN: Nope, just plugging away on the book. 
KENNEDY: Same here, just plugging away at the courses. 
So, thank you everyone for supporting all of our work. Not just this podcast but Brian’s other podcast, his book, my courses, my other podcast. 
OKKEN: Thank you, Michael.
KENNEDY: See you later. 
Thank you for listening to Python Bytes. Follow the show on Twitter via @pythonbytes and get the full show notes at pythonbytes.fm. If you have a news item you want featured, just visit pythonbyes.fm and send it our way. We’re always on the lookout for sharing something cool. On behalf of myself and Brian Okken, this is Michael Kennedy. Thank you for listening and sharing this podcast with your friends and colleagues. 