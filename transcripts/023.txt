Python Bytes Transcript
Episode #23: Can You Grok the GIL?
Michael KENNEDY: Hello and welcome to Python Bytes, where we deliver Python news and headlines directly to your ear buds. This is Episode #23, recorded April 25, 2017. I'm one of your hosts Michael Kennedy. 
Brian OKKEN: And I'm Brian Okken. 
KENNEDY: We're here to share a bunch of cool Python stuff with you. We've got 6 cool items queued up and ready to go, but before we get to that, I want to say thanks to Advance Digital. They have an awesome Python job. You can check it out at python.advance.net and we'll talk more about that later. 
Right now, I want to talk about the GIL (Global Interpreter Lock), Brian. What do you think? 
OKKEN: I think it's a great to talk about the GIL and I'm really glad. So, this is an article called, “Grok the GIL: How to Write Fast and Thread-safe Python”. We talk about the GIL as the reason why we can't do parallel computing and programming just built-in in Python, but I haven't really jumped into it a lot. This article is from A. Jesse Jiryu Davis, who by the way is an excellent writer; if you want to have some examples of great writing, read his stuff. It's great. He has this very lightweight introduction to what the GIL. I like the approach, not just the details of it, because most of us aren't going to go in and start hacking the CPython core. But a little peek into the CPython core to see that it's a mutex inside.  
KENNEDY: I love how he pulls out little snippets from CPython. He’s got a section, “Behold the Global Interpreter Lock” and it just shows you the C code. 
OKKEN: Yeah, it's just one line. 
KENNEDY: Exactly and you don't really need to know a lot of C to appreciate it, but there's enough to make it super concrete. This is actually the code that runs when you call the socket. That's how the GIL gets released, for example. 
OKKEN: Right, yeah. Talking about sockets, he really talks about that. The lock is around I/O, whenever you’re waiting for I/O. I think there's other places too but that's the main place where your code will pause and let some other thread run. 
He has a thing that says, ‘the effect on threads is so, simple you can write it on the back of your hand. One thread runs Python, while N others sleep or await I/O.’ He actually has a picture of his hand – I think it's his hand. 
KENNEDY: Yeah, I was wondering if that was actually his hand. 
OKKEN: If he wrote it, that means he must be left-handed because it's written on the back of his right hand or he had somebody else write it.  
I was always curious about this. What are the limitations? How do you utilize it to have faster code? The gist of it is, as if you've got some code that's waiting I/O, like maybe pulling off a whole bunch of different of connections or downloading a bunch of urls, that's a great place to use multi-threading because the GIL doesn't really get in your way. In places where you really have multiple processing, where you really want your Python code to run at the same time, then you have to jump into
Multiprocessing. He actually gives an example of that and it's not that bad either. I liked the quick jump into it and I think I'm going to be a better Python programmer for reading this. 
OKKEN: Yeah, this is really nice work. Good job, Jesse. He's a great writer. I had him on Talk Python on Episode #69, I think, about design patterns for programmer blogs and we did a whole session on blogging. It was great. 
One of the things I like about this is he talks about cooperative multitasking concurrency versus parallelism, preemptive multitasking, how sometimes you still need to actually lock your Python code even though you might think, ‘Well, this all straight Python. It is not going to get interrupted.’ But there's certain mechanisms that slightly vary between Python 2 and 3, where if you hang on to the GIL too long, it will be potentially taken from you and given to another thread. So, that might still cause what would appear to be parallel-like race conditions. That's also worth reading about. 
OKKEN: Yeah, and one of the things that surprised me – and I do realize that don't really worry about that – I deal with multithreading in C++. With C++, you have to do it fine grain locking of data structures,
any data structure shared by multiple threads. But I was surprised how much you can share between threads in Python because the GIL won't interrupt a byte code. It will only interrupt between byte codes, not in the C code. Things like sorting a list will happen atomically and you won't be interrupted with that; that surprised me. I didn't know that. 
KENNEDY: It is where, ironically, incrementing a variable could be interrupted. 
OKKEN: Right, because it ends up being like a two-step or read modify right operation. 
KENNEDY: Yeah, exactly. Jesse uses the dis module to look inside, which is all very good. That's a great article. I think that's probably the most substantive thing we’re covering. 
You want to think about not so substantive but pretty cool? 
OKKEN: Yes. 
KENNEDY: I've got one for you. Let's talk about the NBA, as in National Basketball Association. American basketball. So, there was a pretty big deal on Twitter the other day. Mark Cuban, he owns the Dallas Mavericks, and he's, I don't know if he comes from tech or, not I don't really think so but he definitely was an entrepreneur. He's a billionaire basically. But as a billionaire owner of a NBA team, he posted out a pretty interesting thing on Twitter saying, ‘Here's the new NBA’ and it was a picture of him learning Python Machine Learning at with IPython and IPython notebook open. He's like, ‘I need to understand the Mavericks in the NBA. I'm on it.’ That’s pretty cool, right?
OKKEN: Wow, it is pretty cool. I don't know much about basketball or Mark Cuban or any of that, but it's neat that somebody that high up is wanting to learn Python and Notebooks. 
KENNEDY: That was basically the main takeaway. A bunch of people, like our friends over at Partially Derivative, invited him to be on the show. They’re like, ‘Oh, we have to hear his story.’ He's like, ‘No, no. I'm just getting started. They have a team at the Mavericks. I just want to understand what they are doing when they use Machine Learning to help make predictions and planning.’ That's kind of cool to think of how Machine Learning is actually driving these professional sports teams as well. 
OKKEN: Yeah, very interesting. 
KENNEDY: Indeed, indeed. 
So, next up we have somebody winning an award. How cool is that? 
OKKEN: Yeah, Ian Cordasco. It was announced he’ll get the 2017 Community Service Award from the Python Software Foundation (PSF). I think that's pretty cool. I didn't know about a lot of the stuff that he did. He was on Testing Code Episode #13 and we talked about Betamax library that he has for recording and playing back requests interactions. He's apparently been the election administrator for the PSF since 2015, volunteering all that time, of course. He is active in mentoring new coders in supporting other Python developers with a focus on trying to be active in mentoring women in Python. I think that's just pretty awesome. 
KENNEDY: Yeah, that's really awesome. Congratulations, Ian. 
In his project that you talked about, like replaying requests that's called Betamax? 
OKKEN: Yes.
KENNEDY: That's an awesome name. 
OKKEN: Yeah. It's, I guess, the idea of course, there's a VCR type library in some other languages but he chose Betamax because well everybody knows Betamax was better. 
KENNEDY: That's right. 
OKKEN: You should do to listen to it. It's a pretty interesting tool. 
That was one that the community asked me to do. There were community members of listeners of Testing Code that said, ‘Hey. Could you go find Ian and talk to him about Betamax?’ 
KENNEDY: That's awesome. We love to get those recommendations for all the shows, including some stuff that we’re covering here today, right? 
OKKEN: Yeah, definitely. 
KENNEDY: Definitely. If you want to work with these kind of fun things, Brian, maybe you work at a company where you are doing a job and you dabble in Python or you don't really get to do all the cool things you'd like, Advance Digital has a cool job offer for everyone out there who might want to make a change. 
OKKEN: I wish I was near Jersey City because this sounds fun. 
KENNEDY: It does sound fun. Right, they are in Jersey City, just across the Hudson from Manhattan. They’re small agile environments. They're mostly a Python shop, but they play with other cool technologies. They fund you guys to go to conferences, professional development and most importantly and coolest I think, is they run one of the 10 largest news sites by traffic in the U.S. and they do it with Python. If you want to be part of that team, you want to play with cool stuff like that, just visit      python.advance.net and check it out. 
So, there's a couple of things coming up Brian, that have to do with Python versus Legacy Python. Remember, Matthias from the IPython Project, Matthias Bussonnier – I’m sorry if I mess up your name but I think that's pretty close – he was the original guy who got us talking Python versus Legacy Python, as opposed to Python 3 versus Python 2. 
OKKEN: Oh yeah, right. 
KENNEDY: He works on IPython and Jupyter and all that stuff. He's back with a new blog post which is my next item and it's a pretty big deal. 
We just talked about Mark Cuban, the new NBA Machine Learning IPython. So, they just released IPython 6. That's pretty big news. 
OKKEN: That is big news. 
KENNEDY: Yeah. For people who use IPython, there's a brand-new version and that's awesome. The bigger thing is that this is the first release where IPython goes Python 3. They dropped support for Python 2.
OKKEN: That's great. 
KENNEDY: Or as Matthias would say, they now support Python and not mixing in Legacy Python with it. 
OKKEN: Yeah. and 
KENNEDY: What I thought was nice, you know it's a pretty major project, they did a little right up of what was their experience of converting a mixed source code to Python 3 only; what were the benefits and what were the drawbacks? 
So, let's see a couple of things, a couple stats that Matthias put out. The sides of the IPython code basis decreased by 1,500 lines. That's pretty solid, right? 
OKKEN: That's significant. Less code means less maintenance. 
KENNEDY: Right. They said it's not just because they're dropping Python 2, but it’s significant. And even more impressive, they added some entirely new features that required hundreds of new lines of code. So, the decrease in amount of code they had to support for Python 2 they were able to get rid of when they went to Python 3 is probably more. That's pretty cool. 
They said one of the benefits, they think, is that contributors can spend less time worrying about, ‘Well, how does this work if we do it in Python 2?’ Or, this has happened to me, you make a pull request, you submit it. It runs on the continuous integration and it works fine on Python 3, but then it fails in Python 2 because, you know, you forgot the b and the string or whatever, right? So, they don't have to worry about that. CI runs faster. They said, basically in summary, ‘We're totally happy. We’re entirely pleased with having switched to basically have the ability to write Python 3 only code’ and they're looking forward to using a lot of the improvements in Python 3, specifically async and await, which will be cool. So, async and await repel inside of IPython. How cool is that? 
OKKEN: That's neat. Is async and await in all of the three versions or did they get introduced… 
KENNEDY: It came in 3.5. The asyncio stuff was introduced in Python 3.4, I think, and then 3.5, they're like, ‘Let’s put some proper syntax in this. Make it really easy.’ 
OKKEN: I’m writing a little thing that I want to have available on Python 2 also, at least 2.7. Even if I were just to do Python 3, all of the 3 versions, I still can't use F strings. I wish I could use F strings. 
KENNEDY: I know, they're so new; 3.6 only. Even on my production servers, it’s 3.5 so it is what it is.
OKKEN: That’s a move in the right direction and I think it's great that Matthias and others talked about their experience with that change. 
KENNEDY: Yeah, that's awesome. Thanks, Matthias. Excellent. 
OKKEN: I think I'm, to use an American expression, ‘beating a dead horse’ but we have another… 
KENNEDY: (Laughing) Is that dead horse called source. src? 
OKKEN: Yes. The other package I was talking about me building up, it's for the book. But I wanted to make sure I was representing the community correctly in how to put together a distributable package and do it correctly. At least, do it with best practice. I know there's not really a correct but somebody pointed me to the direction of an article by – I’m probably going to get this wrong – I think it's Hynek (Schlawack) and it's called, “Testing and Packaging”. He's the guy that did the ATTRS project that we've talked about a couple times, and how there were issues at least with one package that wasn't using the source src. The testing that was done, there was a bug that showed up in installed applications that doesn't show up in non-installed. So, one of the benefits of using src is, you can more easily make sure that you’re only testing the installed package and not the non-installed. He also just shows that it's really just two lines of code change, so to do the right thing is not that much work. 
KENNEDY: Right. So, basically your setup.py, the call to setup, you sent the package to be looking in the source directory and you set the package setup to be in the source directory. 
OKKEN: Yeah. When you would normally say, ‘Find packages’ he recommends specifically saying, ‘find packages’ and then give it where=src, but you can also just put scr as the first argument. That works, also, then listing it in the packages dir. One of the things I noticed, which I don't think people have really talked about, is the entire repository looks better. You've got all of the package junk, like your set up and your manifest, all that stuff at the top level. And the stuff you really care about on a day to day basis is separated into sub directories. You've got the docs in one and the tests in another, then your source in another. That separation, it pleases my organization; it is nice. 
KENNEDY: Yeah, I’m coming around to this as well. It sounds pretty solid. 
OKKEN: I’ll probably try to drop talking about that every episode, but there you go. One more article. 
KENNEDY: Well, I'm not quite done beating the Python versus Legacy Python horse yet. I'm going to keep going on that one, because there's some more big news. We've heard that IPython went to Python 3 only, and now the same week, last week, AWS Lambda adds Python 3.6 support. It was just 2.7, so that's a big jump. 
OKKEN: Wow, that's a big jump, yeah.
KENNEDY: So, that's pretty awesome. Do you have much experience with Lambda? Have you played with it? 
OKKEN: No, you know I've heard a lot about it but I haven't played with it yet. 
KENNEDY: So, Lambda is one of these things from AWS, from Amazon, that fits into this server-less architecture. Basically, you say, ‘Here's a function and when something happens, run this please.’ So, run it on a schedule, somebody changes the database, somebody uploads a filed S3, whatever, and it just runs. There's no servers that you deal with. Obviously, there are servers, but it just distributes your code to run when it needs to. I'll cross a whole bunch of servers so it scales, basically, infinitely. As long as you have infinite money, you can infinitely scale this. It's fine, right? That’s pretty cool. 
OKKEN: Yeah, so have you tried it? 
KENNEDY: No, I have not had a real reason to do it. I guess there's a couple of things that I could do, like on the web sites there's a job that runs like every couple hours that will completely re-index the database and reorganize it for super-fast queries. The queries on the various websites run and they run like, sub-millisecond. In order to get that stuff, you’ve got to pre-compute some things, maybe that's a perfect Lambda operation, right? 
OKKEN: Especially now that they have 3.6 support, I'm intrigued enough that I might give it a shot anyway. Just to make up some excuse to play with it. 
KENNEDY: Exactly. We need to run this. If you using other AWS stuff, like their database services Dynamo or RDS or S3, here's a way to run code really near your resources on triggers with no effort. 
One of the things I thought was pretty cool, this announcement just came out and Zappa, if you look at their page which I linked, it's called Server-less Python Web Services. That's interesting, right? 
Basically, you can set it up using the AWS architecture. You can route web requests to these Lambda functions, but you don't really have servers or anything like that. And people have been asking for Python 3 support. They’ve been saying, ‘No, no, no.’ As soon as this dropped, they’re like, ‘Yes, it has Python 3 support.’  That is pretty cool, as well. You are seeing things that, basically, are layered on top of Lambda also starting to support Python 3, which is great. 
OKKEN: Yeah, definitely, cool. 
KENNEDY: Maybe we should play with Lambda, I don't know.  Very nice. 
Well, that's it for the news, Brian. You got anything personal you want to share with everyone? 
OKKEN: No. I'm going to be in the Munich area the second week in May, if there's anybody around that wants to have a beer or something with me. Hit me up. 
KENNEDY: Yeah, that sounds awesome. I'm jealous, I’d love to go visit Germany. Well, I'll do that at the end of the summer, maybe, we'll see. But no news for me. 
I just want to say thank you everyone for listening.  Actually, one more thing. It is not personal news but it falls right in here. I also saw CheckIO@CheckIO.org. These guys have a pretty cool like gamification to learning Python. They also just went Python 3. Just to keep on this, Python 3 is starting to really roll. It’s really starting to roll this week. 
OKKEN: I use CheckIO – hopefully I won’t get in trouble for this – but I've gone through a bunch of this stuff and I use them for interview questions. 
KENNEDY: Yeah, I think it's actually pretty good and what I really like is you can solve a puzzle and then you can look at other people's solutions. And I found after solving a bunch and looking at the solutions, I unknowingly have an implicit bias towards performance over ease of reading or simplicity or whatever. It was interesting to uncover that for me. 
OKKEN: Oh, that's interesting and I totally have the opposite. I like them to be readable more than anything else.
KENNEDY: Well, thanks, Brian. Thank you everyone for listening. I will catch you next week. 
OKKEN: And thank you. 
KENNEDY: Yep, you’re welcome. Bye. 
Thank you for listening to Python Bytes. Follow the show on Twitter via @pythonbytes and get the full show notes at pythonbytes.fm. If you have a news item you want featured, just visit pythonbyes.fm and send it our way. We’re always on the lookout for sharing something cool. On behalf of myself and Brian Okken, this is Michael Kennedy. Thank you for listening and sharing this podcast with your friends and colleagues. 