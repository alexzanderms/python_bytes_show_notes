Michael KENNEDY: Hello and welcome to Python Bytes, where we deliver news and headlines directly to your earbuds. This is Episode #43, recorded on September 13th, 2017. I’m Michael Kennedy.
Brian OKKEN: And I’m Brian Okken.
KENNEDY: It’s great to be with you guys, great to be with you Brian. We have a bunch of really cool stuff lined up. There’s a few things that really surprised me, maybe even inspired me to go create this project that we were both chatting about before we hit record. Some very cool stuff. But before we get to it, let’s say thank you to Rollbar. Those guys are sponsoring the show. Check out their offers at pythonbytes.fm/Rollbar. We’ll get to them later.
I want to talk about the future and sending it into the past, like Marty McFly-style. What do you think?
OKKEN: Yeah. This popped up recently, just this last week. I’m not sure what the impetus was but it is “Future Fstrings.” It is a project you could just do pip install future-fstrings. It isn’t a library, it changes the encoding. I’ll just jump to the chase, it’s a back port of fstrings, even down to Python 2.7. I’ve tried it in 2.7, I haven’t tried it in anything else, but it is kind of fun to be able to play with fstrings everywhere.
KENNEDY: I had very mixed thoughts about this when you told me about this project. One one hand, I look at it like you’re taking one of the really amazing and smooth features of Python 3.6 and making it available in Legacy Python. Which is kind of like, do we really want to encourage that sort of thing? But at the same time, I feel like this also lets you, as you’re migrating your code, move to the latest, greatest syntax in Python 2. But then when you actually make the switch, you’re not going to have to go, ‘Well, we used format, because that was the best option in Python 2, but now we’ve got fstrings. So, I feel like that’s really cool.
The other area where I think it’s great is Python 3. There’s plenty of people running Python 3.5, it’s a default on Ubuntu right now, and things like that that don’t have fstrings. I’ve decided after further contemplation, this is a really cool project and I want to check it out.
So, tell people what fstrings are? Most people maybe know, but what’s this fstring thing?
OKKEN: Well, if you’re familiar with the format part – I think that’s been available since 2.7 – in the string that you’re printing you can leave little brackets to show where you’re going to insert something and then you say, (dot) .format and then all the things you’re going to put into the string. In fstrings you just put an f before the string and within your brackets you just put the variable name for whatever you’re going to put in there. Or any expression can go in there. So, you could say, f’hello {thing.upper and then just uppercase the thing in that expression. Or something like that, right?
OKKEN: Yeah.
KENNEDY: That’s really cool.
OKKEN: Yeah, at first I was like, ‘I don’t know if I like it.’ But once you start using fstrings you can’t go back. That’s one of the reason why I like this project, because I usually use Python 3.6, but there are times where I have to write some stuff in 3.5 or 2.7 or something and I don’t want to go back.
KENNEDY: I know, I hear ya. That’s great.
OKKEN: I’m going to put a lot of tests around this so I’m not going to rely on this yet, because I don’t know of it’s really ready for prime time everywhere. So, I would say use caution. Step into this slowly if you’re going to use it. But it’s a fun thing. I’m not sure I like how it’s doing it though.
KENNEDY: It’s doing it in an interesting and odd way.
OKKEN: I don’t know how else it would do it but it’s interrupting the encoding.
KENNEDY: Yeah, it installs a separate encoder.
OKKEN: So, it extends the utf-8, I think, the utf-8 encoding to also do this. So, if you’re not using utf-8, I don’t know. Maybe you could hack it to do something like
you’re using.
KENNEDY: Yeah, it’s pretty cool. So, you put a little encoding flag at the top and you would install a special encoder and off it goes. Pretty interesting.
Alright, so I want to stick with this Python 3.6 feature angle, even though that's bringing that stuff to two other version of Python. I want to talk about the fun of reinvention.
So, this was a really amazing presentation done by David Beazely, and it’s done in the style of some of his other presentations and, in my mind, the way technical presentations should be done. So be up there, writing code, showing how things work, not just slides and pictures and stuff but showing things. So, what he shows though is kind of insane and incredible. Your mind will probably explode if you see this and you’re going to come away with a greater appreciation of Python 3.6.
What he does is, he goes and builds upon some of the new 3.6 features that are below the surface that a lot of people wouldn’t even know about, like hooking into when a class gets defined, so you can basically redefine what that means and things like that. For example, he says, ‘Let’s talk about type hints. The type hints are cool but they don’t do anything. We can add these constraints and assertions inside of our code and that does something, but we can’t really check that in the tooling. But what if we could rewrite, create this little framework using inheritance and all sorts of other stuff that let’s us add these constraints as type hints and then they’re enforced at runtime automatically. It’s pretty amazing.
OKKEN: That’s incredible, yeah.
KENNEDY: So, whether you think it’s a good idea or a bad idea to do that, the fact that you can do that is really cool. You can basically set up a function and as a type hint constraint, you can say, ‘This is a positive integer between zero and 200.’ And it will actually check that. It’s really something. But mostly it’s an amazing look inside of Python 3.6 and down to low-level stuff.
So, Brian, knock knock, who’s there? Sound recognition is there.
OKKEN: Yeah, sound recognition. There’s an interesting article called, “Sound Pattern Recognition with Python.” And I didn’t know you could do this with scipy. Apparently, there’s scipy.io.wavfile and I’m not sure if there’s other types you can use. But this article used scipy to read a .wav file and then just has it as data and an array of numbers, and then does some math on it. This particular one is assuming that you’ve got some .wav files that have knocks in them and trying to detect where the knocks are and how far away they are. And just some basic little logic to try to figure out where the peaks are. I think that the author noticed that you needed to have some minimum values for how you tell where the peaks are and then some distance between them so you don’t have ringing within one peak.
I like it because I think it would extend easily. I’d like to take it and run with it to do some basic scope measurements with this kind of thing. It’s be fun.
KENNEDY: Yeah, it’s be super fun. It’s really accessible; like the actual code to figure out the knocks and to process a .wav file, it’s really small and approachable. To me, what I thought of when I heard this was, ‘Oh you could build something that is actually kind of smart.’ So, it shows you how to identify knocks, right? You should be able to identify a door jiggling, a key noise. You should be able to identify a few of these distinct patterns. And if you could identify like, ‘What does a door jiggle sound like?’ ‘What does a knock, what does a doorbell, what does a key sound like?’ You could put a little Raspberry Pi by your front door that says, ‘Someone's home. Someone unlock the door. Someone’s knocking.’ Just cool stuff. It seems like that’s a weekend project with the this, it doesn’t seem major.
OKKEN: Yeah, that would be fun. You could hook it up with Twilio and get texts when somebody’s knocking at your door.
KENNEDY: Yeah, and hook it up with a camera to take a picture of whoever’s out there, see what they’re doing. ‘Hey, kids came home at 3 o’clock and unlocked the door.’
OKKEN: That’d be fun.
KENNEDY: It sure would. I think people should take this idea and run with it, and if they do they should send us a message. Or even better, go to pythonbytes.fm/43 and leave a comment at the bottom about what they created.
OKKEN: Yeah, definitely. Or even better, they can write a blog post and then email that to us and we’ll highlight it on the show.
KENNEDY: Yeah, maybe we can cover it. That’d be awesome. (Laughs)
Before we get to the next item, which is sort of mind blowing, I want to talk about Rollbar. You guys hear me talk about Rollbar a lot, probably but that’s because they’re great. If you run any sort of web app, you should have real time error monitoring and reporting. So, if something goes wrong with the website – for example, python bytes.fm – we’ll get a notification. It could be on Slack, it could be on the phone and it will have all the details. ‘This person went to this URL. Here’s the variables they passed and the function that caused a crash.’ Things like that.
So, if you want to get this for your site or application, just go to pythonbytes.fm/Rollbar and check it out.
So, we’ve talked a lot about async stuff, right? Async, both on the server and on the client. It’s pretty mind blowing stuff but it turns out that – you know, like all changes to software like cascading consequences of adopting a new model or trying something new. One of the cascading changes is in many of the high performance async processing loops, I’m thinking asyncio but also uvloop, the really super fast powerful one. Things like Sanic is based upon it, the web framework, and so on. Those thing are ultra fast because they rely on asyncio, but asyncio doesn’t use threads. So, that means thread local storage doesn’t have any meaning anymore when all of these concurrent operations are running on the same thread.
OKKEN: Okay.
KENNEDY: If I was running a website, I might store into thread-local storage (TLS) the cookies or the authentication, and then later I might ask for it back. But that could be changed because you have a blocking io that released the thread that somebody else then wrote their cookie to. So, it’s kind of crazy.
There’s also another really interesting place like decimals; working with decimals does this. Numpy.errstate, warnings.catch_warnings, profiling, tracing, all these things use this kind of stuff but it doesn’t work in this async and await world. So, we have a new PEP: PEP 550 that defines a new execution context. This is from the guys at magic.io who created uvloop, so their motivation is really obvious. They want uvloop to work and this is kind of something in the way.
The PEP adds a new generic mechanism for ensuring consistent access to non-local state in the context of out-of-order execution, such as generators and coroutines.
OKKEN: Wow.
KENNEDY: It’s pretty fascinating, right?
OKKEN: Yeah, it’s very fascinating.
KENNEDY: You think it through and obviously it’s a problem, but I hadn’t even realized. It’s like, ‘Oh my gosh, some of these low-level things are just going to be broken.’ For example, state is processed in a web request.
OKKEN: I’ll be very interested to watch this and see where it goes.
KENNEDY: Yeah, so maybe it makes it into Python 3.7, maybe not. But it’s kind of cool that this is not just like, ‘Oh, we’ve made uv work properly, but we’re going to make all of Python work properly.’ And they’ve got some really nice examples in the article we’re linking to.
OKKEN: That’s really cool that they did it instead of just trying to hack their own way.
KENNEDY: Yeah, for sure. Speaking of threads and processing and all that…
OKKEN: I often work in single threaded or single process tasks. I really like this article called, “Intro to Threads and Processes in Python”. It’s a very accessible beginner’s guide to parallel programming. It’s kind of, ‘What’s the difference? Where would you use threads? Where would you use processes?’ It’s even got pictures with some algorithms to show if you’re in a certain kind of job – I can’t remember what the job is that he’s doing…
KENNEDY: He’s doing some data science project based on Amazon and trying to analyze a bunch of different stuff from space, so he’s got to run tons of algorithms and tweak them with different parameters and stuff like that.
OKKEN: It shows that basically if you use one thread, two threads or four threads, then the same with processes, how it’s affected with the running times and you can watch to see that things are running in parallel. And good use of simple diagrams as well.
KENNEDY: Yeah, the pictures are great.
OKKEN: The conclusion at the end is if you’re waiting on io for something, threads are just fine. If you are CPU-heavy, then you want to go with multiprocessing.
KENNEDY: Yep. Until the GIL-ectomy happens, which who knows if that will, but until then this is a good introduction to it.
OKKEN: Having the GIL really really doesn’t bother me. It does simplify how you program, I don’t think it’s that terrible.
KENNEDY: Yeah, it’s in the extreme cases. I think the main group of people who suffer under the GIL are those doing CPU computational work. Outside of that, you’re mostly okay.
OKKEN: So, in async and await and stuff like that – I’m going to expose my ignorance of this stuff – is that dealt with with multiple threads?
KENNEDY: No, it’s all one thread but it has a mechanism to say, ‘Any time you hit blocking IO, put this part of the code to sleep and allow it to run another task until it hits blocking IO.’ The idea is most of the time you’re waiting on databases or networks or something like that, and then you wake up for a second and do a little processing and you go back to wait on another network or database or web service. And as long as that’s the kind of stuff you’re waiting on, the GIL is not a problem because it gets released. But if you’re trying to compute Pi with a power series or something… Something like that, then it would just stop and the async wouldn’t help you with that.
OKKEN: So, the async and await is going to be in the same sort of family as when threads would be good for you.
KENNEDY: Yes, it’s in a similar spot. But just more efficiently.
So, let’s talk about another low-level thing. I found this – I think it may have been recommended by a listener – some low-level part of it, that I found the whole thing. One of the problems we can have when we’re doing unit testing is working with files, right? That can be a serious pain.
OKKEN: Yeah.
KENNEDY: And if you want to save your files to say, user storage or you want to process different types of files like zip files and other regular files, these are all sorts of pains that you have to deal with. But there’s this really cool project called, Alternative File Systems for Python and it makes this all seamless. The idea is you can work with files and directories and zip archives and memory on the Cloud, just as easy if they were on your hard drive.
They give some examples on this project. You could write your code now, just ‘With pen such and such as fin’ and start working with it. When you decide what that ‘open’ means – does ‘open’ mean normal files, does it mean something on S3? – things like that. You can unit test your code in memory files, but ‘open’ reads and writes to those memory files. You can upload your file to S3 or OneDrive or something like that by just writing to that folder in that file system, and all sorts of stuff like that.
OKKEN: Yeah, so the memory files system or the temporary file system that they have would be great for parallelizing tests and things like that.
KENNEDY: Right, it keeps it all separated and isolated. Some of the back ends they have application data. This is like a special user-data location in various operating systems. They have Amazon S3 file systems. They have FTP memory. They’ve got Zip for reading and writing zip files and they also have SSH file systems for writing to remote servers. All kinds of stuff.
OKKEN: Even Tar files, food ol’ Tar files.
KENNEDY: Good ol’ Tar files. Yeah, you can just ‘With open’ on those babies. So, this is really pretty interesting. I haven’t tried it yet but it looks quite promising. And it’s extensible, so you can add more of these back ends if that makes sense for you.
OKKEN: That’s awesome. I actually think this is pretty fun. I have to play with this.
KENNEDY: Yeah, me too. Definitely check that out.
Brian, that’s it for our six items for the week.
OKKEN: That’s incredible that we’re already done.
KENNEDY: I know, these are all fun and they’re all interesting. I really enjoyed researching them this week.
So, what else are you up to?
OKKEN: I got an interesting email this morning, saying that they’ve taken off the beta of Python Testing with pytest on the Pragmatic (Publisher) website. You can order the book now and it’s supposed to ship next Monday.
KENNEDY: That is awesome. Congratulations.
OKKEN: Thanks. That is what I’ve been thinking about.
KENNEDY: I bet. Nice. I’ve been thinking about switch.
OKKEN: Well, I have been, too, as of this afternoon.
KENNEDY: (Laughs) I’m working on a project that would add the switch statement to the Python language without extending it. Just like a class that you can basically use but it’s a pretty clever use of defining blocks and stuff. I think it might be interesting. I’ll put a link to the GitHub reboot at the end of the show notes. You guys let us know.
OKKEN: I really do want feedback on that because I want to try to nail this and I think if we could get it into something we could stick on PyPI or have you do the work.
KENNEDY: ‘Pip install switch.’ That might be a thing, don’t do that. (Laughs)
OKKEN: Yeah, don’t do that.
KENNEDY: Who knows? Yeah, but I think it would be a really cool feature if we could make it work for the language, without actually changing the language because it’s already flexible enough.
OKKEN: Yeah, cool.
KENNEDY: Alright, thanks for everything, Brian. Good to chat with everyone.
Thank you listening to Python Bytes. Follow the show on Twitter via @pythonbytes. Get the full show notes at pythonbytes.fm. If you have a news item you want featured, just visit pythonbytes.fm. We’re always on the lookout for sharing something cool. On behalf of myself and Brian Okken, this is Michael Kennedy. Thank you for listening and sharing this podcast with your friends and colleagues.