Michael KENNEDY: Hello and welcome to Python Bytes, where we deliver Python news and headlines directly to your earbuds. This is Episode #55, recorded December 6, 2017. I’m Michael Kennedy.
Brian OKKEN: And I’m Brian Okken.
KENNEDY: Brian, can you believe it’s December?
OKKEN: Yeah, it’s getting cold out.
KENNEDY: It’s getting cold. I look outside, it’s the middle of the day and it still looks dark. I guess we’re getting there.
Before we get into our picks for the week, let’s just say thanks to DigitalOcean. They have a ton of awesome servers for you. The websites I run run on DigitalOcean. I’ll tell you more about that later.
However, one option, one of the servers I have runs Flask. Brian, I hear you’re digging Flask these days.
OKKEN: Yeah. I’m actually going through Miguel Grinberg’s “Flask Mega-Tutorial,” so I’m pretty about that. I think I took the advice from you to try something simple like Flask at first. Not to slam Flask, but it is a pretty low-barrier entry. And I knew Miguel was rewriting this Mega-Tutorial, so I begged and pleaded and got an early copy of the rewrite and I’m part-way through it right now.
He did a Kickstarter to try and rewrite it. The first one was in 2012. His Kickstarter was very successful, I think. Part one of the rewrite is available right now, today.
KENNEDY: Yeah, that’s awesome. I know Miguel’s been putting a ton of work into the rewrite. I was so excited to see his Kickstarter be successful. He added a bunch of stretch goals to do additional sections, he has an ebook version and a video version coming out as rewards from it. He hasn’t done the videos yet. He and I were just talking today about the videos, so that will be fun. If you want to learn how to get going at Flask, his work is really great. Definitely check it out.
OKKEN: What he’s going to do is, he’s going to release one part every week, but if you can’t wait that long, you can buy his ebook. It’s just like $10 or something.
KENNEDY: Yeah, totally affordable.
OKKEN: That’s what I’m reading right now and he’s says he’s planning on January for the video version.
KENNEDY: Yep. Very cool.
OKKEN: Speaking of new releases…
KENNEDY: New releases and the web, amazing stuff… Django 2.0 is released and this is a huge, huge change. It has been many moons since a major point release of Django came out. After all, it’s still only version 2, right? This is a huge deal and there’s a lot of cool new features. One of the things that they added that I really like and it’s always made me just crazy when I looked at Django is the fact of writing regular expressions for the routing. Which is, ‘I want to take this URL and figure out which view method that goes to.’ That used to be a regular expression, which was painful. Now it’s much more like Flask and Pyramid. You put little identifiers, like variable names in cutout URL and that’s how it maps over. You even have types. You can say, ‘It has to map to /users/userid:enter.’ There’s this nice routing syntax there’s some nice design changes, better querying over some of the query sets. These are all cool. They have a new versioning, what they’re calling a loose form of semantic versioning. If you look at the possible version, we have two. Maybe there will be a 2.1 and then a 2.2. And then that 2.2, maybe that’s something they’re calling stable long term support (LTS). So, it might be 2.2 LTS. Then if they go anything beyond the LTS, that’s at 3. Then a 3.2 LTS. Any time you go into new territory past the LTS version, it’s a major version increment now.
OKKEN: That’s interesting.
KENNEDY: Yeah, so I suspect that we’ll see major Django version numbers coming out faster because of that but I’m not sure. I guess we’ll have to see.
OKKEN: And there is some exciting thing about Python 3.
KENNEDY: Yes, it’s very exciting. The Legacy Python was dealt yet another blow. So, Django has had a significant disproportionate influence on the adoption of Python 3. For example, when they switch their tutorials by default to use Python 3 versus Python 2, that dramatically changed the usage by numbers on PyPI. So, now they’ve actually dropped support for Python 2. It’s the first version of Django that says, ‘Thanks, that’s not for us. It’s Python 3 only going forward.’
OKKEN: Yeah and because of that, I've seen a few people mention on Twitter that working with the code base is a lot easier now because there were a lot of backwards compatible things in there. They were able to clean up that code base quite a bit for this, so I think it’s great.
KENNEDY: I think it’s great as well. Definitely makes working on new features easier because you don’t have to write them twice, in some sense. And there’s a bunch of small changes, I don’t want to read them all off to you. But just to give you a sense, down in django.contrib.auth, luckily they’re doing password hashing in folding. So, not just hashing with salt, but then you take that and you hash that, and you take that and hash that. They used to do that 36,000 times but now they do that 100,000 times so it’s more computationally expensive to guess the password of the database or to leak. There’s tons of cool changes like that throughout there as well, but probably the biggest one people will notice is the simplifying URL routing.
OKKEN: Yeah, it’s nice.
KENNEDY. So, you’ve got a bunch of rules for us or something, huh?
OKKEN: I do.
KENNEDY: What’s up with that?
OKKEN: I’m usually someone who doesn’t follow a lot of rules, but one of the things I embraced when coming into Python is the notion that there’s kind of a coding style that everyone follows, or a lot of people follow on Open Source projects, which is PEP8 and then it’s extended. When I started using type checkers like Lint – or at the time I started it – the way to check for PEP8 was a tool called PEP8. The name has now been changed to pycodestyle. But now, I’ll usually use Flake8 for my linter. So, Flake8 covers pycodestyle, which is PEP8, and then it covers pyflakes, which does a lot of traditional Lint stuff to catch bugs. And then a McCabe Complexity Checker. That one I’ve tried to figure out several times and I don’t know what it does.
KENNEDY: Yeah, Cyclomatic Complexity is a pretty interesting metric for code maintainability. So, the idea is how many different decisions paths are possible through that code. If you had a method of Cyclomatic Complexity 5, there’s five separate execution paths that could go through there. There could be one ‘if case’ that doesn’t really return, another that’s an if/l/if/l/if. And taking all the possible ways that you could go through those conditionals and groups and whatnot, there would be five possibilities. Basically, you need five tests minimum to cover that.
OKKEN: Okay. I’m not sure what the check is for McCabe, or what the Complexity number is that they’re flagging for. But I usually turn it on anyway, because I want to know if my code is a little too complex.
The issue with it is, a lot of these spit out an error message with a one liner, explaining what it is. So, what I have for us today is called, “The Big Ol’ List of Rules” which translates all of those errors and warning numbers into very nice one page descriptions of what they are with links to more information. I really like it. I’m going to be using this all the time now.
KENNEDY: That’s really cool. I feel like there’s an opportunity. First of all, well done Grant (McConnaughey) for writing this and putting this out for everyone. But I think there’s an opportunity for editor plugins, whether you’re using Sublime or code or PyCharm or whatever. You could probably get a plugin that would turn that into a hyperlink that shows the details from this list, and that would be awesome.
OKKEN: Yeah, so PyCharm checks for all of this stuff and I usually turn it on for pytest, too. I have my pytest plugin to check Flake8. Once you find an error, trying to fix it, it’s good to know what it is.
KENNEDY: Yeah, especially when it’s ‘e112.’ What the heck does that mean, right? You may be really good at know it, but I don’t know. Awesome.
So, before we get on to the next item, I just want to let everyone know that this podcast and really, all the sites that I run are coming to you through DigitalOcean. I have – gosh, it's a growing list – I think I have eight servers there now, doing all sorts of hard work and working together on various services and database connectivity and whatnot. Super excited about working with DigitalOcean and talking about their stuff because it’s really been great to work with. If you’re looking for cheap, reliable, fast servers, that are simple and not a huge mass of a thousand features like you might get at AWS or Azure. If you want to have a server and work with it in a really nice way, check them out at DigitalOcean.com and let them know that Python Bytes sent you.
OKKEN: Nice.
KENNEDY: Yeah. We can probably contact them with requests, as well. We can probably do some sort of API and talk to them. But if you want to test it, you need to mock out your requests, right?
OKKEN: Definitely.
KENNEDY: There’s a few things that make testing tricky, one of them is time, the other one is the network and external services, some of that being requests-type things, some of that being databases. Any chance you get to cleanly mock that out is really nice. This one actually comes from a friend of the show, Anthony Shaw. He has this thing called requests-staticmock. I think we were recently talking about something with mocking requests and he’s like, ‘You should check out requests-staticmock.’ So, I did and it’s pretty cool, so I decided to make it one of the things we’re talking about this week. The idea is you can create a requests session then mock that out like, ‘Hey, I want that return a 503 service unavailable.’ Or, ‘I like when you make this request to this URL. Return this JSON file after the response.’ So, really easy to swap out the testing behavior if your code, somewhere deep down, calls into requests, but you can do it without monkey patching.
OKKEN: That’s the neat part, it’s without monkey patching or doing a lot of these test-based mocks. It’s pretty cool.
KENNEDY: Yeah, it definitely is. You don’t really mock stuff as much, you kind of just plug in the session.
For people who don’t know, the session object is a thing that comes from requests, which is actually pretty interesting. Suppose you’re going to start talking to a service and every single request has to have an off-header; it has to have, maybe, a user agent, it has some other details, some kind of token-type thing, who knows. A lot of shared. Or if you’re going to try to submit a form and then you need to take a session on the server, like a cookie-based session, and then go and do other things, you can’t do that with just straight requests so easily. You create one of these sessions and it keeps an persistent connection, it handles the cookies across all the requests, and stuff like that.
So, that’s really handy. What Anthony’s thing does is create a sort of testing session variant of that. It’s pretty cool. You can mock that thing out.
OKKEN: And the way you put it together, too, is the data that’s coming back, you can set it up like a tree structure in your file system. It’s kind of like your old school HTML directory.
KENNEDY: Try it with some index.html and all that kind of stuff. They just put it in there and it traverses that; it’s cool.
OKKEN: It’s nice. A nice interface for the developer as well. It’s cool.
KENNEDY: Well done, Anthony.
So, you’re going to give us a preview of Python 3.7, right? Because there’s some pretty awesome stuff that just got approved, or finalized.
OKKEN: Data Classes, which I didn’t know was on the fence for awhile, but they’ve been approved by Guido (van Rossum) and it's PEP557. These are kind of a different form of regular old classes but you can put a decorator on their for a Data Class. And then you can say what data elements and what type they are, and you can assign defaults. And the cool thing about that is you don’t have to write your own _init_ statement, it writes one for you.
KENNEDY: The first time I saw these I was like, ‘That’s not valid Python. What language is this?’ So, you can say, ‘Class C:’ and ‘a:int’ (new line) ‘b:int’ (new line) and you just start out with a class that when you create it that has an ‘a’ and a ‘b’ and those are both known, right? And you can even set default values. It’s pretty cool. It lets you do more of the define part of the class structure instead the self.attribute=value through the dunder_init_. But like you said, it still generates that dunder_init_ and moves over the default values.
OKKEN: I kind of like the syntax. The first time I saw it, like you said, it’s bracing and it’s like, ‘This isn’t Python.’ It’s kind of nice that you can just put that in one place and not worry about it too much. It’s pretty clean.
KENNEDY: Definitely. I find myself doing this sometimes and I’ll just have to set everything to none or to zero or something like that, because it won’t work otherwise. But guess what? It does now.
OKKEN: It’s cool. I also just found out that there is a 3.7.0a3 developer build that’s out that has this in it, so if people want to play with it they can. But I probably wouldn’t do much production code with it because 3.7 isn’t scheduled until June.
KENNEDY: Okay, yeah. It’s still a little ways out but still exciting to see this coming. I think this is pretty nice. One of the things that this is compared to and looks somewhat similar to is attrs. Attrs gets a lot of attention as well. What’s the story between those two?
OKKEN: I know that Heidnik – he’s going to clobber me for getting his name wrong – I think he was involved in talking with the core developers and talking about this Data Class, but I’m not sure. But anyway, attrs is still great. These Data Classes don’t do everything that attrs does and it has more validates and converters and a bunch more stuff that you can do. It doesn’t completely take the place of attrs but for simple cases, I think it’s a simpler interface.
KENNEDY: Yeah, okay. That sounds good.
OKKEN: The best example that I’ve heard of why the people wanted it in there is because the core developers wanted to use it on Python itself, and you can’t use a non-standard library stuff within the core of Python.
KENNEDY: Yeah, I think that’s a really interesting point. Attrs is changing fast. It’s still getting a lot done to it and you don’t want to hamper it and cover it in quicksand or some sort of tar. You want to slow it down by sticking it in the standard library and going, ‘Well, you can only change very slowly now and only every year.’
OKKEN: Same reason why requests isn’t the standard library, right?
KENNEDY: Exactly, same reason. So, for our final thing I want to start with our first thing. Flask.
My version of Flask I want to talk about is three times faster than your version of Flask. How does it do that? There’s this thing called Quart. I haven’t done much with Quart but it’s kind of like a wrapper around some of the asyncio stuff, but also an API that can run Flask apps. Like I said, I haven’t done a ton with it. But Quart is this thing that you can use that has the same API as Flask, but is asyncio-friendly. You can plug it into the super fast things like uvloop or asyncpg or Asynchronous PostgreSQL, which is pretty awesome. And there’s some really amazing benchmarks there.
Flask, along with Django and along with Pyramid and all the others, they don’t support any asyncio stuff. They can’t take advantage of basically releasing the thread to do do other work when it’s, say, waiting on a database or on a call over requests or something like that. Just because they’re all using WSGI, that’s not how WSGI works. So, you can plug in Quart, which basically has the same API as Flask, and you just have to make a few minor changes to get your code to go much faster.
So, here’s an article with the demo application and they’ve got benchmarks and stuff saying, ‘We’re getting roughly three times the speed by just switching a few things around.’
OKKEN: Yeah, I think that’s cool. I definitely need to try this.
KENNEDY: Yeah, so the things you have to do obviously, if you want to take advantage of asyncio is you have to make your functions async. Otherwise, they’re just regular functions. They go the same speed. So, you would put async in front of your view methods and then when you call into things like databases, web services via requests say you have to await those to basically tell Python, ‘Give up my thread, I’m waiting on this. Pick it up when it gets back. Put me back somewhere further down on the loop when this returns.’ So, that’s all cool, but your database access has to have some sort of asynchronous component. When you do a query, you can wait on it, otherwise it’s kind of useless again. That’s why it’s both Quart but also asyncpg, which is pretty cool. It’s not entirely easy to switch over, depending on what you’re doing. Like, if you’re using SQLAlchemy. SQLAlchemy I don’t believe supports anything with async so you’re out of luck. It depends on what you depend upon, actually. It’s easy to switch if it’s going to work at all, how’s that?
OKKEN: Yeah. One of the things that I think is neat about this that I think is a clever idea, instead of inventing a completely new framework, it is a completely new framework. But I think it’s a good idea to slow down the learning curve. You’ve got to figure out the async stuff, but you don’t really have to re-figure out how the framework works, because they said the framework is just like Flask.
KENNEDY: That is such a good observation and it’s really right. There’s http.io, there’s that, there’s Japronto, there’s Sanic. There’s all these other frameworks trying to take advantage of things like uvloop and async and await, but they’re like, ‘And you start from scratch.’ (Laughs) ‘And you learn a totally new framework.’ With this, you could probably go take Miguel’s tutorial and then go make it faster. It’s kind of cool.
OKKEN: And that’s what I plan on doing. (Laughs)
KENNEDY: Alright, well, that’s our news for this week. Brian, anything you’ve got going on?
OKKEN: No, I’m just trying to learn Flask, man.
KENNEDY: Awesome. That sounds really fun. So, are you familiar with the Pythonic Staff of Enlightenment?
OKKEN: Yes, I carried it around for awhile at PyCon.
KENNEDY: So did I. A lot of people probably don’t know about this but there’s a picture of me with Anthony Shaw, who I mentioned in the mocking bit. I’m walking around with this giant, I don’t know, it’s probably four feet tall, this big heavy staff and it has a massive Python logo. So, one of the guys that was involved in creating that thing originally actually decided that since so many people ask for it, he’s creating a store where you can buy your very own Pythonic Staff of Enlightenment. He’s like, ‘Eh. Would you mind letting people know about the staff?’ I’m like, ‘Yeah, it’s pretty cool. I’ll let people know.’
OKKEN: I haven’t checked it out yet. Any idea how much it is?
KENNEDY: I think it’s $100 USD.
OKKEN: I may need one anyway.
KENNEDY: Well, Christmas is coming. Everyone needs a cool Python staff for Christmas. Anyway, I thought that was fun so I thought I’d put that in there at the end for you guys.
OKKEN: That’s nice. Cool.
KENNEDY: Alright. Brian, great to chat with you as always and thanks everyone for listening.
OKKEN: Thank you.
KENNEDY: Thank you for listening to Python Bytes. Follow the show on Twitter via @pythonbytes and get the full show notes at pythonbytes.fm. If you have a news item you want featured, just visit pythonbytes.fm and send it our way. We’re always on the lookout for sharing something cool. On behalf of myself and Brian Okken, this is Michael Kennedy. Thank you for listening and sharing this podcast with your friends and colleagues.