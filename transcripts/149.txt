00:00:00 KENNEDY: Hello and welcome to Python Bytes where we deliver Python News and Headlines directly to your earbuds. This is Episode 149, recorded September 18th, 2019. I'm Michael Kennedy.
 
00:00:11 OKKEN: And I am Brian Okken.
 
00:00:12 KENNEDY: And this episode is brought to you by Datadog, tell you more about them later. Brian, this first item that you have here, it actually sparked some philosophical sort of, challenge to my way of seeing the world here. So, why don't you run it by and I'll tell you about my problem. Maybe you can help me through it.
 
00:00:29 OKKEN: I'm curious about this now.
 
00:00:29 KENNEDY: Yes.
 
00:00:31 OKKEN: I'm pretty sure we covered this before but uh, Dropbox is kind of behind a lot of the push to do different type checking or type hinting and checking those type hints within Python. The mypy project is I think spearheaded by Dropbox.
 
00:00:48 KENNEDY: Yes.
 
00:00:49 OKKEN: There's an article they put out called Our Journey To Type Checking 4 Million Lines of Python. Wow, 4 million lines. That's a big code base.
 
00:00:58 KENNEDY: That's a lot of Python.
 
00:00:59 OKKEN: Yeah!
 
00:01:00 KENNEDY: I wonder how much of it's interconnected. You know, like, you've got all these subtle utilities and nothing actually depends on it directly. Maybe they depend on the output. On the other hand, there could be like a super complicated sort of monolith thing. It's interesting to think about that much code. That is a ton.
 
00:01:17 OKKEN: They're leading a lot of stuff, but one of the, I like this. So why, I mean that's not free. You don't have a huge code base and move it to type checking. You don't get that for free, so there has to be benefits to this cost. And that's one of the things this article does talk about. Their, it does go through some of their story of how they did it. What I really liked is it covered some of the benefits. And this isn't even that surprising. It says "Experience tells us that understanding code becomes the key to maintaining developer productivity." and that it grows with a larger code base. So without type and annotation, basic reasoning such as figuring out what the valid arguments to a function are, or the return types, that's a key one for me, becomes a hard problem. And just answering those questions quickly, more quickly, what does this function return, does it return none sometimes, can it return none? Things like that. These become more and more of a drain as you're looking at a larger code base. I mean that's definitely true. You spend more time reading code than writing it. So thinking about the types as you're writing it and putting those in place, especially for interfaces to functions, those are an easy win, I like it. They talked about some of the other benefits that the type checkers actually finding subtle bugs that they wouldn't have caught easily without it, refactoring becomes easier. And then running the type checking is faster than running the suit of unit tests so the feedback can be faster. And I didn't think about that aspect of it. That's pretty interesting to include type checking as part of a TDD flow, I haven't tried that. That'd be kind of fun. And then one of the things I do know is that the IDEs, such as Visual Studio Code and PyCharm, allow for better completion and static error checking, and a whole bunch of goodies that you get from the IDEs if you have type hints in there. But anyway, the other part of this story that I think is, they talk about is the improvements to mypy to fit their needs. And so if you like mypy now, it's probably because Dropbox needed it to be really good. So anyway, it's a good article.
 
00:03:30 KENNEDY: I'm a big fan of type hinting and stuff. I think all these things here that you've laid out, I definitely think they're all true. I would say absolutely the biggest one for me is making the IDEs and the editors just better. When I get the return value function that declares its return type, and I hit dot on that variable, boom there's the list of the things that I can do. I type one or two characters, it auto-completes. You can just fill it out. Yes, it's in the docs, what comes back from some of these things. Yes, you can go look them up, what arguments or what operations you can do on them. But if it's one character or two you're typing and it's just always there, it just massively improves what you're doing and your confidence, and the speed, and it doesn't take you out of that flow. And I really appreciate that aspect of it.
 
00:04:15 OKKEN: One of the things that made me embrace more and more is things that can return multiple types because we definitely can do that in Python. So arguments that can be set to None but are either None or a boolean, or that can be an element or a list of those types of elements. Those sorts of things are great because if they're one of the types most of the time, you don't even really think about making sure that it works for the other one.
 
00:04:40 KENNEDY: For sure. So you want to hear my philosophical dilemma?
 
00:04:43 OKKEN: Yeah, I do.
 
00:04:44 KENNEDY: Alright, so in that article it says something to the effect of mypy is an open source project and the core team is employed by Dropbox. One of the people who is doing major work on this project is Guido van Rossum, yeah? I think he did something in Python like created things like that, right? He created the language and whatnot. And it wasn't until, I don't know, well into the 2010's or something like that until type hinting became a thing in the language. So Python was created, its core essence is a language without type declarations, right? So here's my philosophical debate. Would Guido have gone back and said in 1991 actually a little bit of type hints should of been how Python originally came into the world, or is this something that you have to got through and you're like oh, it's fine when you have 100 lines of code that don't have any type information, but if your have four million, all of sudden you're in a bad place with four million and hundreds of people working on it. Well all of a sudden these types now are super valuable because here he is working explicitly on this thing that he probably decided not to have in his original language. And there's my dilemma.
 
00:05:58 OKKEN: I think it's the size thing. It's helpful for large projects. For tiny, little things it's not. Has it ever bothered you that there are no type-like declarations in bash scripts?
 
00:06:10 KENNEDY: Yeah, not really I guess.
 
00:06:12 OKKEN: I don't do really huge bash applications.
 
00:06:15 KENNEDY: Yeah, that's probably some form of anti-pattern right there, isn't it? Yeah, I don't know, maybe it's also the tooling, like the editors do a lot more with that information now.
 
00:06:24 OKKEN: It is an interesting question of why didn't it have it to begin with.
 
00:06:27 KENNEDY: If someone else was working on this, sure, okay, these are two philosophies and they kind of come together or don't in different ways, but it's the same person, right? So that's my thought as I was looking through this article. But cool, I'm happy to see them doing it and I like to bring this sort of stuff into my code as well. I think it makes it better.
 
00:06:45 OKKEN: All right, well what do you got for us?
 
00:06:47 KENNEDY: I did mention that we have these editors these days that do so much more than they did in 1991. And namely this would be PyCharm and Visual Studio Code. Those are the two main ones. Obviously there's others, but these are the main ones that are super rich. Our friend, Miguel Grinberg, decided he was going to put together a cool video about setting up Visual Studio Code to work with a full-fledge flask application.
 
00:07:13 OKKEN: Yeah!
 
00:07:14 KENNEDY: So with PyCharm I think it's pretty straight forward. PyCharm kind of is what it is. You go in, here's the project, I see that. Here's how I run stuff, here's how. It's really clear what you do. There's a lot of stuff coming on there, and it's really busy, but you can look at it and see what you're supposed to do. With Visual Studio Code, I don't feel that way. I look at it and I go I know that this thing can be configured and adapted to do all this amazing stuff, and it gives me no bread crumbs or hints on how to even take that first step. I'm like man, I know this thing's cool, probably. But I'm just going to edit this file and go on, right. But this is a video that also has a blog post version from Miguel. And it's actually a followup to doing the same thing in PyCharm about a year ago. And I think the reason he did it in PyCharm, even though I just told you how easy it was, is he's doing it in PyCharm Community, which is not officially able to support web development. It's the free version. So he's like how do you set up a web development project in thing that's not meant for that or officially configured for that or whatever. Anyway, so he goes through and he walks you through all the steps. And you know what? It's really nice and I think that the grand finale you will appreciate here, Brian. So as I think a lot of people do. So all right, here's what we're going to do. We're going to set up, we're going to clone the repo, create a virtual environment. We're going to install the requirements and configure environment variables, maybe run some custom Flask commands like flask deploy, which initializes the database or does database migrations and all that kind of stuff in the terminal, before we actually get to the editor. And this is how I work as well. How 'about you? Do you, like, start within PyCharm or do you kind of get to it eventually?
 
00:08:53 OKKEN: Oh no, I'm the same thing. I'm setting up, well I got a little extra hooks to create an environment and activate an environment 'cause I'm doing that on the command line all the time anyway. Like from the clone a repo and stuff. I'm just going to do that.
 
00:09:08 KENNEDY: Same, and I have all these aliases and stuff that will do multiple steps at once and make it a little bit nicer and so on. All right, so all that is in terminal. But then he says all right, here's what were going to do with VS Code. You're going to open the folder, which is a thing you can do in VS Code, and it will automatically find the virtual environment. But in order for all that stuff to happen, you have to encourage Visual Studio Code to go into Python mode. So just open any Python file, and that activates all the little subsystems that fire up like the environment variable detection, and all that kind of stuff. The virtual environment detection and so on. And then he says all right, now what we want to do is how do you run the thing? So he talks about how to set up a run configuration in the debugger to open the debugger tab, add a configuration, and you can actually pick Flask. And it knows all about Flask, it asks you a couple questions like what's the app.py called, and things like that, so then it'll set it all up. And then you can run it in the debugger or run it without, and that's pretty nice. And then he says finally there's another thing about this UI that, like I said, it's kind of like water. It can be whatever you want, but you don't look at water and go I bet that could be a sculpture of a seal if I froze it and carved it down, right?
 
00:10:21 OKKEN: Our example is a picture. Go on.
 
00:10:22 KENNEDY: Yeah right. Like okay, ice sculptures. So there's another command you can run in VS Code, and this I didn't know about, is you can ask it to discover Python tests.
 
00:10:32 OKKEN: That's nice.
 
00:10:32 KENNEDY: Yeah, so you can say discover Python tests and it'll hunt through and find all the tests in your project, and it'll even offer a what test frameworks do you want to run. Do you want to run unit test or pytest or whatever. And then once you do that, a new UI element pops up and now you can run your tests and a pretty cool runner. So it's about a half hour video. It's good, I think, and there's something really nice about seeing it in action. I'm a big fan of learning through video stuff, as people might imagine since I've put some time and energy into it, but it's one thing to read it. It's another to see that process gone through and explained step by step and Miguel does a good job and I like it.
 
00:11:10 OKKEN: At the end, he also talks about a limitation of handling crashing Flask applications with a debugger. And he says it's a Flask thing, not a VS Code thing, so you have to do it in book by VS Code. But he shows you the little work around.
 
00:11:26 KENNEDY: Yeah, basically you have to stop going through the Flask run option and go to the flask.py or app.py, run it, and then overwrite some settings and they'll run there. Yeah, it's pretty straight forward, but that's definitely a nice touch as well.
 
00:11:40 OKKEN: Yeah, and then the other thing I wanted to touch on is when he's showing how to run tests in the video, they're just sort of magically running in the background, and you don't see what they're doing. And he doesn't cover this, but at the bottom of the screen, or at the bottom of your VS Code window, there's some icons that show you the status of the tests. And if you click on that, that's where you can go look at the output and look at the failures and whatever.
 
00:12:04 KENNEDY: Yeah, very cool, nice. So that's a good one. Another thing that I am a big fan of is parallel programming. And you've got a few things on that one for us, huh?
 
00:12:12 OKKEN: There's an article called 'Multiprocessing vs Threading in Python: What Every Data Scientist Needs to Know.' Talked about multiprocessing and threading. It did not talk about async, and I don't know if that's appropriate or not, if async's even something that would be useful for data science or not.
 
00:12:32 KENNEDY: Sometimes, not computationally though.
 
00:12:34 OKKEN: In any case, I liked it because a lot of people from data science are coming into programming. Like, you know, they're coming in not as programmers, they're coming in from other fields. So there's a lot of background computer science knowledge that they just don't have. Or there might be gaps. So that's one of the reasons why I picked this, because I like it. I like that it talked about some of the basic concepts of parallelism, parallel computing, how to think about it, it has some diagrams, and then what the difference between multiprocessing and threading is in general, specifically threading is within one process. You've got a bunch of stuff going on. And multiprocessing is a bunch of processes. But there's trade-offs. And then it also talks about specifically that Python has a GIL so it's a little different. But because of the GIL, so it talks about the thread's wait. You can use either one, but in general the general rule of thumb is CPU intensive work you need multiprocessing. If you're IO bound or waiting on users, then threads are fine for that. So the surprising bit to me was the charts and some of the graphs that he has. Because he sort of does some bench marks of code running something on both CPU intensive and IO intensive work and how it speeds up with multiprocessing and multi-threading. Obviously throwing more processors at it helps, or more threads, but what surprised me is that the difference between the two wasn't really that great. I thought it would be more pronounced. Basically if you're not sure which one to use, pick one and it'll speed up your code.
 
00:14:21 KENNEDY: Interesting, yeah.
 
00:14:22 OKKEN: I kind of thought it would be, even with CPU intensive stuff, at least with what stuff he was showing, that even multi-threading helped speed things up. So I think this is good. And then he goes through a couple specifically data science examples and shows the code, and how to throw multiprocessing and multi-threading at data science problems.
 
00:14:42 KENNEDY: That sounds super useful, and the comparisons are interesting. These benchmarks are always so full of land mines and special cases, and I didn't use it that way so I didn't get the right results that you said. They're just so tricky to get 'em right, but it is cool to have them here. I like that a lot. One thing I would like to throw out there is a lot of times you have these I could do it this way or I could do it that way and we'll see what we get. And then sometimes it's this, sometimes it's that, so now you got to know two APIs and how you combine them. And I'm a big fan of the unsync, U-N-S-Y-N-C library which takes the async programming model and applies it to multiprocessing to threads and async methods and makes it all nice and clean. Just a couple decorators and they're all the same.
 
00:15:28 OKKEN: So do you still have to pick?
 
00:15:29 KENNEDY: You have to pick at the implementation level. So imagine you have three functions. One of them is async, 'cause it actually implements async and await, it uses that. One is just a regular function you'd like to run on a thread. One is a function that does computational stuff and one does waiting. So you just put a decorator. You say @unsync on the regular async one. That will run an asyncio on the one that's doing waiting stufF, it would work for threads. You just say @unsync and it automatically runs on threads if it's not an async method. And the last one, you would say @unsync(cpu_bound=True). But then once you consume those, the way you program against it, they're all the same regardless of which style it is. So it's like when you define the function, I'll go oh this is a CPU bound one, this one is actually async so it just is async and it just adapts. So it's a pretty cool library. It's 126 lines of Python in one file and it does all that to unify all these APIs, it's great.
 
00:16:28 OKKEN: Oh, that's cool.
 
00:16:29 KENNEDY: Yeah, so pretty cool. Anyway, yeah, this is really nice and certainly something people want to think about. It's a little bit tricky. We'll see if this is still a discussion in a couple years. In Python 3.9, there's talk of maybe using sub-interpreters to remove the limitation of the GIL inside a single processes and all sorts of stuff. They're working on that. So if they actually got that working, then you'd probably be better 'cause you can share data better, more richly, and faster within a single process. It's about to get even more crazy, so.
 
00:17:01 OKKEN: That's a long discussion, like how much do you have to. How much more do you have to care about, like blocking and stuff like that.
 
00:17:08 KENNEDY: Yeah, it brings all that stuff back in because you don't have the GIL anymore. There's, actually with the sub-interpreters, they're talking about a mechanism to explicitly share data in a safe way between them. Still, it's faster though. Cool, well speaking of making things faster, if you're looking at your app and you're wondering what's going on, it would be nice to see everything that's going on across all the layers, across the database, across the web tier, things like that. So you should check out Datadog, they're sponsoring this episode. It's a modern cloud, cloud-scale monitoring platform that brings together metrics, and logs, and distributive traces all in one place. So it auto-instruments things like Django, and Flask, and Postgres. It means you get to see everything across all those boundaries. And it helps you optimize your Python apps in just a few minutes. Start monitoring your environment for free and get a sweet Datadog t-shirt. Just visit pythonbytes.fm/datadog to get started.
 
00:18:02 OKKEN: Nice.
 
00:18:03 KENNEDY: Well not to be outdone by your async stuff. I also chose to async stuff here. So remember we talked about Starlette a little while ago. And Starlette comes from this Github organization called Encode, E-N-C-O-D. And that place is full of magic. So they have uvicorn, which is the ASGI server, that's pretty awesome like Gunicorn but for async based on the UV event loop, a UV loop event loop, and so on. And there's Starlette, there's also Django REST framework, but there's httpx, which we talked about last time. And the last thing I want to cover is a few more things in here, 'cause like I said, there's a lot of great stuff. There's a project just simply called ORM, we've got SQLAlchemy and Django ORM, and these guys just decided you know what, just the term ORM is free in Python so let's just do that. Which is an async ORM. And they also have a thing called databases which adds async support for talking to all these different databases, Postgres and whatnot. So this is a really cool project, especially this ORM one, because it's kind of like SQLAlchemy and it's actually based on the SQLAlchemy core for building queries. And that gives you a bunch of benefits. That means if you already have some stuff that works with SQLAlchemy to some degree, it will be similar. It means that Alembic, which is the tool to do database migrations on SQLAlchemy also works with this ORM so you can automatically just apply Alembic to it and that's pretty cool.
 
00:19:39 OKKEN: Wow.
 
00:19:40 KENNEDY: Yeah, it uses this database project that I talked about for cross-database async support. And it also has this thing called type system for data validation, which is pretty cool. I hadn't heard of that, either. But yeah, it's a really sweet async API for working with databases ORM. So the way you create the models, it's very similar to SQLAlchemy. It's not identical, but it's similar. And then from there on, you just work with it kind of like you would do normal ORM stuff. Like I would say if I'm working on an album, I might say album.objects.create or maybe I would do some kind of filter so I'd say track.objects.filter and I would do something. But every one of these operations is async so you just put await in front of it. And if you have something you got to scale a whole lot of concurrent data traffic like a website, well this is a pretty good combo.
 
00:20:36 OKKEN: Okay, so like in the future, will we just have await in front of every other word?
 
00:20:42 KENNEDY: Everything, exactly. So I was going to point out that you got to be pretty async and await savvy to be doing it. There's a lot of awaiting, isn't there? I think if you want to work with this library, you just have to say we're just going all in on async. That's the way it goes, right?
 
00:20:58 OKKEN: No, it's good. If you're already working with async, that's when you would think hey I wonder if there's an async ORM that I can use.
 
00:21:05 KENNEDY: Yeah, yeah it looks good and I like that it's based on SQLAlchemy core. That means a big chunk of the database conversation, and the table creation, and the migrations, all that stuff is already known, and proven, and working really well. It's just this API around the side of the tradition SQLAlchemy conversation. Like directly with the database. I do wish that SQLAlchemy would take this approach. I interviewed Mike Bayer about it long time ago, and like four years ago he said I don't really think it's going to make that big of a difference. But I think it actually would make a huge difference. You just got to think about what is your goal. If your goal is performance, it probably won't make a big difference. If your goal is scalability, it can make a tremendous difference. Are you trying to make an individual user's experience a little bit faster or are you trying to make the website not take 10 concurrent users but 10,000? It probably might even make it a tiny bit slower for that one person, but it might make that 10 to 10,000 like no big deal, so. It depends on what you're after, right?
 
00:22:11 OKKEN: Yeah, definitely.
 
00:22:12 KENNEDY: Speaking of what you're after, what's next for us?
 
00:22:14 OKKEN: One of the things you might be after is some data on somebody else's website. Like through an API.
 
00:22:19 KENNEDY: Yes.
 
00:22:20 OKKEN: There's more and more people, and I think it's great doing the data science stuff with people coming into Python and programming from just trying to get their work done. And this is a dataquest.io blog post called Getting Started with APIs. And it's not getting started writing APIs, it's getting started consuming them with Python. If you've kind of know what all this stuff is but you haven't really thought about the basics, that's why I picked up this post is because it's really good with the basics as a conceptual introduction of what web APIs are versus what a website is. Kind of what the differences are and why. Also why have APIs if you can just, people could just store the data in CSV files. That'd be easier, wouldn't it?
 
00:23:07 KENNEDY: That'd be amazing! I'd love to live in that world. No.
 
00:23:10 OKKEN: No, but there are a lot of datasets out there that are just CSV files sitting around.
 
00:23:17 KENNEDY: It depends if it's dynamic, right?
 
00:23:18 OKKEN: Right, dynamic and also if you want to specify it. So with APIs you can have parameters to your queries to say I only want the data for this user. Or they gave an example of Spotify music or something. You don't want to have all the data for all the songs that Spotify knows about. But maybe just the songs from a particular artist or something. So things like that are good. This is actually the first time I've seen this, and they're probably all over the place, but talked about status codes, especially GET status codes because that's what we're doing here is retrieving things. And it had a nice list of all the descriptions and things that you might run into for error codes, including like the 301, which isn't necessarily a problem, but you're getting redirected so maybe you want to know about that. And then the 400 is something's not wrong on their end, it's wrong on your end. The server thinks you made a bad request. So that might be an endpoint that expects data or parameters but you didn't send any parameters with it.
 
00:24:24 KENNEDY: Or you sent an int and expected a string, or whatever.
 
00:24:27 OKKEN: And then talks about endpoints and endpoints that take query parameters, endpoints being these specific APIs. So we think of a service providing an API but it's usually not just one API. It's usually a whole bunch of related, different bits of data that you can query together or query separately for different aspects of it. And then of course what APIs usually return is JSON data so it has a little bit of an explanation for what JSON looks like. And then using the JSON module to convert back and forth between native Python stuff and JSON. And it also talks about requests and a bunch of examples for how to pull this, so. If you're getting started trying to pull some data from an API somewhere, this is a good way to get started.
 
00:25:15 KENNEDY: It's a nice blend of theory and stuff. I did just say well you open up requests and you do this. It's like here's what an API is, here's what the HTTP verbs mean, here's what's the status codes are, here's how you get to that and how do you manifest that in Python and stuff. Yeah, it's nice.
 
00:25:32 OKKEN: Yeah, but it's not at the level of like a college course lecture. It's just enough to get the concepts right.
 
00:25:38 KENNEDY: Exactly, it's not trying to make you read the RESTful dissertations and things like that.
 
00:25:44 OKKEN: Yeah, I don't even know if it mentions REST, even though that's what we're talking about.
 
00:25:47 KENNEDY: Cool, that's probably a good thing. That was overdone for awhile. Now last thing I want to cover is memory management in Python. This is an article entitled Memory Management in Python. But what it really is is it's a narrow slice, but a common slice of memory management in Python. So you probably don't think about memory very much in Python, huh Brian?
 
00:26:05 OKKEN: No, I usually forget about it.
 
00:26:06 KENNEDY: Yeah, just forget about it. That's right. So you don't use malloc, or free, or new, or any of these things. Definitely not delete. If you use delete, it means something else, sort of. Things like that, right? So I think it's actually pretty interesting that the story of understanding how the runtime experience is in CPython, it's kind of opaque a little bit. There's not a lot written about memory management which is why I decided to pick this thing and talk a little bit about what it covers because I think it doesn't really matter that you know this in some sense, like your Python code will still work, but you more closely understand what your code is doing, how that might map over to CPU architectures, and caches, and RAM, and all that kind of stuff. And, you know, just having a high level understanding that's good. So here's a pretty deep, detailed article, not too long, you can get through it pretty quick, about memory management in Python. But it only covers, like I said, a little bit. It's really about how does small object allocation and deallocation happen in Python. It doesn't talk about the GIL, which is about thread safety and memory allocation. It doesn't talk about reference counts. It doesn't talk about garbage collection, or cycles, or much else. So it's all about small objects. But most things we make in Python are small objects, even when they're big, they're really just a bunch of small things all pointed at each other. So if I've got like a list of a million items, I don't have, each of those items is 10 bytes, I don't have 10 million bytes, I have this big list with a bunch of things. But then each one of those is a pointer out to its actual thing that it is. Even when you have strings, or even numbers. A lot of languages, numbers are allocated on the stack and treated as value types and stuff. But everything is an object. So every little thing that you make has to get allocated and deallocated. So understanding how these small objects get allocated, that's pretty interesting. So that's what this article talks about. So I'll try to summarize some of the stuff covered there. One of the problems you have with memory allocation is that memory can get super fragmented. If I just allocated a bunch of stuff, and then deleted, and keep allocating, and just let that grow, just keep adding on on the end wherever the memory is, and I want to interact with that, that can really mess up like reading from RAM, and getting stuff on cache to be high performance, and stuff like that. So what Python does is it actually pre-allocates these little 256k chunks, and then it partitions those up, and it plucks in the small objects into those spaces, and then will potentially take them back out, and then reuse those spaces that it had already allocated when it needs to make a new small thing, okay? Alright, so that's supposed to help with memory optimization, the locality stuff, the fragmentation, and so on. So there's a special memory manager in Python called pymalloc, general purpose allocator, on top of like C's malloc, there's a Python allocator. So there's like this layer. We have RAM, we have the operating systems, virtual memory management, we have C's malloc, we have this pymem, pymalloc thing. We have the Python object allocator that then figures out where to place these things, and then we actually have object memory. So there's a lot of stuff going on here, and they break it into three levels of organization. So for small objects, which are things that are individually smaller than 512 bytes. Not like maybe a list that has a bunch of stuff, but each little bit smaller. So those are the things we're talking about. And what happens is it gets broken into these three things called the block, the pool, and the arena. So a block is a chunk of memory of a certain size and it only holds Python objects of a certain size. So maybe there's a block that holds 16 byte Python things.
 
00:30:08 OKKEN: Okay, that's weird.
 
00:30:10 KENNEDY: Yeah, so the reason is Python can then, it knows how to exactly fill up and then reuse those blocks.
 
00:30:17 OKKEN: Oh yeah, okay.
 
00:30:18 KENNEDY: So if it's like okay, I'm going to get a bunch of numbers, all the numbers are the same size unless they become utterly huge, so we can just allocate them into the spots and those numbers go away. We got another block, we drop that new number pointer in right there, or the number which we then point at right there, and so on. So there's these different blocks. Each one is a uniform size between 8 and 512 bytes. And then the blocks are managed by this thing called a pool, which is usually limited to a memory page size, so 4 kilobytes. And then the pools are managed as these things called arenas and these are the things that are allocated on the heap. I believe they are 256K pieces of memory which hold 64 pools, which hold some number of blocks, and things like that. So there's this really intricate way in which memory's trying to be grouped together and then also trying to be reused without re-allocating it from the operating system. Right, so even though Python might new up a bunch of objects, it actually says well but we already have this block that holds those size of things, and there's some spots in there, so let's fill that bad boy up.
 
00:31:25 OKKEN: Oh, all right.
 
00:31:26 KENNEDY: Yeah, anyways so it's pretty interesting how all the stuff is working together, but that's the Python small object allocator.
 
00:31:33 OKKEN: Never thought that before, but kind of interesting. Also I'm trying to visualize a sports arena with 64 swimming pools in it.
 
00:31:42 KENNEDY: That's not a bad one. And each pool is filled of exactly the same size people or creatures swimming around, something like that. Yeah, there you go. That makes a lot of sense. The first part of it totally made sense. The last bit maybe not so much. All right, well anyway, what I like about this article is it seems like it has a lot of stuff from like here's the actual C-code that defines what an arena is. Here you can see it's like a double-linked list and how it all fits together, and it's just got a good analysis. So have a look if you've wondered about this. All right, well that's it for our main items. I know, Brian, you have big news for the entire world if they live near Portland.
 
00:32:19 OKKEN: If they live in Portland, or really close to Portland.
 
00:32:22 KENNEDY: Or want to come to Portland.
 
00:32:24 OKKEN: September 26th I'll be speaking downtown at the Portland Python Users Group. And I'm still working on my talk, but I'll be there. That'll be fun. And then I'll probably polish it more. And people have to volunteer for this other talk, so on October 6th, it's the inaugural first day of meeting the Python PDX West so we've got a new user group for Python in town. I'm hosting it, along with you.
 
00:32:52 KENNEDY: Yeah, it'll be fun, I'm really looking forward to it!
 
00:32:54 OKKEN: Yeah, and you'll be speaking there.
 
00:32:55 KENNEDY: I will.
 
00:32:56 OKKEN: And I'm trying to get other people to volunteer to speak. And if they don't, then it'll just be you and me speaking, but I think it'll be fun. We got a bunch of people signed up so far, so it's filling up fast, so people should sign up.
 
00:33:08 KENNEDY: That's cool, maybe we could do a live PythonBytes sometime there as well at the end of the day or something, who knows.
 
00:33:13 OKKEN: That's a great idea.
 
00:33:15 KENNEDY: Maybe not Tuesday, October 6th, but maybe someday we could make that happen.
 
00:33:18 OKKEN: Maybe someday, yeah.
 
00:33:19 KENNEDY: Yeah, that's great news. If you happen to be around, definitely drop in, that'd be great. It's on meetup.com, people can just sign up there.
 
00:33:26 OKKEN: Yep, and the link in the show notes.
 
00:33:27 KENNEDY: Do you have any intention of recording, live casting, or otherwise spreading this in a farther path?
 
00:33:34 OKKEN: It's not a bad idea. We don't have anything like that set up right away. In the future, maybe we could do that. Probably people would be interested in watching these. But I also want to make it really accessible to people that are new to presenting as well. I'd love to have people come in and do a talk that they're working on that's not quite polished yet. I want it to not just be experts talking to everybody else, but I'd like it to be people working out things that they're just interested in. So I think will be good.
 
00:34:03 KENNEDY: Yeah, that sound like a great philosophy for it.
 
00:34:05 OKKEN: How about you, any extras?
 
00:34:07 KENNEDY: I have a couple presenting and speaking PyCon 2020, which is a little earlier this year. I believe it's like in April or something. The website's up, yeah. So April 15th to the 23rd. So the call for proposals is now open for PyCon 2020, so if you would like to be considered, a talk of yours to be considered there, then now is the time.
 
00:34:29 OKKEN: Yeah, go ahead and submit those 'cause you know you're already going to spend like a week writing it up anyways so you might as well get that done right away.
 
00:34:36 KENNEDY: That's right, do it like a bandaid. Stop worrying about it, just get it over with. Pull it right off. Another thing, have you heard of GitBook?
 
00:34:43 OKKEN: Yeah, but I haven't really looked into it much.
 
00:34:45 KENNEDY: I hadn't either, I was interviewing the guy, Joe, from the Masonite web framework, and I noticed that Masonite's documentation is written in GitBook. And so I looked at it, and GitBook is pretty interesting. You can use it as kind of like almost a base camp project management type thing, so stuff, personal notes, or things you want to track, or stuff like that, but you can also use it for documentation, and knowledge bases, and whatnot. So it looked pretty cool and so I thought I'd just let people know that it's out there. It's free for small teams with some limitations. It costs a little bit of money for non-trivial small teams like seven dollars a user, but it's also free for open source and non-profit teams which is kind of cool. So I'm also a big fan of Read the Docs, so I'm not saying they shouldn't use that, but here's an interesting project that I ran across that I hadn't heard of.
 
00:35:38 OKKEN: It looks nice if people for some reason are opposed to Read the Docs, I don't know why you would be, or just like this look better. Here's another opportunity, so good to have options.
 
00:35:48 KENNEDY: Good to have options. Also good to have laughs.
 
00:35:50 OKKEN: Yeah, let's do some jokes.
 
00:35:52 KENNEDY: All right, how about you go first?
 
00:35:54 OKKEN: Okay, so I pulled these out of a list of dad jokes, you had posted somewhere on our Trello, but changed it a little bit. So what do you call a 3.14 foot long snake?
 
00:36:05 KENNEDY: I don't know.
 
00:36:06 OKKEN: Well that would be a python of course.
 
00:36:08 KENNEDY: With the Greek symbol thon, python.
 
00:36:10 OKKEN: Yeah, so if it's not feet but 3.14 inches, then what is it? It's a uPython.
 
00:36:16 KENNEDY: It's a uPython, a mu Python. Yeah, I feel like we're back in calculus or physics.
 
00:36:22 OKKEN: Yeah, so do you want to do some of these?
 
00:36:24 KENNEDY: Sure. So why doesn't Hollywood make more big data movies?
 
00:36:28 OKKEN: I don't know, why?
 
00:36:29 KENNEDY: NoSQL. This last one, it's a little bit crass. I don't know, it's a little low level, but I'll see what I can do here. So why didn't the angle-bracket div get invited to the dinner party?
 
00:36:40 OKKEN: I don't know, why?
 
00:36:41 KENNEDY: It had no class. Oh yeah, that's a good one. All right, well thanks for throwing those in there. These are fun.
 
00:36:48 OKKEN: Yeah, thank you once again for talking with me on a nice Wednesday.
 
00:36:52 KENNEDY: Absolutely! See you later.
 
00:36:52 OKKEN: Bye.
 
00:36:53 KENNEDY: Thank you for listening to PythonBytes. Follow the show on Twitter via @PythonBytes, that's PythonBytes as in B-Y-T-E-S. And get the full show notes at pythonbytes.fm. If you have a news item you want featured, just visit pythonbytes.fm and send it our way. We're always on the lookout for sharing something cool. On behalf of myself and Brian Okken, this is Michael Kennedy. Thank you for listening and sharing this podcast with your friends and colleagues.
 
