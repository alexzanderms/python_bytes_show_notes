00:00:00 Hello, and welcome to Python bytes where we deliver Python news and headlines directly to your earbuds. This is Episode 178. Recorded April 15 2020. I am Brian Aachen. I'm Michael Kennedy. And this episode is brought to you by Digital Ocean. Who's first? I think my got my notes wrong. Yeah. Well, I want to talk about something really quick before we actually get to the first one. So we'll see. Okay, I just want to tell people about the YouTube channel. And obviously, if people are watching on YouTube, they might know about the YouTube channel. But most people subscribe to our podcast and we are multicasting and repurposing what we're doing here on YouTube. We talked a little bit about it last time. So basically, each individual item is now a separate YouTube video and you can watch Brian and me talk about it if you want to consume in that format, have a little bit of video and admire Brian's awesome shirts, because he's got a bunch of gonna be wearing throughout these different shows. And it's gonna be awesome. Oh, you didn't have to set it up like that, man. I only have like one good shirt. So love the shirt. For the first video. We said that was like several comments about dude, your shirt is awesome. Yeah, go figure. Okay, so

00:01:08 Python also but some fashion shirts in fashion? Yeah, yeah, it's a Python byte set. FM slash YouTube. People could check that out. Well, tell me about strings Python. I mean, Michael,

00:01:19 I'll tell you about Python strings. You know what strings are confusing man, especially when they're about numbers, and dates, especially dates. So this seems to be like a problem that vexes me permanently. And it's, you know, we talked about is programming googling, right? Like, our consensus was, you know, maybe in the early stages of your career, there's a lot of googling, but no, not really, you mostly just sit down and you think about the problems and you write the code, and you evolve the code. Like, there's a lot of reading code before you actually do much writing anyway. Yeah, but this topic, in particular, I'm all about googling this all the time. So Python has a date time dot sturb p time for string pars time, do you give it some piece of text like Wednesday, April 15, comma 10, colon 30 am without a space, I want to take that and turn it into a date time. So I can maybe compare it to something else, right? Like another time, how many days is that from now is that in the future is in the past, I just need to store it in the database as not a string, but a date time because I want to order by it. I don't want it to be alphabetical. Right? There's all sorts of reasons you need to get a date time from strings or go in the reverse. And yet, the format that's ster p time has a, it has a format string that tells it how to look at the string and then pull the pieces out. So would you know about that example I told you about like Wednesday, April 15 10:30am. That's definitely something I google every single time every time and it's never quite right. So just for those of you listening, you really want to know it's percent a space percent capital A B, space percent capital H, comma, space percent, capital M colon, percent s, AM, whoa, who would ever come up with that? Well, I mean, these are intentionally short. Yes, I know. So that like they don't take up too much room. But they're, and they sort of make sense. It's just it's arbitrary, whether it's a capital Y, or lowercase y, or capital D, or lowercase E, right? And there's documentation you can go find like, if you want the three letter date, day of the week, that's a percent a lowercase and whatnot, but putting it all together can be tricky. So what I want to tell you about is this website by Blache Len eaglin. And it's, let me see what the URL is. It's pi stir f time.com, which, of course, is linked in the show notes. And the idea is you put the text you want the pars, like Wednesday, a 15, April 2020 at the time, or whatever, you put that in there, and you hit go and it will tell you that complex string that I told you was the right answer to my parsing problem. Yeah, it's awesome. Yeah, you just put in like the the output that you wanted to have happen. And it tells you the magical incantation, right, right. Or the the format of the thing you want to parse and depending on whether you're trying to go to that string, or from that string, but yeah, super, super handy. This bad boy is bookmarked for me for sure, because this is way better than googling. I can put it in there. It gives me a quick, quick answer. I can throw it into a Python repple and see, hey, did it work or did it not work? It's really easy. Yeah. Nice. Yeah. So not super complicated, but very handy. So people can bookmark that and try it out. Well, I want to tell you about something easier. Also, I gotta gotta thank jack. JACK McHugh has sent us a few suggestions and they're usually pretty darn nice. And here's this one's from jack pandas dash book a book Boca. Oh, I forget to say that. I love the logo, pandas bouquets and I say book I don't know. You know, but it's like that F stop difference where like the person in a portrait is like

00:05:00 But the background is faded. Yeah. And the logo is pandas clear bouquets like in the background faded. It's beautiful. That's pretty cool logo. So I'm going to quote some from from their website, or the readme, it says pandas bouquet, provides a bouquet plotting back end for pandas, geo pandas and pi spark DataFrame, similar to the already existing visualization features of pandas, importing the library adds a complimentary plotting method plot underscore Boca on data frames and series. Okay, so that's, I mean, it's already built in and all it provides is plot bouquet, another function, what's the big deal? Well, it's so cool, it's so easy. And I was I tried out some of these examples this morning. And it's just a little tiny bit of code. And you call like, you've got a DataFrame. And you call plot bouquet on it, and it pops open, like an interactive graph that you can look at everything, it's actually pretty incredible, you have to do something a little different, you plot, okay. But if you want the normal plotting to do the same awesome stuff, though it's built in, you can set an option, one of the pandas options to switch out the plotting back end. So that's neat. So apparently, what it's really doing is switching out the back end. And to me, I mean, it's plotting is not terribly difficult. But this interface, at least for me, it makes it a lot easier instead of having to work with frames and plots to just call this thing. And then all the different options you can have, you can, you know, different points. Normally you don't want it to look like an Asterix instead of a point or something. All are different color, different scale or different titles, all that stuff is options, you can pass into the plot function. And the other thing that I that I like few more things. One of them is you just win your pip install pandas dash polka, it pulls everything in, because it's all the rest of the stuff is dependent on it. So you get all of it just for a simple install. And it also generates a generator, it's able to do this interactively. But you can also generate with notebooks, yeah, you can generate notebooks. And you can also generate standalone HTML files with this in it. This is really cool. And yeah, the fact you can generate a lot of HTML, there's probably ways to plug it into flask sites, you know, Python websites, and whatnot. Pretty straightforward. And the interactive bit is super nice. I mean, this is not about pandas interaction, per se, this is just bokeh, right? Being very interactive, but you can zoom, you can pan as you move around, you know, like, it'll show you the marks on the graph. And you can hide, you know, sort of hide and show elements. And there's even a cool example where they're showing the stock price of Apple versus Google. And as you put the cursor along, it has the Apple logo next to Apple and the information like a little like card that talks about it over time. Man, this is nice stuff. And all you got to do is pointed at a DataFrame. Not bad. Yeah. And they've got a whole bunch of examples on their GitHub repo with a bunch of working examples, too. Obviously, for the examples, the data is just sort of random data that they've thrown in there. But you know, once you know how to get your data, this does the rest of the work for you. So it's cool. Cool. Yeah, it's a great one. And thank you, jack for recommend it. And yeah, it's a good one, Brian, for pulling it out. We've had digitalocean as a sponsor for a while, and we really want to thank them, they've really helped us out a lot. And they're plus, they're pretty darn cool. So thank you, digitalocean, for sponsoring this episode, and many others. And in the past, we've told you about a lot of awesome things with digitalocean, like their one click Install Kubernetes cluster support, their amazing news Support Center and help documentation has been around for a while. And our podcast runs on digitalocean. We're thrilled with it. And so if your business or your side project deserves great hosting and growth that will grow with you and let you scale affordably, I really definitely want you to swing by Python bytes.fm slash digitalocean to grab the $100 credit for new users. But there's something else I want to tell you about digitalocean that's really cool. They've got something they've started recently that's called the hub for good. And it's designed to support COVID-19 relief efforts were digitalocean through this as supplying $100,000 in infrastructure credits for new not for profit profit projects. They're also giving 50 K to COVID-19 relief fund a their own really fun, but still it's really cool. And they're also trying to raise awareness for COVID-19 related projects, and provide learning for developers and also provide visibility for these projects. And so I headed over there this morning and checked it out. And there's a bunch of cool projects starting out that are related to COVID-19 is not just this sort of stuff, but it's things like there's even a platform to help teachers interact with students during

00:10:00 Florentine. You want to pull projects through this? So thank you. digitalocean. Yeah, that's a great project. And obviously, the infrastructure is great. And we'd love it. But this is this is very cool, too. I didn't know about this. That's pretty. Yeah. So speaking of not knowing, you know, it's, I feel like I've been kind of exploring the Cave of Python, which is large and vast. And I just come on, like a whole nother area. I mean, I just think it opens up like, what is this? How am I not known about this? And this is MB Dev. Have you heard of NB dev? No, yeah. Okay. So let me tell you about it. I'll get your impressions later. So NB dev takes notebooks, and basically makes them on par with writing proper Python packages, and solves all these different problems. It lets you generate what's got to be some of the best documentation period for that library that is sort of backed by a notebook. So it lets you develop, like full Python packages and libraries and notebooks where you can have all your code, your unit tests and your documentation all in one place. But then you can take it and pip install, you can upload it to PIP and make it a pip install of a library that people have no idea that it came from a notebook. Wow. Is that crazy? Or Wow, that's awesome.

00:11:16 Yeah, yeah. And, you know, you think about this idea of notebooks and to me notebooks, like burst on the scene in the 2010 ish era, maybe 2012 2011. Like that timeframe. But this project References This concept envisioned by Donald Knuth, way back in 1983. That says notebooks finally made literate programming this concept by Donald Knuth, I think so, you know, the old is new again, but in a really cool way. And to me, that seems like just such a massive upgrade to notebooks. So notebooks have a bunch of challenges. In my view, like, I can't use a proper editor with it. Like if I don't use PI charm or VS code, and all of its navigation, and it's cool, get blame and like, history. And just like all this stuff, is just not present. Right? documentation. I think that actually, it really works well there. Right. But it's, it doesn't tie the documentation of the notebook to like parts of functionality that might be created by the notebook, which is cool. One of the biggest problems with notebooks, it's a benefit, but it's a big problem is, if you run a notebook, it stores the output in the notebook. So if you had like a bokeh plot, or you had like a print of a data frame that is in there, and now it's part of it. So if I'm working on a project, and you were working on the same project, and we both run the notebook, at different times, or the same time, but separately, and for some reason, generates different results. That's a merge conflict and get, right. So basically, you cannot use notebooks in like a sane way with Git. Because anytime you work with it, if you're not careful, and like don't remove all the output, before you save it, there's going to be a merge conflict. So this project has a git pre commit hook that will remove that problem. So right before it gets committed, it'll automatically do the cleaning of that metadata output. So it'll never have that as a conflict. It also has an ability to like a seal, I go, just accept it, I just accept all the metadata changes, minor, just right, or whatever, right. So it also has a COI to automatically fix that. But if you do have those problems, but it also has this pre commit hook to avoid them entirely nice. That's a nice use for pre commit to Yeah, it's super, super clever. So if I write a function in the notebook, I can put hash export in that cell. And that becomes a public function in the package. Oh, cool, right. So I write like documentation and pictures, and I say hash export. Now, that's part of my library that I'm building. It also lets you create the structure for Python packages. So you have like the setup, py. And you can do the build wheels and whatnot, automatically out of that. And it uses this export ID stuff, you can have your unit test in your notebook, which is pretty cool for the things that are in there. And then finally, you can edit it, you can take the edited library or the library, export it right and then edit it with PI charm, or VS code, and then reverse export it. So what you can do is like, say, push the changes that I've done with my editor back into the segments of the notebook where that code came from, man, okay. I'm a little confused, but I got to try it out. Yeah, you got to kind of read through it to get the sense, but there's just a bunch of stuff. Like all these things seem like yes, you should have been able to do that with notebooks, but obviously, right. That's not their origins, right? They can't do everything at once. But all of these things seem awesome to me. Yeah, yeah. So in order to get started, it's going to basically create a Git repo for you as my understanding either on GitHub or Git lab. So you got to follow the Getting Started instructions, and then you click a button and it'll like generate the repo in the right structure, or you can use the Seelye tooling to generate like the right repo with things like the git commit pre hooks and whatnot. And if you're going to read the docs, check out in B dev

00:15:00 fast.ai cuz this comes from fast AI, people the same one as the build the fast API framework. So some of the docs render better. There's certain things on GitHub that like it says, and here's a cool picture. And it's just like source code. It's not quite right, so,

00:15:17 so maybe check out the final link at the bottom in this section to get to if you're gonna, like browse through it, but it's basically, you get the same thing out of GitHub anyway, this, to me seems like a massive improvement for notebooks, and sort of brings them more into, I can do things like for example, you can now have your notebook and its tests running as part of continuous integration. So these notebooks are now like full participants in ci CD, you can upload, you can create packages and put them on pi pi. There's all sorts of neat stuff. The documentation, if you have a cool graph as part of your notebook that can become the documentation on pi pi, or read the docs for this function. I mean, it's crazy cool how this is like taking some of the awesome parts of notebooks, like the doc side and turn that into the help docs, and then also letting you export the functionality still as a proper CES type thing. Yeah, definitely check this out. I do not even know this existed. Like this is awesome. Well, I don't know how long Oh, I mean, it looks like it looks like five months. Semi is my guess. Okay, so we're not that behind the ball or not behind. Yeah, but this succeed? Yeah, it's very fast. It is pretty cool. So I think this is probably pretty solid. Yeah, I agree. It's definitely got some solid people behind it. So very cool. Very cool. Anyway, NB Dev. quite neat. I want to talk about something a little not neat. A little light hearted. So this is sort of a serious topic. But this is a article from Sebastian, entitled, stop naming your Python modules utils. And I don't think we've I don't know if we've covered it before. But it's good advice. And it's something that happens. Basically, a lot of projects public or private, will at some point end up having a utils.pi or a utils package or something. And this article is just saying, resist the urge. utils is arguably one of the worst names for modules, because it's very blurry and imprecise. Some of the names did not say what such a name does not say what the purpose of the code inside is. And on the contractor utils module can well contain almost anything by naming a module utils software developer lays down perfect conditions for an in cohesive in one cohesive, whatever code Bob. And I have definitely seen this in action, I have been one of the culprits before of having a pulling out a little helper function that I had in one file. And I wanted to use it in a different module. So I didn't know where to put it. So I stuck in a utils. py added a couple more. So there's just a few methods. And I come back six months later, and there's like, a couple dozen, just junk drawer functions from all over the place in there. So if you start people add junk to it. So Sebastian lists a few excuses. It's just one function. But it grows, there's no other place in the code to put it. Well try harder. And I needed a place for company comments. I don't really know what that means. But name it company or something. And also Django does it? Well, I don't know, if you're a well, maybe they shouldn't have, but they haven't now, so they're not going to change it. So the advice is to try name, try grouping your utility functions, and naming them based on the role of how you're going to use it, or possibly group them in themes. And also, if you see a utils.py, crop up in a code review, just request that the person rename it to something else, if possible, instead of a CI rule to break the build, if you see that file name.

00:18:59 Yeah, so what are your thoughts on this? And utils? See, I agree with Sebastian, absolutely. I understand the challenge, because like naming things, and software is hard. But naming things and software is super important. Because, you know, when you you think about like even just like function names, or class names or whatever, right? Usually, what will happen is you'll get like a crummy, vague name, and then a comment describing what they are doing. And you're like, Well, why don't you just make the name a little bit longer. That says what it does. And utils is kind of like the generic catch all of saying, like, well, I couldn't come up with a name. So here it is, we're just gonna drop it here. And in my code, I have like tons of different areas of which I organize it, you know, sort of like sub modules, I guess, if it's a sub packages, if it's a package, but not sometimes it's not technically a package. And I tried to come up with names that are meaningful, right like, I have something called number converter that will like try to parse an integer or return it

00:20:00 Default Values sort of throwing an exception, or they'll try to parse some other thing, or maybe it's called conversions.pi, or whatever. But it's not like utils. Right? Like there's, there's usually some kind of better structure you can find that will help you do this. But you know, there's that joke that, you know, naming things in computer science. That's one of the hardest problems. Right? And I, I do agree with that. But yeah, it's, it's worth the effort when you get it figured out. If you don't believe me, you can just try it sometime. If you're working on group project, just put one function in utils. And you will see it grow.

00:20:33 Like the broken window. Theory of software. Yeah. And misc doesn't count either. If you'd name it misc, it's just as bad. That's right.

00:20:44 Yeah, there's probably some synonyms here in the code world, that dog cat. So yeah, awesome. I want to tell you about this one next, that helps with performance or understanding that performance more specifically, of your code. So I don't know if you how much profiling you guys do your work. How much does performance matter to you guys? matters a lot? Yeah. Yeah, I'm building things that go into testing in a production line. So every millisecond that it takes takes it a millisecond longer to get something shipped. So yes, matters. Yeah, matters, I suppose mostly spend my time on the web. And obviously, it matters there. Right? Like, every hundred milliseconds, I think Amazon measured is like 1%, loss of orders or something ridiculous like that. Right? Like, so. Yes, understanding your performance is good. We've had good good in quotes, profilers for Python, and they typically tell you about this function spent this much time. But another challenge is, my program is using too much memory or worse. It's something long running like a web app or some background process. And it's like growing. It's like, sort of leaking memory. Why is that? So I came across this project called scaling, which is a high performance and high precision CPU and memory profiler for Python. Cool. Yeah. So it lets you either analyze CPU time, or it actually lets you on a line by line basis, say, here's some memory, what line made this? And where's it going wrong? Yeah. And so that's cool. But one of the challenges for profiling is when you're profiling your code, you can make it you don't get the same behavior. It's sort of like the Heisenberg uncertainty principle, right? It does one thing, but when you measure the profiler, you've changed it. So now you kind of got to say, well, that part where was the network, that was 50%. But now you made this the computational bits way slower. So that network part looks just like 20, right? Like it's, you're affecting it. So for example, if you use profile the built in profile, it can make your code 30 times faster, or as simple scenario, than running it normally. But you can use C profile, which is the C base one that's built in, and it only slows it down by 1.65 times. So that's not too bad. There's a line profiler that's 11 times slower. And there's a whole bunch of other ones. There's a memory profiler that's like, over 1000 times slower to the scaling thing has a nice comparison to all these things. It says, Well, how does scaling do? And it claims that it's got this built in library that's much faster. So for CPU stuff, it's 1.04 times the speed, so like, 4%, slower? And it does that through sampling? Right? It doesn't do instrumentation, it doesn't rewrite the stuff, it actually just asked frequently, like, Hey, where are you in the code, but it still gets per line analysis of that, which is pretty cool. And then the memory one is like another 10% slower, because analyzing memory is hard. But yeah, there's all sorts of cool stuff you can do with it, the overhead is not too bad, the precision is pretty good, too. Like I said, it gives you like line by line level of how much time you're spending in various places. It also is interesting in that it separates out the time spent running Python code from native code, including like the base libraries and stuff. So usually, like, I can only affect the Python stuff, the other stuff is not a thing I can deal with. So don't tell me about it or punish me for it. Or maybe I do want to look at it right. Tell me about that. So that's pretty cool. Also, the memory stuff, I think, is pretty cool. So it says it points to specific lines of code responsible for memory growth. And it is important, it does this through a special memory allocator thing that comes with it. And so while you can pip install scaling, you can inspect the memory allocation, that way, you have to go and install it directly and do some more setup. On Mac OS, you can do brew install, there's instructions in there on how to do that. On other lessons, I have no idea what you do. But you can't run the memory allocation directly. You have to you can't just say pip install it and then do the memory allocator there's something other like lower subsystem that has to get installed

00:25:00 for that to work, yeah. And memories interesting one because it's a it's a difficult one to chase down with Python. Yeah, it's very hard in Python because everything is a pointer. Everything is an indirection. It's not like Well, here's the block of where we allocated this object, or whatever, right? Like it's, it's pretty indirect. And so and you don't typically have a hold of pointers in the like, the dress sense of it, like you do in C or something. Right? So it's Yeah, it's challenging. Yeah, I would love to see this integrated into pi charm and VS code. Oh, yeah. Right, right. Now, it just gives you, it gives you like a cool tabular text output or file output. But if you could just right click and pi charm and say, analyze what scalene that'd be sweet. Yeah, I wonder. And that also, that would solve some of the install things. So if you have to install it separately out something integration with Python or VS code would be cool, right? Like right now you can do profiling, and it's really awesome in PI charm, but I'm pretty sure it uses c profile. So yeah, who knows, someday there? They will. We're talking about others. I don't know about vias code, but I do know, backing up a little bit. I do know that pi charm does open notebooks. Okay. So awesome. Yeah, back there. Anyway. Yeah. Nice. I want to tell you a little bit about testing. Also, I'm really surprised that you're and you're covering so. Okay.

00:26:17 Yeah, it's interesting. Lately, you've been covering the testing articles. I know. Isn't that my role now? Now? Go ahead. This is great. Tell us about it. Yeah, this is a person named Carolyn that wrote an article called from one to 10,000 test cases in under an hour. Beginner's Guide to proper that's productive. And imagine if Carolyn was getting paid by the test, right, like, we're evaluating your bonus for the year, like, I wrote, five times, many tests. Anyone else? And I just started this month.

00:26:47 I would tell us, if I was paid by the test case, I would definitely use hypothesis on every project.

00:26:54 So how did you do this? What is this property based testing? Okay, so hopefully people have heard of property based testing, but it is. So the, it's as opposed to like, what do we call it? example, based testing. So and this is kind of how she goes through this discussion. It's it says, the article is really just a really excellent introduction to property based testing and using hypothesis. And it's, I mean, she's using hypothesis in the example. But the The intent is just property based testing, because you can, it's the same sort of strategy with every every other type of property based testing library, she just happens to be using hypothesis and Python. So that's nice. But the she starts off with an a unit test example of just doing she has like a string sort, or not a string sort. But let's start a list sorting thing. And if you were doing example, based testing, you just pick a few example, test example, test cases, or you would take the input, and you know, what the sorted output should look like? And you you know, run it through the function and make sure the output sort that is equal or equal to the expected one, how would you do this with property based testing. And before she goes in, she does give an example of how to write some sort of test like that in property based testing, but she stops and pauses and, and talks about kind of the different mindset, you can't test against an exact example. Because you don't know what examples coming in. So you have to think about properties. So like on a list sort thing, you don't have the exact answer, but you could check to make sure that the link, or should be the same. And that you can use sets on both the input and output to make sure that the contents of the both are identical. And then you can go through the answer and make sure that element wise, every element i is less than or equal to i plus one, you know, there's ways to test sort without, you know, without just knowing the answer, but it takes a mind shift a little bit. And I think actually, that's one of the benefits of property based testing is thinking in terms of that. Also, I also think it's nice that she talks about how this isn't a replacement, for example, based testing, it is a complement to it. And so you can mix them together. Then she goes on to introduce some of the aspects of hypothesis, like there's some cool strategies, like some lists and some integers, and being able to set the max examples to, so you can set how many, and that's where you can just set it to 10,000. And wham, you have 10,000 test cases right away. But, and just let hypothesis come up with the examples. The real meat of the article, which I really appreciate is just the how the hard part of property based testing isn't the sum of its syntax. And she does cover the syntax of how to get this done. But it's also just how to think about the properties how to the coming up with what properties to test for is the hard part. And so taking a little time to talk about that I think this is a great thing. I'm also glad she threw in that. One of the things you could you should check for with tests.

00:30:00 Property based testing is making sure exceptions get raised are expected exceptions. So if you throw garbage in or different cases that don't make sense, you should know what kind of exceptions are going to come out. And that this can be caught with your tests with hypothesis. And then also a great use for all of this is to implement whatever functionality you wanted in a very simplistic but possibly slow or memory, Huggy way or something. And then you can compare the elegant version and the slow version within the tests to make sure that they come up with the same answer. This is also great if you're doing a refactoring you can refactor part of your system, and make sure that the old and new way act the same. So it's just a good introduction to all of this, ya know, property based testing is it's You're right, it's such a mind shift. And it's, I don't know, I haven't fully embraced it yet. But I feel like there's probably some places where it would really be interesting and useful. And I probably should just look into it, you know, I don't know, I get stuck in my ways. And then I just I keep going that way. At the end, she talks about if you're not using Python, what options you have as well, which is kind of cool, right? So just like he hypothesis is cool in Python. But if you're in TypeScript, we got fast check, we're on dotnet. They don't have dashes, or A's, or T. So there's Fs check. And in Java, there's this and c++ and rust, and so on. So if it looks like you could use the same thinking and ideas across different parts of your stack, if you're having different technologies in there. This is another example of if it shows up in every language, it's probably something you should be paying attention to. That's a really that's a good rule of thumb. It's like yeah, if I see it all over the place, right? This is a general CS sort of thing. That's important. Yeah, you know what, what else I like about going through stuff like this is you come across things that you didn't know about, right? For example, you'd think that I would know about JSON, it seems pretty simple, like the JavaScript Object Notation. But apparently, there's like a JSON five as well, which allows things like comments and whatnot, and multi line strings and single quotes and elements that are not quoted for the keys and so on. And there's a whole cool library for JSON five support as if you want to have like a little bit more human friendly. json. I had no idea that was a thing. Yeah, neither did I. And I was just like, why can't I put a comma in JSON, this is driving me crazy. So what I do is I have like a field that says, comment or like double slash in quotes. And then I have the string that is the comment because you can't actually have comments, but you can have ignored keys and values. So that's how I have comments, my JSON. But anyway, she talks about using the JSON five library that's part of Python to support that or not, it's not built in, but it's a Python library you can use to do that. Pretty cool. Yeah. Nice. Yeah. Well, I guess that's it for all of our items, right? Yeah, it is. Got anything extra for us. Yeah, I totally did. But you you nabbed it and put it in your section. So go for it.

00:33:00 That tells you found the magical things there. Yeah, I want to get this one out of the way. First, as some sad news. Have you you've heard of Game of Life, right? Yes. Yeah. Conway's Game of Life. Yeah, Khan was Jake came of life. Well, Conway, john Conway, is, I'm going to link to an article that's a nice a nice article talking about the game of life and john Conway, but just an announcement that he is one of the victims of COVID-19 died from it recently. So that's sad. Yeah, it's definitely sad news Game of Life is a kind of a excellent thing to have in the computer science realm. Pretty neat. So that's add something that's happy is GitHub is now free for all teams and individuals. So that's pretty cool announcement. That's really awesome. Yeah. So previously, you had to pay to have collaborators on a private repo. I think maybe you could have some but not a ton, or private, I think like that. Yeah. It's like evolving it first, you had to pay for private repos, then you didn't, but then you had to for collaborators. And yeah, but that's awesome. So it's a much more free. And then also, for people who still pay GitHub, like me, it's half price. It's 40. It's, I don't know, whatever four divided by nine is. It's now 44% of what you're paying before. And people wonder like, why would you pay for GitHub organizations? If you have an organization? So like talk Python, and the related training, authors and content. There's like a GitHub organization for talk Python. Have people collaborate on that you still have to pay, but it was $9 a month per user. Now it's $4 a month per user. So that's also bonus. Yeah. Pretty cool. Yeah, that's happy. Yeah. So last thing I wanted to bring up is that the pike on us 2020 Online is now live. So there's a welcome video, and more. There's some talks linked, and there's more on the way Yeah, there's a nice welcome video from Emily Morehouse that she basically kicks off the virtual conference in this conference. I don't know if that's right word for it.

00:35:00 This

00:35:01 thing, this event is not like a lot of online virtual conferences like on Saturday, we're all going to meet and then the talks are going to be these three hours and whatnot. It's like, it's like a rolling release of information and videos that then you get to consume over the next couple of weeks. So yeah, you're linking to the basically the, the landing page for like stuff as it happens, right? Yeah. And I'm recommend, so also recommend checking out the so if you go to any of that, like the welcome video, and then go up and find the pike on us 2020, top page and look at the videos there, then you can see them all listed as well. But they're they're rolling out there's and I know that they're not all recorded, so some will come later. For instance, I'm still I don't know if I will, but I'm still playing and recording my talk. And posting it just trying to figure out when to do that. So yeah, yeah, cool. Anyway, I'm definitely looking forward to checking it out and see what comes along. There's also it's worth mentioning that there at that link, there's a place that has like the virtual Expo. And the expo hall is actually my favorite part of the conference is because you get to walk around and meet people and just, you know, see what's going on, and you see all the companies and what they're doing. But one of the things that happens there on Sunday, in normal times is there's the like hiring job fair thing. And all the job fair stuff is already up there. So if people are looking for a Python job, there's like, many, many links of this company's hiring for these four positions, click here, this company's hiring for this position. So if you're looking for a job, you want to get in there quick and grab the good ones and apply to them. Yeah, one of the things that's missing is, how am I going to last an entire year with no new t shirts? I know.

00:36:48 Well, you're gonna have to be up in your game there and this video version here. I know. I love all my own swag. Yeah, exactly. Like how do you even do that? How do you even find a good texture like that you buy? I knew that there but

00:37:04 well, you want to know something that wasn't funny as I almost forgot to put a joke in our show notes here. Oh, no. So I pulled up the terminal and I typed pi joke because I've PIP x installed pi joke. So it's, it's right there in the command line anytime we need a lab. This one is about QA software quality, folks. And it's a take on a traditional one. So you're all hit with this UI thing. How many q A's does it take to change a light bulb? I don't know. They noticed the room was dark. They don't fix problems. They find them.

00:37:36 Oh, dear. That's bad. Right? Yeah, that's definitely why QA and development should be one team.

00:37:42 Yeah. All right. Well, yeah, a good joke, nonetheless. A good joke. Thanks. Well, this was lovely today. So thanks for talking with me. Yeah, absolutely. Thanks. As always good to chat with you. See you later. Bye. Thank you for listening to Python bytes. Follow the show on twitter at Python bytes. That's Python bytes as in V yts. And get the full show notes at Python bytes at FM. If you have a news item you want featured just visit by thumb bytes.fm and send it our way. We're always on the lookout for sharing something cool. This is Brian Aachen and on behalf of myself and Michael Kennedy, thank you for listening and sharing this podcast with your friends and colleagues.

