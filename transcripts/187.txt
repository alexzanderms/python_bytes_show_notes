00:00:00 Hello, and welcome to Python bytes where we deliver Python news and headlines directly to your earbuds. This is Episode 187, recorded June 17 2020. I'm Michael Kennedy. And I am Brian knockin. And this episode is brought to you by us. There's a couple of things that we're offering that I think are going to be great for you. We'll talk more about that later. Right now, I want you to bring us back to our youth. Brian, did you ever do the Lego mindstorm thing? No, no. Lego was just bricks when I was a kid. Yeah, well, yeah. Okay. I love Legos. I'm actually, I've got like three kits halfway done right now. One of them I've been working on for a long time. I just finished those. Anyway, because there's a new one I want to buy. It's not out yet. But like announced mindstorm robot inventor. They've had different mindstorm kits in the past for robotics in they started in 2006. Or at least on the mindstorm series, there's NXT was in 2006, they did NXT 2.0, in 2009. And then the iE v3 was in 2013. And I was actually kind of disappointed with the v3 because it was weird. It was like post apocalyptic thing going on. It was like punk rock robots, or something I don't know. Anyway, so I think we've got an NXT somewhere in the house. But the new mindstorm robot inventor, they finally figured out that people are using these things to try to teach in STEM education and stuff. And so the new one, this is awesome drumroll. It supports scratch and Python. So that is super awesome. It has instructions for five different robots that do lots of different kind of cool things like a car like robot and an upright like robot and, and there's a bunch of sensors, the module that it has connects to six different input output ports for sensors and motors. There's even a six axis gyro and accelerometer, a five by five LED matrix five by fives, not much. But we could probably figure out, we can hack more color sensor and distance sensor, of course in Python. So one of the other neat things about it is the other one, I'm not sure about the the older ones, but they were programmable, of course with Windows or Mac. But this one also has, is going to have the ability to program it via an Android or iOS tablet, or smartphone and even some firewalls. So like the Amazon Kindles, some of them might be able to be used, which is pretty awesome. Because even though this robot inventor is pretty expensive, if his school's helping to support it, or something, and a kid has a, you know, a $50 tablet at home, hopefully that'll work. So let's see, yeah, this is really cool. And I think being able to program with a real programming language instead of a blocky type of programming language. Yeah, goes a long ways. I think people underestimate how much kids could do with some simple text versus, you know, like, well, it's got to be dragon copy. So don't ever make syntax errors. And, you know, if you look at things like code combat.com, kids go through these dungeons, and they solve like, challenges to open the door, make it across the bridge or whatever with code. But it's all typing Python. But the editor is so insanely aggressive, in a good way, aggressive with autocomplete, like, if you type A it'll try to autocomplete hero dot attack and suggest arguments. I mean, it's like ridiculous. And in those sorts of scenarios, I feel like, you know, don't pull the punches, like give the kids a real experience. They'll adapt pretty quickly. I think people underestimate with the right tool and what kids can do with a text language like Python. Yeah. And I so I really hope I think so too. At some it's exciting to have it. I know you can't there were ways to put control the v3 with Python, but it was extra hacky ways and not obvious for people. And so hopefully having this supported, and I really hope that we get more of these sorts of robot inventor things coming out from Lego. Not every seven years. Can we update maybe every couple years? That'd be awesome. Yeah, for sure. technology changes fast. Yeah. and other related note, I didn't do this as a full story. But I wanted to note, I also saw a project called microscopy, or microscope pie. Maybe it's an IBM open source project to build your own modular microscope using Raspberry Pi's and Lego bricks, and a little bit of 3d printing. And you can control it or like a motorized microscope, which is pretty awesome. So that's neat, too. Yeah, that's really cool. All right. Well, I have a theme that will become clearer as I go through my items this week, at first somehow, somehow just landed, lined up with all the items I picked the same general area. So I want to start off by talking about this article from Kevin Markham from data school.io. And he put together he's been putting together lots of cool steps and guides to help people get into stuff, his areas, mostly data science, but obviously in the Python side, so he created this thing called a step by step guide to contributing to GitHub. Yeah.

00:05:00 So if you're new, and you haven't actually yet contributed to an open source project, it's like, here are the 17 steps in order. And some of them are obvious, like, you have to have a GitHub account, you have to fork the project, others are not as obvious. Like I always, whenever I fork something, and I'm like, Oh, you know, I really want to get the changes from the thing I forked merged, you know, sort of synchronize my fork with the remote fork, I always like what is that command again, about like remote origins and or upstream, I got to set you know, like, so having that stuff all laid out in a nice little do this, then this, then this guide is helpful, even just for a couple of the steps if you've done it before. So I'll just run you through the steps really quick. People can go and see the pictures and the graphics and explanation. But so I want to contribute to something I think he contributed something back to psychic learn, but it could be any project, right? So you start by figuring out what project you want to contribute to you fork it to your GitHub account. And then you check it out, you clone it locally, and load it up, make some changes. And then you make sure you have your origin remote pointed back to the thing on GitHub. And then the part I was just talking about, you can add an upstream remote, which allows you to say give me the changes from the source repository to my forked version. You always want to get those like maybe forked it a while ago, but now you want to make a change. So you want to grab the changes from the upstream original repository, bring it over, create a new branch, a feature branch for your changes, because you're going to use that for a PR, make changes, commit your changes, push it to your fork, create a PR by clicking the green, create PR button, review the PR have conversations around it, maybe make some more commits to your pull request. So it talks about like, if you submit a PR, and they're like, that's great, but you need unit tests, how could you forget the unit test, please add those as well how to do that. All right, it's common, sorry, I'm sure, discuss it. And then once it's merged, or I guess closed, even you could delete the branch, but especially if it's merged, you don't need it anymore. So delete your branch synchronize again, your fork with the original project repository through the upstream link. Because once they've accepted your changes, your main branch will be out of sync with their so you want to do that. And then also has a nice little tips for contributing code section as well with just some advice on how it goes to the pictures. And like here, type this for the stub think this is pretty handy for a lot of folks. Yeah, people just need to do it. It seems overwhelming when you start because it seems like oh my gosh, this seems like so over the top. And actually. So at work when we switched from a different version control system to to get we started out with this sort of a model. This is not an uncommon model, even within not just open source, but other projects. Originally, I thought this is a lot of overkill. We don't really need forks and branches. But there's a lot of benefits to doing both. And you just kind of get used to it. And it's not it ends up being not that big of a deal. Yeah, one of the advantages for what you're talking about, like inside your company, obviously, it's important for open source, probably mostly because you don't have commit, right? So you make changes to your thing. And you say except my changes, right? But inside a company everyone has commit, right for the most part to their project they're working on. But it bundles it up in documents like these are the changes to add this feature. These are the conversations around it. And here's how it got accepted. Right. It's like a nice way to go beyond just like here's a commit or series of commits I did this week. I think some of them have to do with this Scrum thing I said I would do. Yeah, the one of the main reasons we kept the fork model in places so that we can, if somebody accidentally pushes up a large executable, or something that they shouldn't have committed in the first place. It's easier to kill a fork off than a branch of a project. I see. It's like a layer of insulation of mistakes. Yep, definitely echo. Well, before we get on to a new language, Python inspired language, I just wanted to talk about a couple things you can do to support the show. Obviously, Brian and I are both doing things outside the podcast that we think contribute back to the community that if you want to support what we're doing, it would be great if you could check them out and consider them as your learning Python thing. So I have courses over at talk Python training. We have I think, 170 hours of Python courses and probably a couple hundred hours of exercises for people to do over there. So if you're looking for courses or to learn stuff with Python in general, check out Python training. And Brian, you have some kind of book, I think, yeah. So I think that anybody that wants to learn how to test better should pick up a copy of Python testing with PI test. So book that I wrote about pi test. It's not just it kind of walks through all the different sorts of things you can do in the with PI tests, but also around testing a package project. And I think a lot of these carry over even like switching databases and stuff. These things carry over for all all sorts of types of projects.

00:10:00 And I've gotten a lot of great feedback. And I think it's a good thing for people to read. Yeah, awesome. It's a great book. And both of those things are linked at the top of the show notes. So you all can just check it out your podcast players. So I'm always fascinated with embedded Python and things like micro Python and circuit Python. And you got something along these lines, right? Yes, I ran across this a language called snick snick, I think as an ek, so it's at at snec lang.org. And it's a Python inspired language for embedded devices. But my first reaction is probably going to be yours is also don't we already have that done? We already have micro Python. And we already have to I'm confused why we have to Yes. And circuit Python? Well, actually, yeah, we've got lots micro Python circuit, Python are the ones that we think about a lot. Circuit Python, of course, is focused around Adafruit, but also runs on lots of different other boards as well. But what about really small things, even those, they run on these small chips, but there's smaller chips that you might want also. So if you only have a few kilobytes of flash, and RAM, and you still want to run something, can you run Python, and that's where snack comes in. So it's, I mean, it really runs on small processors, even one of the things that supports is the Lego mp3. So if you don't want to wait for the, the new robot inventor, you can run snick on your current mp3, so that's neat. But the smallness, its goals, it's it's not Python. So most sneck Python programs will run in Python, but not the other way around, you can't run most Python in it. So it's got a limited language. But part of that is an educational person purpose. So a smaller language footprint, as pythons adding more and more new features, it may be overwhelming for some people, when they're just starting out. So having a smaller language is kind of a neat thing. But all of that learning can go towards your, if you're learning snec, you will can transfer that to Python projects later. Right? It's easy to level up to Python because it's it's like going from C to c++. There's stuff to learn. But it'll depend. If there's even like a dedicated a new board called the SEC board that you can that is available, it was through a crowdfunding process. But it runs both circuit Python and snick. So yeah, one more thing to be able to run little small chips with Python, like language. So this is nice. Yeah, it's really cool. And the very, very small devices, I think it's gonna mean, you know, Python can appear in more places, right? On incredibly small IoT things and whatnot. Like even if you have larger though, I like the idea of people saying, pythons just kind of a great syntax. If we stripped some of the things out, the full Python has, it's still usable language with a lot of it stripped out. So it's a good thing. Well, that whole idea that we can go on and on about that, but the whole idea is pretty interesting. Because as we see things like Python, moving to webassembly, and running on the front end, and talking about maybe having a Python on mobile, as well as the traditional c Python that we know and Python on chips, like having this concept of a smaller, focused subset of Python that is universal. That's pretty interesting. Anyway, that sounds like that's a little bit of the philosophy here. Yeah. That's interesting, whether things we see like this coming up in the future. That's right. So we spoke about Git before forks, and using forks as installation. But have you ever made a mistake with Git? Are you like every day? Yeah, yeah. Like, why did that thing get checked in? I told it to ignore it. And now it's in there, right. Stuff like that. So Andrew Simon sent over a link and recommended a zine. A little small book between Xen, yeah, Xen, by Julia Evans. She has a bunch in the programming and DevOps space. And she created one called oshit. Get, and it's like, I'm learning get, and oh, my gosh, something's gone wrong. What have I done? It's cool. Rice is great. Yeah, so I want to be clear, this is a paid thing. It cost $10. We have no affiliation with it. But I just like the idea of it. So I thought I would feature it. So basically, it's this really short little Xen book thing that explains Git fundamentals, like what's a Sha, and why don't you call it an sh, a, I don't know, stuff like that, right? And then it goes into a bunch of how do I fix common mistakes, like, I committed to the wrong branch and other fundamental problems or have a merge conflict? Or I committed the wrong file? Or I ignored a file, you know, and going back in time, right, like, we wrote the wrong code. The server's down. Everyone is yelling at me. I know it worked yesterday. How do I get the server or something to go back and say

00:15:00 Just go back to the way it was, and we'll deal with it in a minute when things calm down. So like all those kinds of stuff, so I thought this is kind of a cool line and people who are, like getting started with git, but they're, you know, they run into these things, and it's a big deal. It's like, Oh, no, it's a merge conflict. Now what I'm stuck, right, or, like I said, committed the wrong file to the wrong branch or, or whatnot. I think this would be pretty helpful for folks. I love that the titles of the different sections are the thing that went wrong. Like, yeah, I committed to the wrong branch. Exactly. Yeah, I tried to run a diff and nothing happened. I have a merge conflict. I want to split my commit into two commits. I want to undo something five commits ago and so on.

00:15:40 I gotta make sure that this isn't a violation of my human resources, things to buy this for all of my employees, because I think everybody needs this. These things are great. Yeah, I just put a little bit of black electrical tape on top of that metal word, and then you can hand it out. It's, it's a PDF, maybe, you know, get by five licenses and printed it five times.

00:16:02 Yeah, no, it's pretty good. He's like, I did something terribly wrong. does get have a time machine. Yeah. So it sounds interesting. Thanks, Andrew for recommending it. And Julia, cool work on the creative way to address Git issues. Yeah, definitely. So what's the story with versioning? You guys got a beef with it?

00:16:22 Well, you know, I've kind of always had a beef with it, but I didn't really think about it. So Brett cannon actually asked a question on was interesting. He wrote an article that I read recently called, why I don't like semver anymore. semver being semantic. versioning. Yeah. 2.1 point zero style. Yeah. And like, like, as opposed to calendar versioning. Or, or what we were, we talked about this earlier of zero, or zero, or I was like, I even more negative version of semi December. Yeah. So the interesting question is, it's not straightforward as to what so that there's often it's like the first digit, like, if we say x dot y de z, x is some major thing. So like some crazy new feature, it's either a crazy new feature or it's a incompatibilities with the old one. Like we're gonna change the interface. Right when Django went from one dot something to two Dotto. They dropped support for Python two, for example, and that was the indicated part later. Yeah, exactly. So what constitutes an interface break? And that's where a lot of people think about well, what about, if you add a deprecation warning to something that you're planning on taking out in the next version? Is that adding an extra warning is that a major thing or a bug fix or a minor thing, and that's part of the discussion of most of us, I think, would think that the maybe that's a either that's just a bug fix, or a minor thing, that's not a major thing, right. And to me, I made, it makes like, no different. There's no new functionality, nothing stopped working. That seems like a super minor, like it should change the very last number, because he doesn't even add or change the functionality, but it is adding a warning. So if I have, if I'm running Python with, with the flag that turns all warnings into errors, or if I'm running my tests such that and that's like normal with running tests, as you turn all your warnings into failures, so that you find them. Now you've, you really did change the interface, because I to get rid of that warning, I have to go. And either I need to change to not need to not look at that warning, or I need to change my use of that thing. So it is kind of an interface break. Yeah, for sure. So that's part of the visit discussion is that it's not really straightforward to say that, what is a major minor micro change, what that really is, it's a gray area, there's discussion. And then also really what the observation that the three digits kind of makes sense if you are maintaining three or more branches. So if you're maintaining a current branch plus the features you're working on the next one, that's a another branch plus you're doing bug fixes to the current production one. So you've got like, development going on in one branch and fixes in the other one, and then you know, minor things going on, you might have like even more branches that you're maintaining at once, for a large project with lots of people on it. That totally makes sense. For small projects and side projects and things where you're really you're not maintaining a bunch of stuff here. It's one branch and you fix bugs. You're not planning on adding new features. Or if you are, you know, I don't know it's so infrequent, that doesn't matter. Maybe two digits is enough, just x&y, or maybe just one digit, because there's a whole one of the reasons why a whole bunch of people are zero for is they're trying to not be backwards incompatible in there. And they're not gonna add any major new features. It's a simple tool or something. The other thing Brett brings up is basically

00:20:00 You shouldn't depend on this stuff. Because it's nebulous and wishy washy, you shouldn't depend on the numbering semantic versioning, to see whether or not what versions of a new of a dependent project you're using, you should rely on continuous integration and testing. So do a minimum version for the project you're using. But don't do a max and use your testing to find out if there's any problems, always do the latest one in the diversion doesn't really matter, you're going to keep ahead. And if your ci breaks, then you might have to pin your event pendency to earlier one, but also, you should always append your dependencies to specific versions and just use your ci and testing system to see if you can move forward. Yeah, absolutely. And if you use something like depend a bot or pi up or something like that, it'll automatically look at your repository, increment those versions, run some ci if you have it set up, and you'll know if it's acceptable or not. So you can get this estimate to tell you, hey, you should update this pin version. And click here to allow it. Yeah, I love systems like that. It totally makes it so you can review it and go, Yeah, that's good. Man. Let those often those just show up as a merge request that you just accept. Right? That's right. Yeah. Very nice. So good discussion about thinking about whether semantic versioning really is appropriate for your project. Yeah. So do you remember what the recommendation was I scanned it, I didn't see like a super clear, like, do this instead, know the the end there's a kind of a summary that I kind of, like cribbed and put in our show notes. Essentially, it's the try to pin the lowest version, or pin your versions, of course, but have a low end but don't have an upper end and just test as for using dependencies for your own version. It really was, it should match your branching strategy, really. So if you're really not supporting three branches, three digit. semantic versioning doesn't make sense. You can do two digit or one digit version. Yeah. Pretty cool. All right, carrying on with my theme. You want to talk about Git? Oh, we haven't covered yet for a while. So that'd be good. Yeah, for sure. So there's famous, like, you know, rock star famous. Julia Roberts movie star famous. There's like maybe a step down, but still pretty cool. There's geek famous, right? Like on the regular Street, nobody would recognize you. But at a conference, you're kind of cool. I think probably get a van Rossum definitely fits geek famous, right? Yeah. And then apparently there's get famous Oh, is that is that when you have like your pixelated face as your get history? It's really complicated. But if you time it just right, you can. Now so there's this project, Bjorn Olson sent this over. So hey, you should check this out. It's quick and fun and kind of useful. If you want to go to a project and answer the question, who kind of created this or who mostly worked on this, and I have this all the time, when I go look at these projects that we're researching and covering? Maybe I want to talk to the person about a question or something. I'm like, Well, if I can go to the contribution thing, and GitHub, maybe it'll show me but that's more of an overtime and who's recently worked on it and stuff. So it's not super good. And if you're not on GitHub, then obviously it doesn't help. So there's a thing called get fame, which is a Python library. And the idea is you pip install Git fame. And then associated with git, you get a new command, you say get space fame, and it will go through and it'll like look at all the commits on all the people and how many lines of code or changes changed and files and whatnot by everyone. And then they'll give you a ranking of these are all the people who've contributed. And here's how many files, they've changed how many lines of code they've changed, and so on. It's pretty cool. And it sorts them by most popular most largest contribution downwards. That's cool. Yeah. And it's super easy. It's super easy, like pip install, get fame, get config and set an alias to fame to run the Python command, and they just get fame and it just goes wrong. And it uses the TQ. dm, I think that might be the right order. Progress Bar, you know, to show you its progress. I ran it on a somewhat large, somewhat large project, small to medium project, I guess in terms of regular software, and it found 596 commits, and it took seven seconds to do that. Processed 76 files a second. That's pretty good. Yeah, I totally like the idea, especially random, very useful for us when we want to talk to one of the people that's really involved with it. Yeah, exactly. Yeah. And like you said, often, some of the most recent ones are valued, of course, but not major changes to the library or something. Right, exactly. So it's a little bit hard to know. So this kind of gives you the historical view of who's really contributed to this project, and how many lines of code have they changed and so on, which is not always a great measure. But you know, it's still interesting. Yeah, I totally missed the my guess I my guess was it was an alias to rerate. Get blame? Because blames so I don't know why they named it that. I know, credit. Maybe get credit.

00:25:00 It should be called credit. There's positive and negative credit, right? Yeah. Yeah. So it basically runs get blamed over and over and over on each file and then analyzes the file the result of get blame and then build out this this history based on that. That's pretty cool. Yeah. Yeah, pretty cool, super easy to use if you're into it. And that wraps up all of our items, Brian, got an extra you want to share with folks, I want to thank everybody that's supporting the show through Patreon, because I went in and took a peek today. And we have 26 supporters. And if you want to, we have links in the show notes and also links on our site, if you want to help out the show through Patreon. But you can also go to patreon.com slash Python bytes. And many people donate $1 a month. And that is awesome. Thank you. And a few go above and beyond and contribute a little bit more. So I wanted to do a special shout out to those that are contributing more than a buck. So thank you, Brent kinser, Brian Cochran, Burt rainmakers, Richard stone house and Jeff keefer, all donating more than $1. So thank you very much. Awesome. Yeah, thank you guys, that really does help support cover things like editing and transcripts and all that kind of stuff. Now I have a quick follow up forum. Last time, we spoke about Dunder pi packages, and things like that to where you could set up I think it was pi flow we were speaking of where if you interact with Python through pi flow, basically, it will use this Node JS like behavior that is really still coming hopefully, in pepp 582. So after that, someone was Paul Everett, who sent over a message and said, Hey, did you know kachelle das, who is one of the folks core developers working on this whole idea, has a little Python example, just a single Python file that you can use to basically implement this and it says this would probably be really great for like trainers and students and teachers and stuff like that, to kind of sidestep the whole virtual environment story. Okay, that's cool. We're gonna try this. Yeah. So quick little link to a working version. That's not just a whole overhaul like pie flow, but a simpler thing. All right. Now this last one, Brian, this joke here and wrap it up with a joke as always, you got to open it up because an animated GIF. Okay. First, let me ask you, what shell do you use? On your bash? bash? Okay, so I'm on my z shell, kind of guy. Because I love like the history and it keeps us really good track of all the stuff I've done. And sometimes I'll type like one or two letters, I'll try to go back and like no, no, that's not, instead of just typing out the stupid thing. I'll just go back and back. And so here's like, this clear, like super bearded guy, who's some kind of sysadmin Linux, exaggerated person, I guess you would say, and it's an animated GIF, right? The guy's just clicking his finger clicking his finger up, up, up, up, up, up, up, shows him doing that. Doing it some more. Now he's got a drink. He's clicking on a drink at his drink, clicking up and then finally, he's so excited. Finally, what does he say? I knew I had that. So that LS somewhere in my history. And eventually, he just says, Yeah, LS right, he's up arrowed until, like forever to just so didn't have to type ls. Man, have you ever been there? No, cuz I look kind of keybinding do you use vi? keybindings? Okay, do you have a backward search or something like that? Yeah, you can just search through history to find the find himself. But then you have to press more than just the up arrow.

00:28:26 It's got a cool,

00:28:27 cool little animation, cartoon face. I just linked over to comic strip.com. Where, where the title is definitely not lazy.

00:28:37 Yeah, definitely. You know, I was thinking about I don't even remember the key sequence to do the searching. I would have to do it. I just it's one of those built in muscle memory things now. So that's right. Yeah. I was trying to remember today and I couldn't remember it. I'm like, whatever up there. Up there up there. Yeah.

00:28:54 Pretty funny. All right. Well, thanks for bringing all these items and sharing with everyone crazy champions. Always. Thank you. Thank you for listening to Python bytes. Follow the show on Twitter via at Python bytes events, Python bytes as mb yts. And get the full show notes at python bytes.fm. If you have a news item you want featured just visit Python by setup him and send it our way. We're always on the lookout for sharing something cool. On behalf of myself and Brian Aachen, this is Michael Kennedy. Thank you for listening and sharing this podcast with your friends and colleagues.

