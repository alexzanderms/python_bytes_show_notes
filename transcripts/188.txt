00:00:00 Hello, and welcome to Python bytes where we deliver Python news and headlines directly to your earbuds. This is Episode 188. Recorded June 24 2020. I'm Brian knockin. And I'm Michael Kennedy. And this episode is brought to you by us talk Python training and Ryan's fabulous pi test book, right? Can you believe 188 contiguous episodes? I cannot. The number keeps going up. I guess that's what numbers do. But I guess so. It's awesome. glad we're still doing it. It's fun. Which got for us to start with. Well, you may have heard me talk about async. And actually, I didn't cover it on purpose. There's sort of a controversial async article going around. I don't really want to talk about it at the moment, unless I have to. But I do want to talk about my favorite async thing, which is unsync un s wincc. unsafe. Okay. I feel like the Python core developers should look at this and say, You know what, we massively over complicated. All the asynchronous parallel capabilities of Python, let's create a unifying API that like, is the one simple way that you can do things. And if you need to dig into the details of the other ones, that would be great. They haven't done that yet. I mean, async await the keywords are great. But if you want to say work with like a thread, and some async IO thing, the way you do it is like totally destroyed and unrelated. So this unsink Library is like a unification library on top of threading, multi processing and async and await. So I've talked about that a bunch of times, and it's sweet. I'd love to see Python just adopt something very similar to that API internally. Anyway, there's a cool article called Making a trading bot a synchronous using pythons. unsink library by Matt, Matt Gostin. Oh, nice. Yeah, it's cool. It just walks you through a somewhat realistic example of creating something that does rating. And in order to do it has to go and you know, it talks to a different web services and some databases, and whatnot. Now, all these are simulated with a function call to a time sleep call. Right? One of the things you'll see a lot of people when they do like these performance analyses and stuff is they'll have some async code, and it's hitting up against some other thing. And that other thing has a performance limit that is like near

00:02:25 near what I can handle anyway, and so you can't get a big boost out of it. So this kind of like puts that to the side. So it's like, we're not going to actually talk to another thing, because maybe that thing is slower than we can handle or who knows, we're just gonna go and simulate slowness by sleeping, right. So it actually walks you through some different ways of doing things that has a synchronous version, and the async and await version using unsink. I don't know if there's intermediate, I can't remember if there's intermediate versions in this tutorial about having just a pure threaded version, right. But it's mostly about taking the synchronous version and making it unsink. So it's, it's nice, because it's a somewhat realistic example. It's not as much of a realistic example as some of the scenarios or it's not as ideal of an example of some of the other scenarios. Like for example, if I need a web scrape 100 different websites, right, you could do that 100 times faster by just like kicking them all off and getting it back and not really waiting, because all the work is happening, distributed elsewhere. But it's still a pretty realistic example, doing some different things. It would be fun to hear it talk about scalability more like how much it's like, we've got a couple, I think it's doing three things. It's like, Look, we could do these three things quicker. But you know, like, what is the limit? Like? How far can you push it? Because I think you could push it quite far actually, with what they're doing. It's just hard to know when if sleeps are representative, as well. Yeah, it is hard to know if like asleep is representative basically, if it's like in truly external system that has infinite scale. Alright, some cloud service, that asleep is probably pretty representative, like whatever you're doing is not going to affect it. But if it's a like a database, right, if I'm doing 10 requests against the database, versus one, and maybe the database can't handle it, it slows down to what like two or three queries at a time would be like, there's things like that right, where it hits a limit, but if the thing you're talking to totally scales, and sometimes it does sometimes doesn't. One thing that I think is missing from this is it doesn't actually use async methods, it just has regular methods. So this is really an interesting thing, right? So it's like, okay, we're gonna put unsink on it. There's a regular function that we put that unsink decorator, which turns them into these things that are available in parallel and so on. And what you really probably want to do is actually leverage async in a way create, you know, def async methods, use await async IO sleep and all that kind of stuff. So I didn't actually fully transition them to leveraging async IO. But what I think's interesting about that is, it still got much better with unsync. And what's cool is like it said, Okay, well these are not async method.

00:05:00 So we're gonna have to use threads, but let's just fire them off with threads anyway. And because the time that sleep releases the Gil, just like a network call would, it still kind of works. So it's kind of neat that like, it wasn't fully converted over, but unsync still made it better in the same way that you would expect. Interesting. Yeah, yeah. Yeah. So anyway, a cool example of someone talking about unsink was not me.

00:05:23 separate out, reviewed it. There's a lot of cool stuff in there kind of like a like a fruit salad, would you say? is a lot of stuff to take? And it's, it's sweet, and people generally enjoy it. Oh, man, I shouldn't have picked this story right before lunch also, cuz I'm kind of hungry. I know. I know. It's good. So tell us about this. I was gonna put this as an extra thing. But I put it as one of my topics because it's actually pretty darn cool. So this on Twitter, Lacey hentschel just asked the question of like, there's this Scrum estimation tool with fruit? Does anybody remember it? and Kathleen Jones replied and said, Is this it, essentially? And it was. And so we're linking to this article. It's called the fruit salad Scrum estimation scale. And, you know, task planning and Scrum estimation is a, you know, it's a kind of an art form and a science together, you takes a while to get things right to maybe just really, really super quickly tell people, what is this Scrum estimation about? Okay, maybe scientists, and they're like, we don't do that in our biology. That's true. Lots of teams have picked up Scrum or sort of a variant of Scrum, which is a way to plan what tasks, what things that people are going to work on. And the things that people work on, we kind of want to, you know, have a like a size for them. And instead of doing like, Oh, it's a one day task, or a two day task or five day task, or some people just use small, medium, large t shirt sizes are popular. And then also, for some reason, just points are very popular. And the point system is often the Fibonacci sequence, which, but it's not really just kind of Fibonacci. So I can't remember the numbers right off the top of my head, I think they're like, one two through a, we usually skip three. So one, two, either four, or five, and like eight sometimes and then like 13, and 40. So it doesn't really quite fit normal Fibonacci, but I think that's where people took it from. So we've been using them at work as well lately. But the numbers, it's a kind of like t shirt sizes, but I don't know that none of these things really fit. But the fruit salad estimation scale actually kind of fits. So they've mapped 1235, and eight to grape, apple, cherry, pineapple and watermelon. And I like these ideas, because they're kind of like how easy they are to cut up something, and how easy they are to eat them. So like a grape is trivial. You know, you just pop it in your mouth, it's no big deal. You don't even have to cut it up for fruit salad. Although I usually do an apple, everybody knows how to cut up an apple, but it's a little more food. So it takes a little bit more in it might take some more time. A cherry. It's also easy, but there's some unknowns in it because of the pit. And pineapple. Yeah, you can't just eat that you've got to actually put some work into it. Some people don't know how to cut it up, and it's a little messy, you're gonna have to get your hands dirty for that one, and a watermelon, all bets are off. Nobody knows. You don't know what you're getting into until you cut open the watermelon. So I like that as the large size. There's more description on this article. And then they throw in some nice ones. Tomato and avocado, tomato and avocado do not map to points. But tomato is unknown. I mean, are you a fruit? Or are you not, and you need more information before you can estimate it. And it really doesn't belong in the fruit salad until you change it into something else. And then one of my favorites is avocado. That's something that you just get, you can't really scope it very well. And it's probably urgent because it'll go bad quickly. These are great. I like this, this concept of thinking about them here. Yeah, so I think that somebody needs to put these fruits in an official product. That would be cool. That would be cool. You know, another one that comes to mind here is a mango. Yeah, you know, those are tricky because I like to cut them like in the orientation of the husk or whatever the thing in the middle is a giant seed. But you got to hack into it a little bit before you can even figure out what that is. So you kind of start out unknown and it's slippery. You may hurt yourself on it, but it's it's really an it's a high value. Once you get it out of there. I don't know mega and sometimes you can't tell until you get into the mango if it's even good or not. Because Exactly, yeah, I think mangoes in this category somewhere but this is a really cool idea thinking about it, because it's super hard to be very accurate when you're estimating stuff. And what I like about this is it just brings that together

00:10:00 pretty clear way, right? They're not like, well, how many hours? Is it gonna take? It's gonna take, it's gonna three or four hours like, No, no, we're not talking like, I can't possibly give you that answer. It's like, Alright, fine. It's four hours plus or minus 16 hours. Yeah. And then that kind of stuff. If you do points, people always have like, some conversion to hours anyway. And it's annoying. I think it'd be cool to somebody said, You know, I got a manager, somebody saying, hey, hey, how many how much time we have left? Be like, well, we have three grapes and a cherry left to do.

00:10:31 Yeah, just don't talk about it by lunchtime. Anyway, now I am hungry now. So instead of doing a another topic, we should just talk about how awesome we are, how awesome your training courses are? Oh, thank you. Well, so this episode is brought to you by us. And we both are doing stuff, we would love for you to check out over talk Python training, we have a bunch of courses, I think we're up. Probably by the time that this goes out, we're up to almost 200 hours of courses and a couple hundred hours of exercises. So lots of stuff to be learned over there. But I want to call out if you have a company, and your company has a training budget or training plan, you know, reach out to us we have special deals and offers and pilot programs to help get our courses started at your company. So shoot me a message over the Michael at talk python.fm or just check us out over there. And if the writing code, they should test it right definitely should test it and tell everybody, the Python testing with PI test is the best way to get started with testing with Python. And even though it's like 180 pages, the first two or three chapters will get you up and running like in a day less than a day. So you can get started right away. And then you just get faster and more more awesome as you go along. Indeed, I take advantage of all those features in PI tests that people might not know about it. So you know, one thing, I think people come into programming often feel like, if they're going to be programmers, they have to be good at math, like, Oh, I was really good at calculus. So I'd be a good programmer, or I never actually got algebra very well. So I probably be a bad programmer. And I think that that connection is often very much not true. Like I don't do math, other than like basic arithmetic in my programming these days. But some people do. Right? Some people come as engineers, or they come as scientists, and they actually do math frequently. And they want to do it with Python. So Vernon thermit bomber at sorry, sent over this cool project called math to code. Have you seen this? Yeah, I was checking this out the other day. It's pretty fun. Yeah. So imagine you wanted to learn something by doing flashcards, right, I'm going to show myself, I'm gonna flip through them and like, see, like a simple thing. And then what the answer to that is, and this is kind of like that, like it starts out says, what I want you to do is take the square root of something using NumPy. And it's all based on NumPy, or just pure Python like, Ray something to the power. It's just x star star y, for example. But it just really quickly and simply takes you through that. So you type out the answer. Hit enter. It's all hockey driven, which is great for a web app. And it just kind of guides you through, like practice experience of here's a math problem. Solve it. NumPy. Yeah. And it's so beautiful. It is pretty right. Yeah, cool. Yeah, I honestly haven't made it to the end. So I don't know how many answers or questions or whatever, there are flashcards as I'm calling them. But it is open source on GitHub, which is pretty cool. So you can go in there. And, you know, check out the source code and play with it. And yeah, it looks like 13 questions, but it's on GitHub. And the questions are just markdown, so you could go add as many as you would like. Actually, that's pretty cool. Yeah. But what also is interesting, just at a more higher metal level, maybe you don't care about finding, you know, the square root of something in Python is the building blocks. So if you look at how this thing is built, and like I said, open source on GitHub, you can check it out. It's built running Python on the client side. What really yeah, so it's built using sculpt, which is a JavaScript implementation of Python. And then it has sculpt NumPy for the subset of NumPy, running on a client side that it wants you to experiment with, right? Like NumPy dot square root, for example, or NPS dot square. It has k Tex for rendering la tech on the browser side. It has next j s for front end tailwind CSS, which my friend Mark just told me about, which is a really interesting alternative way to like CSS front end frameworks, like bootstrap, but different remark from markdown on the client side, gray matter, all sorts of stuff. So there's a lot of cool building blocks here. Regardless of whether or not you're actually into the questions. Yeah, this is awesome. That might be more interesting, actually, than the thing right, because I honestly don't care about learning the math features generally. It's nice, but it's just not some. I do.

00:15:00 Yeah, this sort of model of like have a I mean, if you look at it, I don't know if he already said this, but if you look at it, you get like, the some explanation and a question on the left a place to type in and submit your answer on the right. And then there's even a place where you can like, set up a hint and and show show the answer hidden or somebody. And having all this just it's, it looks very nice and having like this as an example to, for somebody else I could totally see, like a teacher running with this to help help their students learn really pretty much anything. Yeah, it doesn't have to be exactly Python long as you can verify it with Python. Yeah, go. Yeah. Tell us about the PAP. There's always a pep to be discussed. I've learned about a couple of new peps and the three nine timeframe right, so this is the 310 timeframe. So we're everybody's should be using three eight now. And you should be testing three, nine, if you especially if you have a package that depends on that people depend on so that when three nine is then officially, it'll all work. But people are already working on 310, of course. And one of the peps for 310 is pepp 622. And it's not official yet. It's in draft status. But there's some cool people working on it, including Guido, and I think it's super cool. Did you have you taken a look at this? I have taken a look at it. It starts out to me feeling like a switch statement? Yeah, it's there's a lot more going on here. It's called structural pattern matching. And right off the bat, they note that there have been previous peps before that have tried to put switch case statements in Python. And they've been rejected, I don't know why they were rejected, it's kind of something I didn't pay attention to. But this Yes, instead of a switch case, it's a match case statement and a multiple statements. But the neat thing is, there's all these different. So when we think of like a switch case statement, and like from see matches by equality or value, you switch on some variable name, or some expression. And if the answer matches one of the case statements, then you run that part of the code. So that would be in the pepp, 622. world, that sort of a use model would be like the literal pattern or the constant value pattern, basically, with equality and stuff. But it does more than that, you've got named patterns, so that if you just have a whatever, if these will always, if nothing else, succeeds, pre or prior to it, you can just have a variable name, and it just assigns, whatever you're passing in to that name, and you can use it there. My first thought was, what's the big deal, you already have the variable name or the value, but this new value in the name pattern is only available in that it's isn't assigned, otherwise, if that didn't get hit. So that's kind of some useful neat things, constant patterns kind of the same, but then it gets interesting. So I think it'd be worth it just for that. But you've got sequence patterns where you can do it works like unpacking assignment stuff, you've got mapping patterns, that are like similar to sequences, but for like dictionaries, and class patterns where it can, you can have a like a custom class or a class that it might be and you have a match object, it's similar to equality, but you could have, it could be different than equality. And then you can combine them with ORS. So you can match cases, if multiple things are true, like a Boolean expression in there. I don't think it's a full Boolean expression, but at least ORS work for pipes, guards, so you can say if this pattern matches, and then have an extra if expression, so you can clarify it even more. And then even sub patterns. And at that point, I kind of got lost. So just there's a lot here. I don't think it's going to clutter Python up actually, I've seen some examples of how this would dramatically simplify some Python. So yeah, it's interesting. What's surprising to me is how many types of things it's trying to do at once, right? Like, it's not just like, oh, let's have a switch statement with like a slight variation. Like it's, there's a ton of stuff going on, including things like if you switch on an enumeration, you can just say dot attribute, and it'll try to like pull that attribute out of that type and check it. And yeah, it's pretty interesting. One thing that's missing here that I would love to see is range matching. Right? So I could say it's in the range of zero to 10. match this case, if it's a range of 11 to 100. Do this other thing, actually. So I have my package, the switch Lang package, which adds switch to Python, and it has those types of things. So I actually sent that over to one of the people working on this map, it said, Hey, this is really cool. You know, check out some of the ideas from this one, like, especially the the range matching, and see if it makes sense here because it's so common that you would want to say

00:20:00 Like, this range is this case, that range is that case, and so on. And we even talked about a package A while ago, I can't remember exactly what it was called, which is unfortunate that we've covered too many things. But it was basically you could give a, like a number or a value, and then this range, and you could ask is this thing in that range and some real simple way? So it'd be cool. If like, that was all combined, you might be able to do with the IP guard, though. So you could say like, you know, match x if x is within, you know, in this range? Yep. Yep. It's true. Yeah, we'll see. I mean, at that point, like, if you're writing a lot of complicated statements, you might as well just write if statements.

00:20:39 Yeah, yeah. Although, I mean, it's just always, I don't like it when I see like these, the FL sliders. So I think that this is more than, of course, more than just replacing the FL sliders. It's also doing things like unpacking and other sorts of cool stuff. But you're right, yeah, there's a lot going on here. There is, there is, but it's cool to see innovation around this, I do feel like that thing, that general idea is missing from Python. I know people say you could just use a dictionary or stuff. But there's like a lot of a lot of cases where if else is buggy, hard to maintain, or like these other cases are very, you know, verbose, and so on. Anyway, I'm happy to see this, I think, depending how it comes out, it's very complicated. But uh, the idea is good. So one thing that we've talked about a lot, Brian is how do you host your own private pi, pi, right, pip install a thing. But I wouldn't be able to pip install and version. Like, say you work at a large company, you probably have libraries, packages that you've shared across projects. How do you like have the PIP style package management, but for you, well, we've got a custom pie in our work is right, and that's fine, that's fine. The more global you are, the harder it is to maybe do that. Well, without people getting a hold of like, obviously, you want to protect that code, because that's internal private code. But at the same time you want to share in version two, there's all sorts of options that you can set up and take care of that. But there's this new thing, which tormod MacLeod has said over our way called code artifact from AWS. Neat. Yeah. So the idea is, it is a general purpose, basically, package management system for a variety thing. So right now it works with Java with Maven, and Gradle. For JavaScript, it has NPM and yarn. And for Python, it has PIP and twine. And basically, you can just set it up in AWS and tell it to go. And they'll take care of all the storage, and the security and all that kind of stuff. And then you can just pip install all the things. And it also is backed by the real pi pi, or the real NPM. And you can whitelist stuff you say, Okay, if somebody PIP installs requests, just get the real requests and stay in sync with that, but let them have it. But if they pip install that misspelled request, I think you can say don't don't let them have that type of squatting hacker version. Yeah. So these sorts of solutions are pretty interesting to be able to have basically a cache of API stuff, and then also your own stuff. So you push to it just like often you publish it. I don't know about this one. But often you some of these, you use twine or something to push just like you normally would, but it doesn't go to ipi goes to your own thing. Yeah, it's pretty neat. It reminds me of artifactory, which people might have heard of, which is looks really cool. However, if you look at like the pricing, it starts at, you know, just $2,900 a year, right? For the base version, the pro version is 14,000. And it goes up from there. So you know, this is it looks like one of those cases where one of these cloud services from places like AWS and so on, it's coming along and going, you know what, we got you. And it's not 14,000 a year or whatever, or month? I don't know, whatever the you know, it was I said there per year. Yeah, I think to some degree, I believe GitHub is working on something like this as well. I can't remember what it's called over GitHub. But it doesn't have Python yet. Which is why I haven't jumped up and down about it. But I think it will I think they're working on it. Well, supposedly like warehouse was something you could just use that is used for oil. I guess they don't call warehouse anymore. But ipi.org that the new pipe? Yeah, yeah. So I think that you can deploy that yourself, but there's not I haven't seen very many people like well, one I'd like to see people write instructions on really how to get that up and running for yourself. And and also like to see some like, you know, warehouses a service and sorts of things anyway, not so free money laying on the table there people Yeah, that's a good point. That's right. I What's his last one I wanted to bring up invoke, and it's what pi invoke.org is where you can see the documentation for this. And to tell you the truth. We've had it on our list for a while and I've tried several times and couldn't get it to work but

00:25:00 I had some confusion so that my confusion was the product. When you install it, you install it with pip install, invoke, not with the PI part, but there is a PI invoke on pi pi, but it does something different. So, the invoke that I'm talking about is invoke without the PI in front, but the website is pi invoke.org. Okay, if you're confused, I'm confused, but we've got it in the show notes. But why do we care about this, we care about it. Because it does make me feel I like Mike files, I think make files are fine. There's parts of them I don't like like, I don't like that the tat like, it's the only thing in my life that I have to use tabs for. Because I usually use spaces in Python. But make files have tabs. And often things like cleaning out your building your documentation, or kicking out for tests or deploying or a lot, a lot of those other book maintenance things. For a project you put into a no make file. And some people use talks for that. And you can, but invoke is intended to do that sort of thing. But with Python code. So with invoke, you just create a little test.py file with these little tiny, you just have little functions that you decorate with the Add task decorator. When you if you have it installed, you can just say on the command line invoke and then the name of the function. So if you have a build function, you can say, invoke build, and you can pass in command flags to it. And it's just pretty easy to run something. So something like you would use make files for. You can have it without any makefile. Yeah, that's cool. And you get to write Python, or your scripting, right, basically, yeah, the project looks like, I'm not quite sure if this is recent or old, it says that it was intended for building documentation. But it does look like there's some examples on how to combine it to I don't see why you couldn't use it to, to run your tests and run all sorts of other stuff too, because it's just, it's got things like you can run Python code, but you can also run command line, it can launch a command line tools, and all sorts of stuff. Yeah, if you can run stuff off the command line, then you could do get pre commit hook type stuff, are all kinds of automation, or even like cycle, the version like increment, the version numbers and all kinds of stuff, you want to put it together. Oh, yeah, that'd be a good thing to put in there, version incrementing. And then also just like things like deploying, like, check linting, that's a good thing. And then you can still make fun. One of the neat things about make is different make targets can depend on each other. And this one has dependencies as well, you can have, like, for instance, build can depend on clean and can have to have to run off and do a different target. And you can make a whole mess of stuff in there. Or you could keep it clean. But I like things like this that have I mean, one of the reasons I'm not even I don't mind make files, but people that are not from a Unix or don't come from Unix background. Have no idea what to do with a make file. Yeah, it's good for the team to make it easy for them. Yeah, yep, indeed. All right. That's pretty cool. I like to use this. And I just got to think of a reason use case for it. And, and I will, it's great, though. Well, that's all of our six items. Actually. I've been like totally swamped at work. I don't have a lot of extra things to share with people. You have anything extra for us. I have a mysteries that we can discuss no mystery. Yeah, apparently, he just talked, he talked about Python, three, nine, and it's in beta, which means it's getting no new features. It's just getting tested and ironed out. And there was Python three, nine, beta one. And then there, ido announced Oh, hey, everybody, here's python 390. Beta three is out for immediate testing. And somebody disappeared, beta two. So the problem apparently with beta two was somehow the way that it looked up certificates was busted. So if you like, installed it from source and just ran it, it would be fine. But if you install it from the installer, all of a sudden, every web requests that went to HTTPS or something along those lines would fail. So that's not good to break the networking subsystem of Python, because a lot of things depend on that. And so they quickly ditch that one and fix it and roll out beta three. Okay, and just about the time that this is released, so on June 29, we'll have beta four, which presumably will still make web requests successfully, and won't have to be disappeared. So anyway, just some beta Python three, nine news, beta three is out. Beta four will be out days after this comes out. Or actually maybe even before, so there is no beta to before it will be after before it will be before.

00:29:37 Before it will be before I think but it might be after I'm not sure.

00:29:43 So I've got a joke for you. I grabbed here off of

00:29:48 Geek and poke, which is like a cartoon strip. Okay. All right. So it's a mom and a son. And you have kids, I'm sure you know how this goes. How was your day?

00:30:00 Yeah, good day. Yeah. What do you learn in school? Not much. You were there for eight hours, continuously beginning instructed, like you didn't learn more than like half is it like or Yeah, right. So but if this child happens to be a geek, there's another ploy in which you can, you can employ another technique you can employ to get them to tell you more about their day. So goes like that says, Hi, Darlene. How was your school day? Huh? And like sort of a blank stare. Hi, Darlene. How was your school day dash dash verbose?

00:30:32 Yeah, I totally wish I had verbose flags on my kids sometimes. Yeah. Also, sometimes a dash q or like a quiet one would be good sometimes. Yeah, exactly. The dash dash quiet.

00:30:46 If I got to pick one or the other, I'm gonna go for the dash dash quiet as an option.

00:30:51 Yeah, especially for young kids. Yeah, exactly. Exactly. That he needs a little piece dash dash quiet.

00:30:59 Yeah, definitely. All right. Well, that's it for the episode, I guess. Yeah. Thanks a lot. Again. You bet. Thank you for listening to Python bytes. Follow the show on twitter at Python bytes. That's Python bytes as in be yts and get the full show notes at Python bytes at FM. If you have a news item you want featured just visit by thumb bytes.fm and send it our way. We're always on the lookout for sharing something cool. This is Brian Aachen and on behalf of myself and Michael Kennedy, thank you for listening and sharing this podcast with your friends and colleagues.

