00:00:00 Hello, and welcome to Python bytes where we deliver Python news and headlines directly to your earbuds. This is Episode 194. Recorded August 5 2020. I'm Brian knockin. And I'm Michael Kennedy. And this episode is brought to you by us and we'll tell you more about what we're we're shilling later in the day, I want to talk to you about mutants, mutants like Mutant Ninja Turtle type things are, what are we looking at here? Sure. Mutant Ninja Turtles? No. So mutation testing. So I really kind of, I think muted in warming to mutation testing. And it's kind of a neat thing. I think we've covered it before. But this article is from Marsh psutka. And it's called an introduction to mutation testing in Python, there are a few a handful of, I think there's like two or three different mutation testing libraries. Mutt is one of them. And that's what this article uses. And so if people are not familiar with mutation testing, here's the problem. So you can use code coverage tools like coverage pie, to show how much of your code your tests are covering. But even if you get to 100% coverage, it doesn't mean that you're really testing everything. And so, mutation testing, what it does is it takes your code under test, and it does a modify modification. So it modifies portions of your source code to simulate potential bugs, like, for example, it'll replace like greater than comparison with greater than equal or placing it with those sorts of edge cases and stuff are often where we muck up. If there's no boundary test around the boundary condition, you know, there'll be a problem. So every little change is considered a mutant. And it generates all these different mutants. And it does it in a fairly fairly smart way. It can test your code fairly quickly, with not too many means. So and then it runs your test suite on the mutant. And the idea is, your test suite should kill all of the means. So in this article, he shows an example of three methods and one test case and 100% code coverage. But he runs meat, Mutt and 16 of them survive, and then talks about how to fix that. So it's really quick article. Yeah, this is interesting. And I like the emoji legend use for the output. Yeah, it's a cute library. Yeah, it's, you know, one thing that I don't understand about mutation testing is like, I understand, okay, well, we're going to change like, a value of a variable, or like the wire for doing a test make it it was less than we're gonna make it greater than and see if your tests still pass. And like those kinds of things, that totally seems reasonable. But if it goes in, I don't know if it does, maybe, you know, if it goes in like says, well, you're doing a print statement. So we changed part of the print string, like, Who's testing for that? Right? Like that? Would seems like it would survive? Yeah, I'm not sure. So it seems like there's certain things like I would just never care to test for the output of the print statement where the static string changes, like, to me, that just is not something I care to test, right. And but I feel like the sort of general case of mutation testing to go, Well, here's a piece of variable that I need to change around, let's change a string and see what the passed, the tests still pass. So I don't know maybe it's just inappropriate for those types of scenarios. Maybe you only test stuff like at a lower level where you don't have like a bunch of print statements. But you know, you've got login and all kinds of things. So I don't know. But still, I do like the idea, I think. And some of the others have ways to specify which kinds of mutants to generate. So I don't know if it does the print statement sort of example, but I'm sure that there's ways to say, Yeah, I really care about don't modify string values, for instance. Yeah. Yeah. So like, Don't modify constants or something. Maybe. Who knows? Yeah. Cool. All right. Well, you know, that looks really interesting. And Marcia does a great job writing up these types of things. We feature him a lot. Very cool. Next up, I want to talk about asynchronous programming. Oh, nice. Yeah. So we maybe we've covered this before. Now, we've covered this a lot. But I don't believe we've covered async queue? I don't think so. I don't think so either. So this is from Korra. And it is not brand new, like so I just want to be really upfront, like this has been around since 2016. But it's pretty interesting. And the idea is, so much of what asynchronous programming, especially async IO type of async and await programming is about is scaling while you're waiting, scaling the latencies right? So I you know, like I'm going to call the stripe service and it's going to take you know, half a second to return and so I want my web server to be able to go and just do stuff who you know other requests instead of waiting for half a second while we're checking out some person or whatever right? But they've got a different use case what they're doing is they're running I don't know if I said this is from Cora they're running Cora calm which is a really cool q&a site actually think Cora does a great job of having like solid, thoughtful answers, not always right.

00:05:00 But thought follies, which is pretty cool. But what they do is they don't talk directly to their database, because that would be too slow. Okay, we started on that. But what they're doing is they're talking to mem cache D, or which you know, or Redis, or whatever. But they're using mem cache D, to store a bunch of pre computed query results. So they don't have to keep going back to the database. Like, for example, when you go view a question, they want to see the names of the people who uploaded the question, right? So it's kind of a complicated query, right, I need to go, here's the IDs, we we store the ideas of the boater, then we're going to do a query a joint over on the user table, and get the their names back. And then we're going to show it like that sounds expensive for lots of data. So what they do is they basically store those answers like this user goes to this thing in mem cache D. But a lot of the latency around this has to do with actually with the network call, like, it's pretty close. It's like, you know, one millisecond or something, but they've got to go get those names over and over, right? Because the way that you store stuff in memcached, D is this ID has this name, you've got 50 uploaders. It's like given the name of this person, given the name of that person. So there's a way to do like a, you know, a batch get like, here's all these IDs, go get me all the associated names. And they've got like this dependency tree of these sorts of questions they have to answer. So what they've done is they've come up with this thing called async queue, and it's all about batching, asynchronous requests, and converting them from a bunch of individual calls into like, one massive call, okay, so they can like, do what looks like asynchronous programming, say, Go get me all these things. And instead of doing a bunch of individual async, and await type calls, the system looks that goes, Okay. What that means is turn that into one giant query, where it's like all of these IDs, go to all those things, and then return them back. Oh, so yeah, it's pretty neat. So it's basically this way to write code that will take what would be a bunch of small independent requests and turn it into like a one shot requests for talking to things like caching servers and whatnot. Yeah. So apparently, this is like a core component, of course, architecture. And yeah, it's all about batching. up these calls. I didn't know core was Python in the back end. Oh, yeah. Yeah, they've got a really interesting Python blog, where they can engineering blog where they talk about all sorts of stuff. So this was like written up on their engineering blog about sort of how they went from what they're doing before this, which was, you'd have to like write several functions that would prepare the things and then you could ask for because they would be cached locally, and all sorts of funky stuff. So there's a great write up on sort of the whole use case of this. So this, like I said, is from 2016. So it predates async and await. And so they use the yield keyword, which is a sort of a more foundational way to get to break up functions into parts that run. So basically, you decorate a function, and then you yield out the various steps. And then before it executes, all those that looks at them figures out what it has to do, and then it like, batches it up. And then does it all at once. pretty well. Yeah. He Yeah. So I thought this was, you know, kind of interesting. I think it's a little bit just looking at the the patterns here, I feel like it's a little tiny bit limited, because it's targeted at, I believe they're still at least then. So when they came up with it, and it's still active, I think they built it for running a Python two, right? Remember this 2016 they've been running for a while. So some of their API's, I don't think like, for example, Ace, they don't use the async and await keyword, I think because that didn't exist. Like they supported Python three, four, where async IO was, but async. And await didn't come along until just a tiny bit later. I don't think so. Anyway, a bit of a grain of salt. But I think, you know, this will be a pretty interesting thing that people can adopt and use for these types of scenarios. Certainly, if it powers Cora, it's probably pretty good. Yeah.

00:08:58 Absolutely. Yep. Another thing that's cool is talk Python training. Thank you. Oh, we got a lot of stuff going on over there. Actually, we got a ton of new courses coming course for people who generally have an Excel and should be adopting the Python data science tools. So that's coming really soon. We've got to get started data science. I just actually last time we spoke, I said, Hey, I'm writing this course. I started writing a course. Python memory management. I finished it, I recorded it. It's like a five hour course. It's gonna be awesome. So now I'm on to writing a new course. Python design patterns. Oh, nice. Yeah, so that'll be out in a few weeks as well. How about you? Yeah. I just wanted to highlight again, I have the URL pi test book, comm set up to go directly to a router because I get a lot of people asking, Hey, your PI test book is still good for it was like in 2017 still valid? Yes, it's still valid, but there's a few gotchas. And I list them out. Very easy to read at pi test book comm directory, do an errata page to show you

00:10:00 Just a couple tweaks to the source code, you got to make it a pin I need to be and a couple other things. And we'll try to get those changes out to the download link on pragmatic as soon as possible. That's still in the works. But there's also a link to if you have any issues, there's a link to the official, pragmatic urata page where you can ask questions, and if you have not run into anything, I'd love to hear about it. And I'm excited to get a lot the lately a lot of the people that have been contacting me, said they're excited about reading the book, our machine learning people. So it's kind of neat to see data science and machine learning people add testing to their workflows. That's exciting. Absolutely. So I have a final call to action for people out there. If If you want to make sure that we have the time and energy to keep creating stuff like this podcast and the other things we're doing. You don't have to get our stuff. But how about recommending it right? If your company needs to get up to speed on Python, recommend that your company buy the courses for that team? Or if a company is doing a bunch of testing? have everyone at that on that team, or the engineering group get Brian's book? That would be great. Yeah. And then individually to remind people that we do have a Patreon campaign going so people can contribute a buck or two a month. That'd be great. Yeah, now that we know go anywhere, we don't buy coffee. Yeah. Next, I want to talk this sort of ties into your async thing. So yeah, that's interesting. But they use memcached D. But I wanted to talk about Redis. So I've not used Redis myself, but I know that a lot of people do for for caching and for other things. And so this is an article, it's actually on the Redis site, but it's an article called the Redis. Beyond the cache in Python, by Guy Royce, I think I knew that Redis did more than just a cache for her back end database. But this is kind of neat. So he there's these are good clear examples of Python code using Redis for more than just caching. So the first example talks about how to use it as a cube. So you can set it up as a fast queuing system. And apparently, there's a couple calls called our push and build pop. And actually, to tell you the truth, I picked this article because of bl pop. I think that's one of the best function names ever. I don't know what it means. But maybe back to the list pop. Not sure. But it's good. I thought you picked it because of the various from the code example, about putting stuff into cues here. felt that felt close to home. Yeah, it's about a Bigfoot sightings. And we've got a sighting near the Columbia River and people were chased by a tall, hairy creature. And so, like asynchronously adding Bigfoot sightings from the general Pacific Northwest? Yeah, that's good.

00:12:50 All right. Yeah. I didn't mean to derail you know, it's good. So using it as a cue using it in a pub sub model. Currently, there's functions, like publish and subscribe. So you can do publish and subscribe models, data streaming, using it as a search engine, the search engine seems like a little more hardcore, because it looks like they're, it's almost like SQL queries that they're using, but apparently can do that. And of course, you can also use it as your primary in memory database. If you want to, as long as you don't need to store it somewhere. So or use some later thing. You know, I guess I'm just winging it here. I don't know how you get how you hook up a Redis database to a normal database. But I know you database people know how to do that.

00:13:35 But I probably use a I like the idea of using it as a cute system for like multi threads and multi processors. That sounds kind of fun. This is a really cool article, because I just often think of Redis as cash. Right? But yeah, yeah, there's a bunch of neat stuff here. And

00:13:51 so often, you think like, oh, I'll just write this cool data structure, we'll just do this thing. And it's great. And you're like, Oh, wait, but hold on. When I deploy that to the web server, it forks off, like 10 copies of micro whiskey. And so I'm gonna have like, 10 separate dv copies and all this, like, there's just certain times you're like, I just need a thing to hold this stuff. And like Redis seems pretty cool for that. Yeah. And the examples use, apparently, there's a bunch of different Python libraries to access Redis. And this one uses aIIow Redis. Because there's async and await calls to access everything. Yeah. It's beautiful. It's a really nice example of async and await as well. Yeah. So I'm sure Brian, you've heard of little Bobby tables.

00:14:32 Yeah, of course. brought it up on the show. Yeah. I don't know if we've actually have we featured it as a proper joke. I don't know what we have. Nonetheless, this one is no joke. This is just a little table. I didn't know what I was thinking. I know what I was thinking. I was curious. I didn't want to commit as much effort as it turned out to be into having like a broad discussion about this. But I thought okay, well we've dictionaries, so I can go and find a single key passing a certain key and then

00:15:00 Get the thing back or not, right? So if I've got like, I don't know, users, I could have the user ID. And then the user object comes back. If I index a dictionary like that, totally simple, right? Yeah. What if we wanted to ask that question two ways on the same data structure? What if I wanted to say, give me the user by ID, and give me the user by email? So to one possible way, I guess you could just cram all the IDs and all the emails into the dictionary, but then things like, you know, enumerate over dict, items, breaks, because you get, you know, every now and then it's integers, or its strings, and then it's a duplicate of the users like in dot items, or dot values, right? So it's not really a great way. So I said, Does Python have like a structure that is not a database, because I do not want to do database stuff. Like if I wanted to do that, I would just use a database. thing that is lightweight and in memory and easy to use, that lets me put something like a user in there, but then be able to ask Give me the user by ID giving the user by email. That is fast, right? So dictionaries work, because they're indexed. And they're insanely like near, you know, oh, one type of performance on getting back the content that's in there, right? Yeah. So I wouldn't be able to do that both with email, and Id not. I'm going to go on this rant. Some more later, I'm actually trying to pull together all the responses I got, because I got a bunch of things given back to me. A lot of people suggested pandas, but I want to store non tabular data. So I'm not sure pandas, which is tabular ish. Makes sense. Nonetheless, one thing I did come up with, that's probably the closest to what I was asking for, without me doing any work, which I'm not against doing work. But if something exists, you know, let me pip install it right, is this thing called light table by Paul McGuire? Who sorry, not like a little table,

00:16:53 little table, and it gives you a schema list in memory thing that's kind of like a dictionary, but gives you RM acts like access to the objects, okay. Okay. So it's like, think of like an in memory database, basically, that you don't have to go create table, you know, set column type, name this to, you know, var char 16 type, and like, you don't actually define the table, like full on database, right? You just say it has, you know, put these things in it, like you were a dictionary, and then you can access all the elements. What do you think, I think I'd like to try to solve your problem. But it's a fun programming problem, right? But this thing is pretty cool. because it lets you do like greater than queries, it has indexes on all of the columns are the columns that you say you want them on, like, all you do, is say, it's like creating a dictionary. So I'm gonna put in a thing by ID, I'm gonna put it a thing by email and put it in a thing by city. And I want to index for all of those. So it's like dictionary like speed, which is pretty cool. It even does like in memory joins, and all sorts of stuff. So yeah, okay.

00:18:02 And the result of like, a query can be like another little table. So I could like do a filter and select only a couple of columns, and then outcomes, a little baby, little table, a little even littler, little table. Anyway, I thought this was a pretty cool thing, because it lets you kind of do database like stuff without the effort, right? Do it dynamically. Some people said, Hey, you should just use SQL or SQL Lite. I'm like, yeah, SQL lights. Cool. But then I've got to come up with a full on schema for defining the thing. That gets to be a pain. There's also some other options, but little table looks good. Yeah. Let's take, get an example. Get your actual problem statement again, and try it. But this looks neat. Yeah, yeah, absolutely. Yeah, well, I'll come back to that for sure. as well. So because I want to bring the like, I got so many good recommendations. And ideas. I think it's probably worth just doing a segment on that. But little table nice. This is something I'm I'm surprised we didn't talk about already. Maybe we have but I forgotten pi test timeout. This was a listener suggestion. And I think it's an A, pretty much an essential plugin for any, any test suite that you're running, especially if it's not something you're running, where you're watching it. So if it's something running on a server, or continuous integration or something, or if it's a long running test suite, it says very simple to use plug in. And what you want to make sure is that none of your tests run longer than a certain number of seconds. All the people out there that are like scratching your head thinking, wow, there's a test that runs longer than a second. Yes, there are tests that run longer than a second, especially if they're trying to talk to hardware or external things. And that thing might not be there. And it's just waiting. Yeah, there's more to testing than unit testing. There's also system testing. But anyway, this one's great because you can set up a configuration in the config file, you can throw one number in to say like, say you have like, you know, five minutes or something like that or or even just down

00:20:00 To like three minutes, I don't want to make, I want to make sure nothing. Nothing runs longer than this. And just to make sure that the server doesn't just sit spinning all day long. And then well, let's say you even tighten it closer to try to kill off a test if it's running longer than a certain amount. But there's like maybe two of your tests that are longer or a few of them that are longer, you can put a decorator on those particular tests and give them more time. And then the rest of them shorter. It's very easy to operate, and just kind of a must have for long test suites. Yeah, that's super cool. Yeah, I mean, sometimes you just rather have the test fail. If it's taking way, way, way too long. And you're like, I'm pretty sure this is gonna fail, but not right away, I would recommend just trying it out. And kind of like, look at the time of your tests and stuff and then set it so that it actually kills one of your tests in the middle, or stick a spin in there or something like that, just to verify it does, because it is sort of operating system dependent. And there's some configuration allowed in the plugin to be able to use either signals or kill commands or process killing, there's just different ways to to stop a test that's going too long. And that's so test it before you deploy it. But it's a good thing, do a meta Test. Test of your test. Exactly. Super cool. Okay, that's a great one. And, you know, use cases super straightforward. I have got one for you, that has got me really, really excited. It's called events. So in Python, we have functions as first class objects, right? You can pass a function around super easy, right? Like, if there's some part of your programs going to run and you want to get a function called when it's done, you can pass that function, the dude's work, you can call it right, you have this kind of observer style programming, right? What requires programming on your behalf is to have that happen for more than one thing, like, I would like parts of my program to subscribe to be notified about events. And one or more of them get called when this thing happens. So friend of mine, Nicola Roshi put together a really cool project called events. And the idea is that it adds event subscription and callback to the Python language in like a super simple way. So go to a function that is an event, if I want my function to be called by it, I would say like, like, if I want the event on change, I would say, my class.on change plus equals some function to call. If there's already one there is just going to add it to the list of all the functions that will be called when that event fires in if at some point, I decide I don't want to hear about it anymore, I just go to my class.or, my object.on change minus equals the function I want to take out of that subscription list. That's it. Oh, that's the in that's like, and then you call it you just say object.on change, and you pass the arguments? And then all those functions get called in order? Oh, this is cool. Yeah. So it's, if you have to do any sort of observer design pattern, event subscription stuff, like this is super, super nice. And it's inspired on the C sharp language base event keyword, which is based on delegates, basically function pointers, it doesn't really matter if you know about that, or care about it. But if you know about the C sharp version, this basically brings that to the Python language. Yeah, I kind of want to build up a face to machine using this. It's cool, right? Yeah. I mean, it could make it really readable. Yeah, I have a just that I'm working on, or I have some code I'm working on I'll post as a gist that people can check out that is like, a lot better than what they have in the documentation to the documentation takes like this raw event source and shows you how you can subscribe and unsubscribe to it. But what I've got is something that's like, how you have a class, right? Like, you know, a thing on the screen. And then you could have like, subscribe to when the location changes, or the size changes, or you know, those kinds of things. And it's more of like a natural programming analogy. So I'll put up the just for that. I'm just working on a few things to see if I can make it even slightly better. I've seen if I can use descriptors, so that the event triggering happens behind the scenes without you even have to program it as well. So like, right now, the from the outside using it right is really easy. But you do have to sort of like know, when something's changed, and then call that have raised that event, I think I can use descriptors to maybe make it seamless on both sides. But I'm still playing with that.

00:24:22 Now, do you know if this, if all of the events get called by the thing changing the making event happen? Yes, they do. Yeah. Okay. Yeah. So they, they get called by the thing that whatever decides to raise the event, that's the thing that's doing the calling. The events just basically manage, what are the functions to be called in what order and then like you call it and it just like delegates on to them. Also, you get to just arbitrarily pick the parameters that gets passed, a get passed along. But it seems like a good idea to say this event always takes these kinds of arguments and whatever. There's not a lot of structure there. You do. Get

00:25:00 The only real safety is you can say when you create it, you can say these are the only allowed events because it's kind of just full on dynamic programming. But you can say these three things, you can subscribe and unsubscribe and call anything else. We're gonna say it doesn't exist. So that's pretty nice. Yeah, yeah. Yeah. provides a little safety. Cool. Yeah. Well, that's our six items. Do you have any extras for us? Not really, just I sort of talked about it I was going to talk about here, but I talked about it in the we talked about what we're doing how people can support us, I finished the Python memory management course, the thing is so cool. It's a five hour course just diving into the internals of like Python memory management algorithms. And what I thought I would create was something that was like understanding Python memory management. But there's actually a ton of techniques I discovered that actually let you run your code. In a way it's there like, well, now it uses half as much memory and it's 30% faster, and stuff like that. So I didn't think there would be a lot of actionable stuff coming out of it. But there is, which I think is pretty cool, actually. Oh, nice. Yeah. How about you? I'm pretty excited that pi test six is out. A couple weeks ago, we talked about the six being in sort of a beta release, but it's out now. And I wanted to mention that episode 125 of testing code walks through those changes. This is due to the miracles of time travel. This has not been recorded yet, but it will be recorded and released by last week. So perfect. Time travel. I love it. I do chosen the perfect joke. So the only question I have for you before we do the joke. is am I the school administrator IT person or am I the mom? Oh, give me the mom. Okay. Okay. So the phone rings. I pick it up. Hi, this is your son's school. We're having some computer trouble. Oh, dear. Did he break something in a way? Did you really name your son, Robert? Robert single quote up parentheses, semicolon DROP TABLE students. semi colon minus minus Oh, yes. Little Bobby tables, the column. Well, we've lost this year student records. I hope you're happy. And I hope you've learned to sanitize your database inputs. Look out for that SQL injection, baby.

00:27:13 I love it. This is so good. This is absolutely one of the most classic computer jokes there is. Yeah, I love it. Because it probably would actually work. It reminds me of that guy

00:27:26 said that his he got his license plate to be the the characters in you ll know. Yeah, I heard about that. Yeah. And he ended up getting all the like automated you know, you drove through a traffic light sort of thing. Tickets for all the records that weren't all your data with them. Any police officer that forgot to enter the license plate, it would go to him.

00:27:53 He thought he would get out of it because they wouldn't be listened to do it. But oh no.

00:27:58 It's hilarious. Awesome. All right. Well, great to chat with as always, you too. Bye. Bye. Thank you for listening to Python bytes. Follow the show on twitter at Python bytes. That's Python bytes as in be yts and get the full show notes at Python bytes at FM. If you have a news item you want featured just visit Python bytes out FM and send it our way. We're always on the lookout for sharing something cool. This is Brian Aachen and on behalf of myself and Michael Kennedy, thank you for listening and sharing this podcast with your friends and colleagues.

