00:00:00 Hello, and welcome to Python bytes where we deliver Python news and headlines directly to your earbuds. This is Episode 223. Recorded March 3 2021. I'm Brian knockin. I'm Michael Kennedy.

00:00:14 Cool. We did that without talking over the top. Hey, we're getting we're getting good at this. Welcome, Sebastian. Great to see you. Thank you very much for inviting us a pleasure to be here with you. All right, well, um, let's start it off. Oh, I wanted to mention, we'll talk about them later. But thanks to data dog for sponsoring this episode. Yeah. And Sebastian, and people maybe know you, but they definitely know your API framework, right. I hope so. At least told him. Hey, yeah. Should I say who I am or not yet? Yeah, sure. Give us a quick introduction. Okay. We'll jump over to it. Awesome. So Hello, everyone. I'm so Sam. He is the creator of fast API, which is a web API framework for Python based on type annotations. That

00:01:00 Yeah, well, it has been a used by quite a bunch of interesting organizations, and most recently, a sort of developer explosion in Berlin, Germany, my friend from Colombia. That's why Yeah, yeah. And you have the best moustache of anyone that's ever been on the show. Thank you very much. Definitely. Um, well, let's jump in. So I wanted to cover the Python developers survey. 2020 results. This is pretty exciting. We'll get we'll get a little bit to in a minute. Talk about one of the things I wanted to talk about, of course, but let's look at it a little bit. So the Python developer surveys is put on by its the PSF. Right, isn't it joint PSF? And JetBrains? Yeah, I think it's put on by the PSF. It's, like hosted and analyzed by JetBrains. But it's not collected by JetBrains. They make a point of not, you know, it's put on python.org. And maybe even pi API, but not on, not on jetbrains.com. So they try to not slant it in that regard. Yeah. So um, but yeah, it's hard to Anyway, um, there's a whole bunch of cool stuff in here. One of the things that takeaways that I was confused by a little bit at first was the use, what do you use Python for, and you've got a lot of reductions in percentages. But if you look at what increased so you kind of see that people are using Python for more stuff, and it's spreading out. So there's a increases in education. And in desktop apps, games increased quite a bit. Mobile, which is interesting. And other, so the long tail has gotten fatter. And that's good. We're using Python for a lot of stuff. Another another good sign is a Python three is increased. So last year, we had 90% usage of Python three, now it's up to 94%. Not sure why it's not at 100% yet, but I think there's some probably some legacy stuff. There's some some projects out there and they are the they're in the please don't touch it. It's working. Nobody knows how it works. Just leave it alone category. And that's probably that last last 5% or so. Yeah. Um, what are people using for Environment isolation? We've got virtual env at 54%. But I assume that also includes v and v are the built in, there's like, Yeah, I saw there was no mention of V m v. So just virtual envy probably is that as well, that's I had that same question like, wait, surely somebody uses PIP

00:03:26 or Python, bash and V and V? Because that I answered that question. So we kind of use those interchangeably. So I guess that maybe that's what it what it is. But one of the things that surprised me was the the I've heard, I know a lot of people use conda for data science stuff. That's a 22%. But 32% are just using Docker for isolation, which that surprised me. That's an interesting thing. That's a hardcore isolation. Yeah, yeah. Although I think more and more people are just using it all the time for a lot of stuff. So guess why not? Sebastian? What about you? Are you a poetry? Are you a Python dash m, v, and v? Are you a Docker over the place, I truly am quite a fan of poetry. And I think it's a great tool because like, it

00:04:10 puts a lot of functionality in the same place handling dependencies in handling various environments and handling pinning versions. When you have a new package with poetry. It automatically detects what is the latest version, and as they write a Rangers version. So I think that's very, very cool. I'm creating a package with poetry is super straightforward to create a package that can be later published directly. So it's more similar to NPM in the Node JS world, right? You can publish from it as well, right? You can create the package and then publish. Yeah, I have like all the configurations together. But at the same time, I'm using a funny little Python VM in a bunch of projects at work and things and I want your Docker as well. So yeah, it's many different things. I will think that for local development is always one type of

00:05:00 virtual environments been VM for poetry and then for deployment. Sometimes it's just like pure though there are some things poetry inside of Docker but not even using the virtual environment. But yeah, I will think Docker for deployment and then locally virtual environments, at least for me. Yeah. And that was the majority. I think most people are primarily using V and V. For that, but I can't remember exactly. Hey, Brian, quick comment. Yeah. What's up? is V and V. vs. Virtual env via Python two versus three thing? Oh, yeah, I guess maybe it is, I think, you know, v. and V. was added, I believe in Python three, but, and I kind of forgotten about virtual envy. But there's some interesting stuff. I think we covered it a while ago, the release of version 20. Because it actually does a lot of interesting stuff. And then Magnussen has a comment on poetry, use it to create the virtual environment manually into in order to use dash dash prompt, which is, so it's not called V and V when your prompt changes, but project name in parentheses when your project changes, which is the question Gandalf had, and then Dean is a fan of the virtual envy wrapper as well. So awesome. This? Yeah, I haven't either. I feel like this is one of the areas where there's just so many different ways people are doing this stuff. But yeah. With our special guest here, Brian, have a touch on this one. This is this is big news here. Yeah. So this is this is big news. So frameworks and libraries under web frameworks, we've got flask at 46%, Django 43. And then done fast API at 12% is the first time it was on the survey. And it's already up at number three. So

00:06:40 the growth is super, super interesting there. And yeah, congratulations, Sebastian. And I actually think that this is going to grow quite a bit more if you look at the first derivative, it's it's higher for the numbers for fast API, like the rate of growth, or just the growth. Also, I feel like a lot of people are are not necessarily that leveraging. I mean, I'd like to hear your thoughts on this question. Leveraging fast API is ability to deliver HTML as well. Yeah, absolutely. Because if you're rendering HTML into by cam, the benefits of fast API are not as obvious. So I guess people broadly will use it more for API's, but then a, there's actually a bunch of people just need for very different stuff than what I initially thought, yeah, yeah, I think you know, I think you can basically get down to the starlet type features and stuff. And then you can build you an equivalent of flask or Django. And what I think's interesting about that is a lot of people are like, well, I could do this really cool API with fast API. And then do we use flask or Django for the web part is like, well, if you've already got the fast API part, and you've got like, 10 pages you want to serve, just, you know, don't don't juggle two apps just like put them there. It's actually not that hard. So I think there's some really interesting stuff. And I think as people learn those and leverage those, it's only going to grow because they're like, Oh, I actually don't have to have flask plus fast API, you could just have fast API. Yeah, the flask is bad. But yeah, yeah, of course, I'm like fast API is actually a fast API, always. And was inspired a lot by all of these frameworks that paved the way like all of these designs of these ideas came before first API's again, just putting them together with the new type annotations from from motorbiking. Yeah, like, it's all the work that has been done by a lot of people standing on the shoulders of giants type thing. Exactly. Exactly. Yeah. Yeah. Awesome. But yeah, I've got some stuff to add to that as well, for my next item, by the way. Oh, yeah. No, before we move on, one of the things in the survey that was interesting to me was,

00:08:44 was the use of continuous integration. So I use ci, continuous integration all the time, but one of the see if I can find it, see, the CI system is in use. Git lab was top, which was interesting to me. I mean, I use Git lab at work, but I use GitHub OR gate. I use, I guess, git lab ci, but I'm using GitHub actions a lot. And I don't see GitHub actions, even here. So I wonder if it just wasn't listed? Or I'm not sure. That's quite interesting. Yeah. I hadn't noticed that good elections is not expected to see it as well. Yeah. But what I did not see, I just want to throw this out, like well done. I'm building a survey, because what I didn't see is, what platform are you on? Do you use Python? Or do you use SQL? Or do you use Vue JS? Like the like, they did a good job of comparing apples to apples in this one. And that was nice. Yeah, yeah, I guess. But like, I guess you what you brought up before on the the web frameworks though? The like, Why? I mean, it depends on what you're using the web for. So yeah, like you. The early use of fast API was just API's. So no, that's not apples to apples, right. You may be doing flask plus fast API. Yeah. Yeah. And that the survey allows that you can, you can if you add these numbers,

00:10:00 There are over 100. So I wanted to bring up one more thing. I guess unit testing is at 49% for pi tests, so pi test doesn't lead. So yeah, I also saw there's a really interesting number two, and that list there 28% of using unit test. Yeah, no, that's not the one I was thinking of. That's number three. Wasn't number three. Number two is number two. Number two is so you know, in Python, when, like, a lot of languages have no or nil, but apparently, people just like, do stuff with the nun type to test here a lot. So

00:10:35 yeah, that is number two. Yeah, it's crushing it. Yeah. None is key. I mean, you do get a lot of exceptions. And it's easy to like, fail first. And then yeah, anyway, so I got a time type has no attributes such and such that I get to talk to the pipe PSF and JetBrains about this, because I'm not sure why they call it unit testing frameworks we gotta get, we got to drop the unit off. They're just testing frameworks. Yeah, Brian, I hope you don't mind. I'm considering writing a book on this new non framework, by the way, I just, I think you should, that would be funny. Actually, I

00:11:09 yeah, it's really short. It's really, really short.

00:11:13 All right. It's probably one page book. Okay. All right. Next item. Gotta keep moving along. But we're gonna have a two hour show here is I like ninjas. Do you like ninjas? Guys? ninjas are cool. Oh, yeah. Well, I mean, I don't know any. But well, I mean, if you are a ninja, you can't really speak about it, because it's something about the secrecy. Anyway, Sebastian was just talking about how fast API was inspired by many of the frameworks that were on there. And there's a cool framework called Django Ninja, fast Django rest framework. And I'm not a super expert in Django, but I think Django rest framework has been primarily the way to do API's in Django these days, and you layer that on. And if you look at the very bottom of this, there's a little bit here that says this project was heavily inspired by fast API developed by some guy named Sebastian. So that's pretty cool. Have you checked this out? Sebastian, I have seen it. And actually, the author was quite active in the API community and like, yeah, like I haven't been able to play around with the framework itself. Yet, like, I think it could be a very nice, a very nice middle ground for people that is already having a lot of work or already have code with Django rest framework. Yeah, exactly, exactly. So this was sent over by Marcus sharp, and Adam Parkin, who goes by codependent coder independently. So thank you both for sending this in. And the idea is that it's a framework for building API's primarily based on type hints, but also with async support. And it makes use of pedantic and those are many of the important ingredients that make fast API special as well. So some of the key features are, it's pretty easy to work with. It has a similar feel as fast API. It's high performance, partly because of Titanic, partly because it has native async support, and partly just as they did a good job. They're also fast to code. The type hints let you know what you're working with and automatically get conversions along with pedantic Of course, does massive levels of like validation and conversion. And then it also has automatic docks with open API formerly known as swagger, similar to fast API in that regard. And the reason this is interesting, I think, is because it's Django friendly. So it has integration with Django core, it has integration with the Django ORM. So if you're already, like got all of your stuff done in Django, and you're thinking, well, I really want to have these the style of API that fast API brings. But I don't want to leave Django, I don't want to have to rewrite everything and SQL alchemy and learn the async API over there. And that kind of stuff. Well, here's a way to kind of like layer on API's to your Django app, but in the Zen of what, Sebastian? So yeah, I think it's pretty cool. And if you check out the performance, here, you can see, it's slightly faster in the single threaded version. But once you bust out async and await and it starts just crushing it. So here you can see like with 50, operations, 50, workers and so on, it was really interesting, as you see, like this graph at the bottom of as you add more workers, things like Django rest framework or flask, marshmallow start to catch up, in my theory, looking at this graph, my intuition is what this means is the thing that it's talking to and the back end, like the database that it was talking to, or something like that is starting to like not be able to take it anymore. Or the the overall CPU level is just starting to like to hit a limit where it can't scale, because it's really interesting that it's kind of just like, linear number of things for or flat for the Django ninja. And as the scale increases, it kind of gets it's normalized so that so it would be flat. But anyway, it's a pretty interesting graph, I think there. Yeah. And then last thing, just a super quick example of here is, all you got to do is create a ninja API ninja and then you do an API dot get give it a URL, you give it some parameters. those parameters have types like a colon int B, colon int, and then you return a dictionary.

00:15:00 Off you go. And then you've got an API. And presumably, you could make this async def ad, although there's really no reason to do it. You could write because it supports asynchronous. Anyway, I think there's a pretty cool thing for people already doing Django and like, we have so much logic in the orem. And in the other parts of our app, we just want to add in this style of API, I think this is neat. Absolutely. Yeah. Cool. Cool. All right. Well, let's see what's your what's your first item, Sebastian. So I have by done tick 1.8 was released, it was was released one or two weeks ago, is the latest version. And it has a bunch of interesting things. It has a hypothesis plugin for doing property based testing, which I haven't been able to, to try out yet a lot. But I have heard a lot of good things about this, this idea of property based testing. And in fact, there's, there's a package for doing this type of testing, integrating hypotheses with open API. So you can like it was made to test first API actually, with these ideas. But then now there's an integrated a plugin in a Python three. So I think that's, that can be quite interesting. And also, there's no support in by downtek, directly for name tuples. And for type dates. So type, these are these new types, or type declarations to say, what is the shape of a dictionary inside of Python, if you have played with TypeScript, it will be comparable to an interface or ages, you know, languages to a, then these type dates, the thing is that they are the official or standard way inside of Python that are part of Python to define the types of dictionaries, because I don't think it's actually a class. So these school B, I think these type dates will be interesting, for example, for declaring a the parameters of a function that are actually a dictionary and the current word types that that dictionary will take or things like that. And they will expect a editores, to be able to have support for that. So imagine that you are passing a parameter to a dictionary, and the bar is a parameter to a function, and the parameter is a dictionary. And then the editor can give you completion for the dictionary inside of the parameter that is part of the argument that you're passing to the function and things like that, I think type takes help. And then now you can use an insight of biotic models. And I think that's critical. And these other one is the fact that he has support for annual data types, which is another of these types. So a annotate that is one of these things that you import from typing the same way that you will import a optional or that you will import union, or that you will import the type for lists. A, this is cool, I was wondering how you would do stuff like this, if you could say add a default value to a pedantic model or to add simple constraints. Yeah, so the default values would be nothing. And with a CPA, you have a way to declare that before annotated as is that you have to declare those things by setting the default value a as a call to antics field, which is a special function or API, you can call, for example, a

00:18:19 default function query, which is a special function that returns a special object that has all the information including metadata for validation, and maybe like the title or the description of their specific parameter, things like that. But then the the issue with that approach is that we are taking the place in the in the declaration of the parameter inside of the function, we are taking the place that will be used by the default value. And we are like playing around with that default value inside of the function signature inside of the function declaration of parameters. So it's actually not like the most correct way to do it. It's kind of intuitive. And it works quite well with identical API, a, but in terms of types, it's not very, very explicit. And now with these new and updated a type, you can put the actual type that the parameter has, like, let's say it's a string. And then you can also put the extra a metadata to Google for Python, or for fast API inside of the same annotated, a generic type is the name. So the same way that you will put they say, annotate a type that is a dictionary that has strings as keys, and then as values is how it has integers. Then instead of that, we will put this annotated thing and declare the type of the parameter and these external data that will include like validation and a bunch of things. And then the default value can be kept for the actual default value of the browser. So Right, right, that can be very useful, especially if you are calling the same functions, for example, for first API dependencies and you're calling the same function in other places.

00:20:00 And I think that data can be very powerful one very, very useful for reusing a code in remote places. Yeah. When I first looked at this, I thought it was this annotated thing was the value you were setting like SQL alchemy would be or Django ORM or something where you say like, name equals an annotated thing, but that's actually the type name Colin, this really interesting annotated thing with lots of constraints equals some potential default value or equals nothing, right? You just don't even have to set a value. Yeah, yeah. Like, I don't know, I feel this syntax might look a little bit weird is not necessarily like the most intuitive, but it's like the most correct at the same time. So in cases where like this strict type correctness is important, I think this is this will be quite useful. Yeah. So another thing that I this is not in the new release, but I'd like to hear your thoughts on it. Is it called validation? Is that what it's, there's a type with like runtime validation. I think this this thing here is you say app validate arguments. Have you seen this for actually going? You know, instead of just suggesting that it's a string and an integer, it will actually make sure that it's a string and an integer at runtime? Have you played with this? What are your thoughts? I haven't played with it. Like I remember when somebody was talking earlier. And I it was super exciting, because it's also a very, it's the same idea that what, what faster API is doing, or similarly, what typer, which is like a cool interface API for building command line applications that the equivalent of what they do, which is take a signature in there, take the parameters from the function and use those parameters to do validation. A, I think that's very interesting and very powerful. Powerful. I just haven't used it yet. Because I use Python, most of the time with first API, and in first API, there's no need to add this specific decorator, because that's the case already doing that. But for other use cases where where it's not really using fast API, but just by downtek. standalone, because identity is awesome. itself. I think this will be very, very powerful. Yeah, yeah, totally agree. Okay, cool. Anything else you want to add on this? Before we move on? I kick it back to praying? Oh, that was the highlight. I have just I think we burst by this quickly. But I was curious, not about this. But you mentioned fast API does validation? I just went by that quickly. But is that true? Can you profess API, can I say that this, this data, or this, you know, data point that's coming in has to be in a certain range of integers or something like that, absolutely. Like all the validations that you do, that you can do with by dumping, you can do them with faster, okay, I'm actually like quite extensive the things that you can do, you can say that you want to validate against regular expression, or that you want to have a minimum number and a maximum number, or that you want to have, like, I don't know, you could even write like custom types of validations, for the things that you receive. And because Python thing is based on the same standard Python type annotations, you go to these validations, even for deeply nested data structures. So you can say like, my, my request of this endpoint is going to receive a list that contains dictionaries that inside contain this key tag contains strings, and this other one that has some dictionaries. And so based on the, you know, like, a very complex, deeply nested tree of data, and you can declare all that and have all that validated so that when your code executes, when when the code that you wrote executes, a, it's it's a faster way to get on making sure that the data that you that there is the data that you receive, your code will never execute with invalid data. It's so it's so nice in that regard, you just like, by the time it gets here, I know it's all been converted and validated, at least as much as the model is going to validate it for me, you don't have to worry about that. So it's great to push that to somewhere else. Yeah. And on the other side, they because A, which is also a great feature of dynamic data validation shows the errors exactly the place where they are. And when you get that is like, Yes, I can see exactly where is my data wrong. So you can see which index in the list was incorrect. And inside of that index, which key was incorrect. And inside of that, what was the exact error and see like, Oh, I had to put a string in order now object here. Now that JSON, what you mean is like if I have a pedantic model, and it says it has a list of customers, and there's three customers in the list, but the third customer that was submitted as part of the JSON body has an error. It'll say, in the customers in index three on this field is the problem. Not just the name is required, like Oh, great. What does this mean?

00:24:49 Right, exactly. So yeah, I don't know. I don't know how you do to make these examples out of the war and understand the world the same time. It's so difficult.

00:25:00 jetski Yeah, we've been doing it for 223 episodes, I guess.

00:25:06 All right, Brian. Yeah, so something else that's awesome is data dog. So this episode of Python Blitz is brought to you by data dog. Are you having trouble visualizing latencies CPU and memory bottlenecks in your app and not sure where the issues coming from or how to solve it? Well, data dog seamlessly correlates logs and traces at the level of individual requests, allowing you to quickly troubleshoot troubleshoot your Python application. Plus, their continuous profiler allows you to find the most resource consuming parts in your production code all the time at scale, at any scale with minimal overhead be the hero that got the app back on track at your company. Get started today with a free trial at Python bytes.fm slash data dog, or just click the link in your podcast player show notes. Yes, check out our show notes. And thank you data dog. Yeah, thanks a dog and get a cool little digital t shirt as well. Speaking of cool, let me talk about the next item here. I guess I'm Next up on this on the list here. So this item comes to us partially from will Shanks, he sent me the Python side. But I wanted to highlight this sort of broader thing, because I think it's pretty interesting. The first part, let me just tell you the title, the article, the piece of news is Google and Microsoft back Python and rust programming languages. And they both I believe, do stuff with each but it's primarily Google backs, Python, Microsoft backs rust, but the overall trend is part of the story that I think is interesting. So they both come along to make significant contributions to the various languages. And part of the trade off, I believe there is that they'll have some say, or some ability to influence where the direction of these projects are going, like, hey, for example, Google donated $350,000, or not quite the right way to put it. That's what the article says Google sponsored the PSF at the visionary sponsor level, which has a price tag of $350,000. And the goal is, this is the first company to do so by the way. And so they're investing in improved peipsi malware detection, and better foundational tools and services like hip type of things, and so on. And they're hiring a C Python developer in residence for 2021. I don't know if that position is still open, or if there's applications. But anyway, I think that's pretty awesome. So yeah, I'm really happy for this. I do feel like there's 100 other companies that should be doing the same thing, you know, Bank of America, hello, 5000 people working on a Python project. They're 5000 Python developers, surely some of their well being depends on the well being of Python, and your banks and places like that have at least $300,000 to suspend that's been on it per year, I'm pretty sure what I find funny about that, that you don't like these huge companies, these huge corporations, they depending on Python, and all this stuff. And they they are for example, they are for sure, running Python, in ci, beep, install a bunch of things. And they are probably having some issues with the new resolver and pip install and taking a bunch of time and like having a lot of time by their developers waiting for the resolver to handle things. And the resolver is having to download all the packages that that match some range to be able to extract the metadata to be able to compete and to be able to do all that by tracking all the stuff. And if they BSF was a better form that they already have a feature request. And they already have the ID and they they objective to include the metadata of those packages in pi di so that people ask the API, what are the versions instead of downloading all the packages? So it is like, that seems more efficient, like 100 kilobyte or 100 byte JSON document instead of Meg's of packages. Exactly. And and he's just like, you know, like, it will probably just be like, a little funding, just, I don't know, a couple of full time developers working a little more on that than a lot of volunteering and like, with with Yeah, like, I feel a fe was birthed from that they will they will save a ton of money and time spent by their developers if they eat a whole piece of was performance. Absolutely. I mean, that's just one small example. Right? Yeah, yeah. Another one is maybe maybe we want higher performance. Like the the survey that Brian covered was one of the top requested features was better performance. Well, if we had you know, 20 companies each donate a million dollars I bet we could get a pretty awesome jet belt or something like that, right? I mean, there's there's like clear links back to the well being so anyway, is awesome Google and Microsoft is well for the rust side of things. Absolutely. But it's it's the I think part of the story is that this is a story. You know, like that. This is big.

00:30:00 News is awesome. But it should be like, Oh, yeah, and the other 20 are the other 100 companies, right? Yeah. So the people that listened to I mean, Microsoft and Google know that they that they use Python and rust, but that I think there's a lot of people listening to this podcast that know there's a need there. But they're, they're just engineers. And there's the people at the top of the company really might not know how much their company depends on these languages. Yeah. And so I actually nice. I actually would like to, I'd like to have some sort of how to start that conversation document something. Like if I, if I'm at a company, how do I start that conversation with my lead leaders? To say, how, you know, how do I talk to that to say, Hey, we use Python a lot. Can we contribute to the PSF? Yeah, I spoke to I think it was Peter Yang, about this. No, sorry, Peter Wang from Anaconda. And he has such a good insight and ideas on on this whole topic. One of the challenges is think it was he said this, like they don't have there's not a place on, you know, a profit and loss accounting system for charity. There's a place for sponsorship, where you get something back, there's a place for advertising, there's a place for it, but just charity alone doesn't quite work. So I don't know, I think that's part of the story is like, kind of got to fit into that world with like, well, we could support it. And in this sense that we've been talking about, yeah, you'll get something back. But we need a tangible we get something back. I don't know what that is. But I think there's a little bit of a mismatch there. Anyway, just a couple shout outs to some more, we got Salesforce, we got fastly, Bloomberg, Azure, Microsoft Capital One, you even find talk by them training down near the bottom of that list, sponsoring the PSF over there. That's cool. But also just to round this out. Microsoft is doing interesting stuff with rust around using it to basically replace whether using C and low level stuff like that. So they've joined Mozilla, AWS, Huawei, and Google as founding members of the rust foundation as well. And I think they donated something. And I don't know the numbers there what that means. But anyway, thanks. Well, thanks for sending that over. And thank you, Google and Microsoft, and other companies who gave a shout out to you for supporting these projects and communities. semantic versions talking about that. So um, yeah. So I actually don't know if fast API's using semver or Calver. Sebastian, what do you got? I think fast EPA will match a web page describes as they YOLO sown in that article.

00:32:37 Okay, so a version of you. So it's zero point something, the thing is that I'm managing it as if it was like very strict same version, where I'm

00:32:47 handling the, the bumps in the individuals. But all it's all a zero point something still, because I want to add some features and do some the freedom to do some changes to the API to have like the best design possible. Also, because I want to a to release the one version after you've gone and started have the one version? Yeah, I think I think is what he described. So yeah, so that what we're talking about is an article from pinic, saying, semantic versioning will not save you. So that the idea with semantic with versions is you've is you've got like a three digit number. And, you know, there's a major minor micro and the the idea is if if as long as the major number doesn't change, and you're using this, this package, or this library or this tool, it's it's not going to break you if it goes up. So if you if you go from 1.9, to one point, 10, you can upgrade, it's fine, and nothing will break. But there's a there's a whole bunch of problems with that. For one, what's that implication is just, it's not really true all the time, you don't really know. It's, it's often there's no new features. But there'll be something fixes, there'll be fixes and things. And you might actually depend on the broken behaviors. So there's, in practice, you can't really just upgrade willy nilly. So in practice, you have to be like, if you're depending on a package, and it changes its version, you have to you have to test and have good coverage for your own code to start with. And you should pin your dependencies. So you don't just automatically update to the newest one. But you should also try to regularly keep updated to the new changes. And you have to you have to do it in a try and try basis. So you do like update the new version, and then try it and run your tests. And if they pass, then repin the new versions. And if they don't pass, well, you've got to have to either you know, in below it or block that version or something. There. There are messy things that happen. Yeah, and it's getting more complicated with the new resolver. Like if you say I must have

00:35:00 pedantic below some version, and then fast API comes along says I must have Titanic above a higher version, well, whatever that other thing needed can't be as a facet. Like, there's these these intervals that no longer intersect, that can become challenging. Yeah. And like, let's say you've got an application, your end application, you're the only user of it or other people are, but you're nobody's importing it, then you can pin directly all of your dependencies, and you can test it and it's great. But if you're, if you're a library, and you're somebody's going to import you, you can't really just actually just pin everything because somebody might like, let's say, I'm pulling in requests, somebody else might be pulling in me and requests. So you pinning it hardcore is you're like you said with the, with the dependency manager or the dependency resolver, that'll break. So you got to be a little bit broad, so that these overlaps happen. But okay, so the consequences of this just nightmare is mayhem. And version conflicts, like we described, let's say, my package says, I have to have requests something and somebody else acts and somebody else says, Oh, well, I need to request version why in mind, and that's just gonna be a mess. The so all these promises. The other other subheading for the promises for semver is that if you're on zero at the beginning, you can change it all you want. So there's no promises on zero over, if it's zero dot something, all bets are off, you can change the API, you can completely break things, you can completely change the API, so nothing before worked. And in, in practice, that doesn't happen. But there are times where in the there's a, it's a lot of people are stuck in the zero version. But you in reality, the first few releases really are up in the air, you're not sure what's going to work and what's going to not not work. But after a while, zero verjus starts to be just there. And you really should have been at one because everybody's using it. But anyway, so yeah. And we covered that whole thing. I think it was my Motor Show me I can't remember about the whole zero river thing. Yeah, I'm calling it calling places out. Yeah, I mean, it's fine to have it. But like some of these projects had been out for 15 years, and they're still zero dot something. Right? Yeah. Like react was used by everyone before they released the first one data back way back way. Interesting. Yep. United States found that. There are no some months ago, I dated a little bit, a little piece in first API of some corner case that I had for some specific workaround for SQL alchemy that didn't import SQL alchemy boot excluded so much. We have some little thing over there. And it was like deprecated, not using the latest versions, or anything. And I just removed it, because it was there for a long time. And help break loose. I have had

00:38:00 an issue that had like, I don't know, 10s of, of thumbs up a I tried the issue a connected to the repository and Netflix that was using fast API for the piano. Yeah. Anyway, I had to release something quickly to get the book back because people were already depending on their Yeah, you have this problem that you have so many consumers have I mean, 12% of all web frameworks are fast API at the moment. That's a lot of people using your library touching the corners. Yeah, absolutely. Yeah. So the last thing I wanted to touch on with this is, I do like Linux instructions on what you should do about this use of testing. But one of the things that we didn't bring up yet so far is if you test something against a update, and it doesn't work, it might not be an intentional break in the API or the behaviors, look into it, and maybe notify the maintainers that there's, there's a that you are depending on some behavior that it broke, almost all this stuff is on GitHub, and you can file an issue. Yeah, potentially, or something like that. And don't don't just get mad people didn't break you on purpose. So

00:39:11 let's start out with a generosity and your thoughts. So there's a whole bunch of comments in the live stream. Thank you. I'm going to just try to like circle back on a few things. One, Magnus asked how do you say or talk about, you know, verbally, the square brackets and pedantic or even type you just iterable square bracket and bracket? I've always said interval of int, just like you would use for generics or templates in c++, like interval event. I don't know. What are you gonna say? I have no idea. I will ask.

00:39:41 Maybe you could say like, what is the actual term? I think it's one of those down there that doesn't have a naked eye. Oh, yeah. And then Dean has an interesting comment on versioning. Brian, talking talking about versioning Why is Brian not updated Chrome, there's a big update, right there. And then this one

00:40:00 For you, Sebastian, although I believe we touched on this RJ lm a little bit ago, any chance to ask a fast API question will ever become a web server like Django or flask more than API engine? Yeah, absolutely. So the API will you can use, you can do everything that you can do with flask or Django. With fast API, you can render Jinja templates in the backend. If you want. A fast the game will not include an ORM by default, because that will compromise on tying it to a database and to a title. Well, flask doesn't as well, right? Like flask, go pick Mongo, go pick sequel alchemy, something like that you read? Actually, I don't know a comparison to flask.

00:40:45 Very much.

00:40:46 I think it's super comparable. And you know, I also I created the the decorators that you can put on the templates to on the aim points to have like a chameleon template or a flat. Sorry, Jinja to template. And then yeah, I'm actually working on a course I haven't told you Sebastian in the course i'm going to release is building proper web apps with fast API plus API is like sort of factoring that stuff in and like doing forums and stuff like that. Nice vehicle. Yeah, it'd be fun. Yeah. All right. So cool. rjL likes the orem news. You can pick that. And then also a Sebastian, you had such a good tweet a while ago. And Robert Robinson wants to just touch on that, when it would be possible to have four years of experience with fast API's, as companies are still yearning for tell people about your tweet.

00:41:35 I tweeted something for those that maybe probably didn't see it, I did it something. Half a year ago, he was saying, I saw a job post a required four plus years of experience of foster PA, I couldn't apply because I only have 1.5 years of experience since I created the thing. So maybe it's time to reevaluate the way the experience is equal to skill set.

00:42:00 Like a bunch of people seem to have it because they tweeted it like crazy. My Twitter app broke.

00:42:09 And now recently, I don't know why they started with tweeting it again, I'm sharing screenshots of faith on LinkedIn and tagging me. By this point, I have two years of experience with fast API. So that is no longer true. So now, it'll be like, 20, what 2023 2023 these things will be legit, then you can apply for that job. That'd be fantastic. Yes.

00:42:35 All right, we're getting along in the show. So maybe our next two items should be kind of short, but I Subash. The next one's yours. Yeah, this will be a open API. 3.2 1.0 was released recently, first API is based on open API. So it's important for us today. And for whoever it is, in particular, a open API 3.1 consumer doesn't change much, it adds a more compatibility underneath. So now is based on the latest version of a JSON schema, which means that if you do things like for example, automatic react components based on JSON schema, now they will be able to share the same schema as open API, the previous open API was based on a very old version of JSON schema. And the new one is based on the latest version. So we will have like all the compatibility around the place in all the all the different tools. So that's, that's a great, and it will allow like a lot of interoperability and integration with other tools. Yeah, yeah. For people who don't know, if you run a fast API API site, and you go to slash Doc's, it'll generate a whole form that gives you information about the pedantic models that are exchanged. The validation that happens even lets you try it out. Right. Yep. And it's related to this. Yeah, yeah, I'm opening the is an open standard that is held by the Linux Foundation. And it uses JSON schema, which is another open standard, which is in progress, RFC, running the internet standard. And open API also uses OAuth two, which is another standard. So it's all based on Sanders, when you when you build an application with a security, it's all based on standards, and you get an application built on stars, having this compatibility between these different standards and having all things synchronized now it will improve a lot of all that interaction between those different things. Yeah, that's really cool. Awesome. Very nice. So Brian, that's our items, right? Anything you want to throw out there. Um, I am wearing this lovely Noah shirt from National Oceanic and Atmospheric Administration, thanks to the Matthew kasari. And NOAA for the great shirt has sent it as a thank you for speaking to them a couple weeks ago, and that's really cool. They also sent a couple shirts for my daughters. That was nice. Thanks. Yeah. Fantastic. That's really cool. I'm sure there's neat Python stuff there. Yeah. So anybody want me to speak at their company and and send me a shirt or

00:45:00 On.

00:45:03 Sebastian, we always throw out just little extra items. If people if you got anything extra you want to let people know about anything you want to share. I just got curious recently about item, which is a kind of react in Python. And you can use it with through Jupiter. That's the it seemed quite interesting. I haven't played much with it. I know, I just changed the way that it works. It's, it's a bit mind bending, but it's quite quite an interesting experiment. Yeah. Awesome. Okay. Very cool. People should check that out. And Brian, it's true. Everyone has a price. Everyone has a price. Some people, it's just a T shirt. That's awesome. All right, I got a four things I want to throw out there. And then joke, I'll make these all super, super quick. So first of all, I wrote, I've been to all of my courses. It's always like, Oh, do you need Python? Do you have the right version of Python? Are you on Windows? Oh, then here's what you are going to need to do to get there. Like, here's how you check it. You don't type Python three, that will never work. You type Python unless you are a certain version of Windows 10, then a report that it's not there. But like, there's just like, Oh, my God, what is happening? I just couldn't take it anymore. So I finally broke down and wrote a I don't have Python, any Python. What do I do? Oh, I'm on Mac OS. Okay. So then here's how you find out if you have Python is a good version. If not, here's three or four options for each OS, the benefits, pros and the cons of potentially, say using homebrew, and then how you install if you want to go down that path. And so anyway, I'll put a link in the show notes that people care about that. Nice. Thanks for doing that. Yeah, you're absolutely welcome. Last time, I was so excited still, I'm excited about Boto three type annotations. But someone pointed out that this you notice the last updated two years ago, there's a deprecated Oh, there's a fork over here. And if you go to that it goes, you go down like oh, no, no, no, this is deprecated. It's over here. Eventually, you end up with this my PI Boto three builder that uses my PI to dynamically generate the type stubs for that are compatible with VS code and Python and so on for the Boto library. So if you're really super interested in that thing I covered last time, you know, check this out, follow the GitHub thing, but use it fast before it's deprecated. Yes, exactly, exactly. And that comes from Dean, LinkedIn, who is also on the live stream. So thank you for that. Dean. That's awesome. We had Brett cannon on the show was that last time or time before? Last time, right? Very, very recently, we had Brett cannon come talk about various things, including the pattern matching stuff. He also talked about Python launcher, and we threw out like, hey, if I'm in a subdirectory of some project, and somewhere up, there's a virtual environment, and I just try to run it, it should automatically find the whole project sort of ambient virtual environment. So he apparently added that for us. Yeah, I just traded this morning. Awesome. Yeah, fantastic. Last, the last thing I'm thinking of doing an Ask me anything talk Python episode where I get some people in the audience to interview me and ask the questions of the audience just about the show. So I'll put a link in the show notes. If you have a question you would like to ask on talk Python and make it part of the Ask me anything. And we'll do that it was live stream it on YouTube as well. Alright, so that's all my extra items. We need a joke. We need a joke. All right. Well, last time, I really enjoyed this one. So I thought, the funny code comments. So I thought we might come back to this. So so I think I'll kick it off, I guess and then Brian, you next and then Sebastian, you can you can pick up the third one. How's that sound? Awesome. All right. So here's a comment that kind of misunderstands Exception Handling constructs.

00:48:18 To try finally comment in the finally block, it should never happen.

00:48:24 Try exceptions never happen. No, no, no. Try Finally, that probably almost always happens.

00:48:31 Yeah, that's a good one. Right. All right, Ryan, you're up next. Oh, okay. So comment that says, looks like C code because of the comment style. But you may think you know, what's the following code does, but you don't trust me fiddle with it. And you'll spend many a sleepless night cursing, the moment you thought you'd be clever enough to optimize the code below. Now, close this file and go play with something else.

00:48:56 Alright, so the next one, cheers. So there's this a declaration of a constant integer with a name of capitals, t n. So 10. And the value is the number 10. And the comment says, as if the value of time will fluctuate.

00:49:14 You know, you don't want magic numbers in your code, like, like blue might be better than some hexadecimal number, or like Mac the limit might be 10. But just the word 10. There's no reason for that. And also, I'll do the next one here. I am not responsible for this code. They made me write it against my will.

00:49:38 So yeah, if this code works, it was written by Paul, if not, we don't know who wrote it.

00:49:49 And then the last one says option so is it the creation of options, the batch size is equal to 300. And then the government says madness and then screams this

00:50:00 This is

00:50:03 from the movie 300. Fantastic.

00:50:08 Nice. Awesome. Well, those are some really good important comments, all of them. I think the Sparta one kind of inspires you like we're gonna go to batch size 300 Let's do this. The others I don't know about them so much. Now I'm gonna start doing the if if this code works is written by me. I know we have version control. You can you can just look it up. Yeah, sir. There's blame. Well, that was fun. We're done. Thanks, everybody, for joining us.

00:50:35 Thank you, Sebastian, for joining us. This is great. Thank you for the invitation. Thanks, everyone for listening to my voice.

00:50:43 It was great to have you here. Thank you.

00:50:46 Yep. I run by Brian. I

