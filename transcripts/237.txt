00:00:00 Hello, and welcome to Python bytes where we deliver Python news and headlines directly to your earbuds. This is Episode 237. Recorded June 9 2021. I'm Brian knockin Michael Kennedy and on microbes. Hey, Mike, thanks for showing up today. Tell us a little bit about yourself. Yeah, well, thank you guys for having me. This is actually really fun. My name is Mike groves, I am leading the engineering at a company called assembly AI. We are a mainly a Python shop. But we do a lot. We do speech to text for developers. We're an API company. So you can really think of us as we, we are trying to make speech to text and all of the all of the ways that you can take that text and do things with it really easy for developers, so that they can, you know, integrate this value into their products and make their customers happier. Yeah, that's really cool. I had somebody who I'd spoken to you guys at assembly ai, ai for some talk Python stuff. But someone else that I'm working with reached out to me and said, Hey, I'm doing this stuff with this assembly AI API. And I don't know how to save the file that Well, can you help me? I'm like, Oh, this looks really simple. This is really nice. So yeah, you guys doing good work? Yeah, we tried to make it really simple. Yeah. Yeah. Fantastic. Right, shall we kick it off? I think we should, with A to E. gooey, a GUI, a graphical user interface. And this new trend of taking stuff that happens in the terminal and making it nicer. We've covered things like rich and stuff before, right? Yeah, a lot. I love it. Yeah, I do, too. I'm super, super big fan. So I want to cover something that's like a derivative of rich from will McGann of gogan. See, here, we are missing some names already. Sorry, well. And the idea is, if I wanted to create, like Emacs or a richer UI with some, like rich, I can sort of control stuff on the screen and how it prints. But it's not full on curses, right? It's not, I want to write this section over here. And I want to dock this other bit to the right and have rich automatically put stuff into it, and so on. So I introduced you to textual, it was called rich.ui UI, as in text, terminal user interface, but it's now called textual. And the idea is, we can have these cool things like I would like a thing to be a header of my terminal app and the footer of my terminal app, and I want to dock a 30 column wide section to the left, and then just fill out the rest in a little area that just takes the rest of the space. How cool is that? Yeah, that's great. Yeah. And then each one of these areas is written to and controlled by Rich. So all the nice stuff that we've already talked about with rich, and the really nice things you get from there. So you know, if people remember, like ritualists, you have spectrums, and like centered text, or right align text and tables, and just all sorts of good stuff. So think of doing that. But on top of this, like lay, it's almost like a layout for terminals. Yeah, he's kind of rethinking how to do terminal stuff. So this, I know, you can do all of this stuff with curses, libraries, and things like that. But curse curses isn't always easy on all platforms. So he's re rethinking all of it. And I think it's really kind of fun. Yeah, I do want to point out something here really quick. There's a comment in the readme, it says this project is currently a work in progress and may not be usable for a while. So you know, just kind of maybe watch the repo and get notifications and stuff and see, you know, keep your eye out for it. On the other hand, this kind of thing, these early stages, a lot of people contact us and say, I really want to get into open source, I want to contribute to some project. What should I work on? Should I work on Django? It's like, well, that's gonna be a little bit complicated. It's highly polished. And there's a ton of dependencies, like projects like this that are in the early stages are really good for jumping in and getting involved if it sparks your interest. So yeah, there's a lot of room for people to do things like

00:03:55 out of the testing, do documentation tests on different platforms, and really help it so that we'll can concentrate on doing more features. Yeah, yeah, exactly. Even documentation like a little tutorial or whatever, Kim out in the live stream again, because I would argue curses isn't easy anywhere. I agree. It's always feels like Oh, boy, we're going down going down this path. Mike, what do you think? Well, it looks really cool. Yeah, it looks like a really cool library. And I think for me, I try to think of what would I use it for, and, and certainly a lot of internal tooling, you know, that we could use this for to, you know, so that we can make better ways of monitoring our, our machine learning systems and how that all works. And so yeah, I think that's would be something I would like to look at. And yeah, and also just a lot of times to is just trying something out, even if you haven't a day or two to just try it out and hit the bug. So you can really communicate that with the community on what's what is broken and what could be. What could be fixed. Yeah, absolutely. I'm excited to see where this goes. Um, yeah. So next up, I want to talk about PIP tools. So we're actually one of the listeners john Hagen

00:05:00 contacted us a while ago and said, Hey, have you covered this and we thought we had, but I don't think we have. So I'm gonna cover it now, Pip tolls. So we've talked, we've talked about other things around PIP like poetry and, and there's other ways to, to and you know, some virtual environment controllers and stuff. This isn't that this isn't an all in one thing. But one of the things that like, for instance poetry gives you is in a couple of the packaging things is locked files and stuff. And kind of a locked file really isn't, it isn't really what it does. I don't know if it's a locked file or pinned pinned requirements. But the idea around the PIP tool does does a whole bunch of stuff. But right now, I'm just going to concentrate on the compiled part. So the problem it solves is, so let's say I've got like, I'm gonna give an example of I've got like, a requirement, my, my dependency is rich in typer is a like to libraries. And depending on, I could just have a simple requirements.in, the file that has this, just those 222 labels in it. And then with PIP tools, I can take that and take that requirements in file, and, and compile it, I run PIP compile, and then I get like a pinned list. And it actually just goes it goes ahead and writes the requirements dot txt file. So just from an easy, I require these things, and it'll pop out the the actual pinned dependencies. And now I can deploy this and and all the other developers and stuff can use it, and be okay with it. Of course,

00:06:34 in before you do the deployment, please test this. So that's the idea as you upgrade your update your requirements, and then and then test it before you deploy it. But this little extra step of taking, like I've got a loose list of requirements, and I want to create a pinned list. You can also there's PIP tools also has a way to just say, I'm gonna get the syntax, right, upgrade. So you say dash dash upgrade, and it updates your requirements. One of the things I love about it also is it doesn't just do one file. So if you've got a requirements, txt and a a dev requirements dot txt, for instance, with your, you know, your testing tools, pi test and stuff such, you can throw that in a different file, and it'll it'll update those two. So you can have as many actually as many requirements files as you want, and it handles it just fine. So this is a really cool thing. Jonathan also gave us a, an example project, this Python blueprint that has example code in it, and it uses this workflow, and it has a readme. So if you want to check out a project that uses this, I'm going to do that. I don't really actually to be To be honest, I don't use the PIP tools for anything other than this. This is what I use PIP tools for is just this. I know it does other things, too. But this is what I use.

00:07:53 I'm psyched about this. This looks fantastic. I have a requirements dot txt and a dev requirements, stash dev dot txt. And in there, I've been putting like at the top, here's the stuff that I really wanted to install. And below it, these are the things I want to pin not because I actually care about them, or you would actually need to mention them. But I want things like to pin the bot to see that there's a security problem in the dependency I'm using not the thing itself. And so it'll bump the version and fix it right. Yeah. And that means I just noticed a couple days ago that there's these other libraries. I'm like, Where did this come from? I this is in my virtual environment. And I didn't it's not in either of those scenarios, right? Well, some new dependency was added to the main dependency that I didn't pay attention to. So now I'm like babysitting the bottom half of my requirements. txt file, which seems like a thing I don't want to do with life. This is beautiful. I'm all about this. I'm very much thinking that this is going to be something I'm using out there. My guess. Would you agree? Yeah, I absolutely agree. And I actually have we do not use this. I do not use this, but I will be looking into this right after this podcast. So yeah, like, why am I not doing well, this is this, this will make my life a lot easier. And I'm definitely look into it. Yeah. No, you're getting brings up. Oh, you

00:09:08 pixels is awesome.

00:09:11 Yes, it is. And he also brings up that it's all about the app versus library story. So pivotal does differently on the app side. So you,

00:09:20 you wouldn't want completely pinned dependencies in a library because it might conflict with the rest of the application. So, right. Again, you want to say I have to have the one that has the vulnerability in it, rather than the newer one that fixes it. Right. You don't want that. Yeah, right. Yeah. Awesome. Yeah. So I think you I think you're up I'm up all right. Now you Okay, so here, here's a hint on the pronunciation, but you're gonna have to give this a shot on your own. Yeah, so I'm gonna say it's Penguin, but I guess you could call it penguin. I don't know. I don't know what the proper pronunciation pronunciation there is. But so penguin is a library for automating generate the generation of of tests.

00:10:00 So basically what you do with c li, you set this up, you point it at your code, you can sometimes give it hints, and then it goes off and

00:10:12 it processes the the your files and produces tests. Just disclaimer here. And I mentioned this several times, this is very important, it will run your code so and it will try many different inputs. So you have to be very careful with what that code is doing. So they suggest wrapping it in a Docker container to prevent it from affecting or poisoning your your file system. Maybe you don't give it access to the production database, something like that. Yes, exactly. Exactly. So.

00:10:43 So yes, this this, I didn't go deep into it. But I know that they're using some interesting search techniques. This is actually developed by a colleague at a university, and there's a white paper behind it, I don't think it's here. But if you if you look it up, I'm sure you could find a white period that's associated, but it's supposed to be a very interesting technique around searching for, you know, the inputs, that would be, you know, that would find good edge cases. So it does take a while to run, they say, so you can give it some hints. And they talked about that within the documentation. But I really think this is something for me. Now I look at tools like well, what would I use it for? And, and I think, you know, a lot of times we're busy. And we don't get the coverage that we really want to get because, you know, deadlines. And, you know, we want to land this customer and, and so we have to get we have to, you know, work really quick to get this one feature done. And we don't we only get half coverage instead of getting, you know, 90% or plus so. So I think this tool could help maybe bridge that gap in those cases, and maybe give you a jump a jumpstart to to getting the coverage that you're looking for on your projects. So that's what I'm looking at it for. And yeah, I think it's a cool project. It looks like one of those systems a little bit like hypothesis safe mode of hypothesis. Only by name, I haven't actually looked into it, where it kind of tries to determine what are some edge cases and some like you give it bounds of data and it'll test different scenarios for you. Looks looks quite interesting. Brian, if you've already this. I'm not. I am actually often leery of test generators. But I don't know if people find it useful. And maybe it's worth checking out. Yeah, yeah, it looks neat. Yeah, I'm the same. I would say I'm the same, Brian. I did. You know, I was a little bit leery I guess about about the idea of it.

00:12:34 For me, as I said, I think it's just really that gap that you know, if you have a gap in coverage, and really just trying to get a quick, a quick jumpstart on on your your coverage. This might be a good tool to start with. That's, that's my thought. Yeah. Yeah. Very cool. That's good. Although, Brian, I don't know, if you really want to encourage it too much. You're getting out there. I'd known about penguin earlier, I might not about Brian's testing. You didn't need to highlight that.

00:13:00 Indeed, indeed. Alright, you got the next one? Well, I wanted to I think we're at the sponsor bit. I believe we are. So let's, um, yeah, so I don't have our sponsor up. I gotcha. There we go. This episode of Python bytes is brought to you by century. How would you like to remove a little stress from your life? Well, do you worry about users that do worry that users may be having difficulties or encountering errors in your app right now? Would you even know until they sent you a support email? How much better would it be to have an error err and performance details immediately sent to you, including the call stack and values of local variables in the active user recorded in the report? That'd be awesome. But century is not only possible, but simple. The fact of Michael uses century on all of his web properties, including Python bytes here. He actually fixed a bug triggered by a user and had the upgrade ready to roll out as he got the support email. That's also Sentry, but also because Michael's awesome, but no surprise and delight your users today create your Sentry account at Python bytes.fm slash century. And please when signing up, click the gunner promo code and redeem the redeem and enter Python bytes all one word, it's good for two free months of centuries team plan which will give you up to 20 times as many monthly events as well as other features. That's Python bytes dish slash century and promo code Python bytes. Yep. Thanks. entry. All right, I guess I got the next one. This one is sent in by us a friend of the show Brian skin. Thank you, Brian. And he let us know that there is something out there for all of us who love these external packages and all of these amazing Lego building blocks that are pie. And yet that's running other people's code with dependencies on them getting things right. And it's this is under the PI pa so this is sort of pretty neat in terms of you know, being officially the Python package.

00:15:00 authority group, right? believe. And so it's called the advisory dashDB. It's a security advisory database for Python packages published on pi pi.org. And the idea is, if somebody finds some major problem with a package, or maybe even worse, maybe it's like a typo squatting scenario, but more like, you know, that part where they were supposed to check the input in that form, and then they did this direct SQL query, they didn't do that. Now they are you really, really should change that so that they're using, like parameterised queries now. And so there's vulnerabilities directory, that is just a bunch of yamo files. You come over here, like, let's take one here that may be a security conscious bleach, I love the name of this package. The idea is you take user input, and you sanitize it by putting bleach on it, which is fantastic. But even the sanitizers can have problems right. So we check this out back apparently, in 2020. There's a problem with bleach and pipe I said in Mozilla bleach before three dot 12 a mutation x s s cross site scripting in bleach clean when RCD RC data. And either the SVG or math tags are whitelisted and such and such as said, like, Oh my gosh, but here's all the version and effects. And here's the fixed version. And then there's some more info about like, where that was spoken about, like where the problem was discovered, and so on. This is really cool. So if you depend on these packages, and we already spoke at the beginning about how having a tracking your dependencies, not just the things you directly install, let you let you be more aware of this, right, you could look at that PIP tools generated requirements dot txt file and see this problem. And then very likely, GitHub through dependent bot would even be proposing a fix. But you guys think that's great.

00:16:45 School? So how do you use it? Do you just look stuff up or you let it help you I mean, you can come over here and obviously look it up. It depends on what's going on. I think more if you're maintaining a package, you can do a PR to let people know, there's a triage service, which goes through the NIST, it pulls a lot of data from the NIST what's called the National Vulnerability Database data feed. Say that again. So like if it gets submitted there, it gets a lot of the data gets pulled back in, they have a tool to perform some heuristics to match that back up. And then you can do most importantly, is there's an API that you can use. So these vulnerabilities when submitted to this GitHub repository are then submitted outwardly to this place called the open source vulnerability or the database for open source vulnerabilities. And then this has an API that people can call to learn about these problems. So if you ran, I don't know, if you were an API company, and you wanted to make sure your API wasn't getting hacked. By having a bad dependency, maybe you make this part of your ci CD or something, Mike, you absolutely have to tell

00:17:52 our DevOps, or DevOps guru Micha, to look into this.

00:17:56 Exactly. So I mean, for the most part, having stuff pinned in GitHub will trigger an immediate security notification to you when GitHub finds out about it and when that makes it out. But if you want to be a little more proactive, or your security researcher or something like that, this looks like a good one. in the longer term, we're looking, we're working with the API team to build a pipeline to automatically get these vulnerabilities in the pipeline. So maybe like you go see it or something like that. Not exactly sure what the story is there. But it's a start for basically storing that data and sharing that data. And then hopefully like it, it makes its way over to pi pi and such. Sam Morley, welcome glad you made the live show man said Is there a tool that can run like a pre commit hook? I feel like maybe just a tiny bit of wrapper, you could call that API over the open source vulnerabilities project and get some information back. That'd be cool. Yeah, that would be a cool thing. Like don't check that in. It's got a problem. Don't push it. Yeah, exactly. Exactly. So anyway, I think this is a pretty cool one. Thanks, Brian. Skin for sending it in. Yeah, so I'm

00:19:03 gonna say, Yeah, you're a c++ developer, right? Yeah. And c++ is all about overriding functions by type, like, oh, it takes an int, it takes a float, this one takes a string, and it's totally different. Python doesn't have that. Yeah. What's funny is I don't actually use it that much in c++, I mean, you, you learn about it a lot. But I don't mean I normally don't write a whole bunch of functions that that have the same name, but take different parameters. But you can do yes, you can do that. Definitely do it in c++ and C. And I should probably other languages, you can do that in but those are the two main languages that I work with C sharp, for example,

00:19:37 as well, the Python you cannot so Python just if you if you try to do that, and the second one wins, and you just have another name that is attached to the function. So I was um, and I never really thought that I had a problem with this but there are definitely times where it would be simpler to not try to put a switch in place or something and just have some

00:20:00 Like several functions that dealt with related things, but in different functions. So this, there's there's an article called the correct way to overload functions in Python. And maybe it is, but I'm just I'm not somebody that likes to use the phrase the correct way, because somebody will tell me I'm wrong. But anyway, it's an interesting, you might, for example, here, like you shouldn't overload functions in Python, you're doing it wrong if you do it at all, for example, right? Yeah, exactly. But this is a cool solution. I totally like it. Definitely, it's a cool solution. So there's this, there's a apparently a built in way with func tools. So there's a func tools has a

00:20:41 a decorator called single dispatch. And what what it does is you can decorate a, basically a function signature with a with a single function, you say that, I'm going to single dispatch this, this function, and then you register or you do like the name of the function register as decorators around other functions. And I'm in the example shown in the articles just uses underscore, I'm guessing that's just because you don't care what the name is, I don't know. But that seems like a good way to do it. And then you've got then after, after that, you just have that works. It works like you've done function overloading. So it's awesome. So in the example it takes, you can call this format function with a string with a date with a date, time and a time. And you actually get there's like three different functions that get called one for a string one for a date, one that just falls back or something. Right. Yeah, I mean, it's a, it's a pretty simple example. And if you if it's pretty clean code, so I would definitely try to keep all these things together in one, you know, in one module, here would be mean to put them in different places that

00:21:51 are evenly spread out in the same function would be terrible, but, but keeping them together this, this is great.

00:21:58 The, the one of the things that that article mentions is that this you can't really it's called single dispatch, because it's based on the type of the first, I think it's based on the type of the first parameter. So if you want to do multi parameter ones, there is a, there's a third party plugin called multiple dispatch, you can just pip install, and then it kind of works the same, although I like this one better. Honestly, this syntax is a little different. And it probably does single dispatch to I'm guessing, but yeah, one parameter. Um, but in this, this one, yeah, similar sort of thing. It just kind of works on multiple parameters, multiple, I'm digging the multiple dispatch style, where you just say dispatch, this is arguments are the list, stir, you know, we're gonna maybe get to where Mike is going at the end of the show. But it would be even cooler, if you could just say, at dispatch, and then put a type like a colon list B colon, stir to I want to dispatch on types, and stuff like that, and have the dispatch decorator, look at the function that's passed in and look at the type parameters and they just do that. So you don't have to say the types more than once. Anyway, we come back to that as well. Yeah. So So I, you know, I'm in a past life, I was I was a Java engineer. So we did, you know, but we call it dynamic dispatch in Java. And it's, it's x, there's a lot of patterns, object oriented patterns that kind of are derived from that, from that feature, from the, you know, from, again, from the c++, well, from the old days. And, ya know, I, to me this, actually, you know, when I saw it, I was like, Okay, I could definitely use this for a lot of a lot of cases, I know that like, when you want might want to build, when you have like a piece of code that has to work with a variety of different types, but they're very similar types, maybe, and you want to do something with with that family of types. You know, I think that that would be something I would, you know, I would think to to look at solve with something like this. Yeah. Yeah, I kind of had the same thought. And I do not think I would make this any sort of normal workflow use case for my code. But there are times where you have some code that says, if, you know, argument is the type of this is a list, do this thing. If it's not a list, then make an empty list, put it in and then do this other thing. You know, like, if you're doing that type switching already, this dispatch thing might actually make it more clear, right? It's not common in Python, but there are times like, I kinda want to be able to take a string or a date time, and then just parse the string of it, you know, those kinds of things. So So as an API company, this is actually kind of interesting, fits into what we do with an API company, we have to a lot of times, you know, we were not very, we're not overly strict on our input types. We allow like truthy and falsy kind of types to come in for like billions. And I could see us using this for that, right. So that way, instead of using all that helper code, we've already written for that habit more along the lines of okay if it's this type of input.

00:25:00 Then Then you can convert it this way. If it's this type of input, you can compare it that way. And I think we could probably write some some code to to handle our inputs differently using seeing this pattern. Yeah, yeah. Very neat insight there. Brian, you blew up our chat with this.

00:25:14 Well, you want to pull out some highlight. Yeah. All right. So john C, and says function overloading was one of those things like switch statements that I missed when I first started Python, but then I found I really needed it. Yeah, I'm kind of with you on that. Like I said, there's a few cases for me that I'm like, where I'm doing a type checker is instance of that, I think is the one time but that's, you know, a couple times in a whole program, I think. Yeah, I definitely missed it at first and now I just don't even really notice it. Yeah.

00:25:42 Then you've got a you're gonna get it says Feliciano. Romana ramalho also explains this in fluent Python. I just read the pre version of the second edition. Getting some polish. Yeah, very nice. That's a really good book. And Python as well. Came out there says that's the kind of thing I was thinking of. Yeah. Oh, sorry. That's a different combo. come back to that in a minute. And then Sam Morley, I don't tend to find this kind of dispatching that useful a generalist write a master function that takes star star caviar eggs and dispatch to other functions. Yeah, yep. But if you're switching on his instance, it could be could be a time. And then stepping back. One quick topic. Kevin awake says we'd be handy with some PIP tooling could automatically check the PI pa advisory before downloading the package. That would be slick. Yeah, I just did a typo squatting and pi security episode over on talk Python. And we had a lot of interesting ideas, like almost like, have I been poned. Like, remember what I installed. And if you ever see I installed something had a vulnerability quick, shoot me a note, let me know, hey, a few weeks ago, he installed this thing, and you might want to get rid of it now, stuff like that. But I think this is another interesting thing along those lines, right? Like to cache that data, and then just say, you know, I know you want to install it, and maybe this is what they're talking about with integrating that into pi pi.org. itself. Who knows? A very cool. Alright, Mike, you got the last one subsea. Yeah, so AI Oh, SQL is a suit as it says simple SQL in Python, it's a sequel templating framework or library. That really, you what you do is you give it some SQL files with some, it has some conventions around how you define queries, and then essentially gives you a query mapping that you can then use in your code. And this is kind of a it's a minimalistic way of have access to your of accessing your database.

00:27:28 It is, you know, what the a in front of it, it's, it's natively asynchronous.

00:27:33 It works really well with async. PG, I know that we use Postgres, so that was a good, that was a highlight for us to look at it. And, you know, I think we all have worked with RMS, you know, I've come back and forth on RMS over the years. You know, I think this is a nice fit for when you have, when you, when you don't have to do a lot of touch a lot of different tables, or do a lot of joins, maybe you're a small microservice that just needs to do a couple, you know, reads and writes updates.

00:28:07 And it also I think this really helps because or RAMs, especially when you're dealing at scale, you have to really know the Orem, at a very deep level to understand what it's doing. And this kind of exposes all of you know, it really just brings you down to the sequel level. So now you know exactly what you're doing. And you you can be a little bit more direct on what you want to want what you want to do with your data. Yeah, yeah, sometimes you're like, well, I want to do the join and then the filter or not the filter, then the I don't know, like, if you're really good at SQL, you can, you can put these little tricks in like, Oh, it's actually likes it better if we do it this way, rather than that way, and probably not gonna let you do that. So let me just describe this to people out there, because it's breaking some paradigms for me. So this is a library that allows you to write queries against a database, but you do it almost with data access data, access layer style of thing. So you would you don't do you put quotes Select star from such and such you, you would say like query dot get all Greetings, or get user by username. And you have say, like username equals such and such in an asynchronous way, which is pretty interesting. But the way that that has meaning as you create a dot SQL file that has like a doc string like thing, and you write a bunch of SQL, almost like stored procedures, but just in a text file, this thing, like parses it, and then it becomes like a smart query data access layer, correct? Yeah. So it basically builds out some other data access layer or data access object kind of for you where you can basically map in these these, these queries and out it's not just queries, you can do mutations, and you can do you can do DDL and all of that. So yeah, yeah. tables or whatever function you call. Yeah, absolutely. So Brian, what do you think? Do you touch SQL much these days, um, I'm touching it more and more. And I love this actually. Because I always assume if there's a bug, it's probably in my SQL statement.

00:30:00 This looks pretty cool. So get get your get your selects and stuffs figured out what kind of queries you want to do ahead of time, and, and then use them in your code. This is cool. Yeah, I mean, I'm very repelled by writing raw SQL statements in my code. Pretty much like Kim like others like this, it looks exactly what I like, like not writing sequel, but not using an ORM. So it's no secret to the world out there that I'm a MongoDB fan. So I'm not I don't have like, direct use for this a lot. But I do find this super valuable, especially if people on the team are really good at SQL. And they're like, Oh, this, this library is inhibiting me from like, using my superpower on the database. Right, right. Exactly. Yeah, that's exactly that. I was just about to say that, you know, if you have a DBA, or you have someone who is, you know, basically they are focused or concentrated on the database and optimizing those queries,

00:30:52 you know, the, I think what, what this allows you to do, then you can go define your queries, you can write them yourself how they are as developer, and then maybe you can take that to your to the experts and have him refine them for you. without actually changing the attraction, right? Like without, yeah, you still get that? Yeah, yeah, there's also times where like, let's say, I've got an internal tool that I put together, and it needs to do database and it's really not that big of a deal to tell like your, your IT department and your supervisor and stuff, they're gonna throw up a MySQL database and, or something and interact with it or Postgres, but to say, Hey, I'm gonna throw Mongo in there, that might bring up just just a discussion that you're just not ready to have. So yeah, for sure. Let me suggest a pairing. You know, kind of like, as you pair wines, a pairing with this library, I think pedantic might go fantastic with this, right? So you get these results back as tuples. And then you could just, you know, Star our eggs that into your pedantic models, and you get your validation and also just like stuff, and then you get a list of identity, like your one list comprehension away from something beautiful here. Yeah, this is that's exactly what we're doing. In we're using. You know, I think right now, we're building out a new stack. And it's basically it's, it's, it's fast API, pedantic. AI. Oh, SQL. Oh, interesting. And you'll find JC Oh, it's it? Yeah, it's very performant. So it's, you know, because it's this asynchronous, right? We're using async, PG all the way down to the database to so it's pretty much a synchrony from end to end. So this is a really good recommendation. Yeah, you'd like it to write Brian's pretty sweet. Yeah, this is great. Yeah, I do. I really like the separation of concerns of the SQL statements, and the Python code, but the flexibility of having both it's pretty cool. Awesome. Brian, is that it for us? Um, yeah. Maybe any other topics they want to bring up? Oh, you know, I do kind of kind of crazy. So not quite an extra, extra, extra, extra hear all about it. But a couple of things sent in from some listeners. So make sure I credit these. So Daniel Mulkey sent this one in and said, there is now has been for a little while, from Science Direct, there's a journal for academics called software x. And this library is pretty cool. So it aims to acknowledge the impact of software in today's research. So if you're in academics, one of the big challenges is that whole publish or perish sort of thing. And it would be great to take this cool library and make it a thing that's out on pi pi, or conda. People can use all but that's going to take a week and a half. And you really only get credit for your citations in articles not in code, right. So this kind of addresses that to try to give people a place to publish, like their projects in a meaningful way. And I just want to point out that there's a special issue on the software that contributed to a Lego experiment, the gravitational wave discovery, which really sure got the Nobel Prize, I don't totally remember. But if you just start poking around here, you know, you might find the word Python periodically in this, this thing here. So over this one, we got some Python, I've just randomly quick articles, and they're all coming up Python. So I think that that's pretty sweet. If people are in science, and they do this computational side of thing, check this out. Very cool. Yeah, that's number one. Number two, hi, Khan has been finished for a little while. And we were able to go through some like medium platform type thing where we could watch the replays, but it's a little bit wonky in the way that the playback work. Like I had to do some weird stuff to actually get logged back in after a while. Anyway, it was fine for live stuff, but it was weird for playback. YouTube is pretty awesome for playback. And here's the I'm putting in the show notes. The playlist for all of iKON 2021. us. That's pretty cool. I don't know how many videos are in here looks like 86 videos. So if you want to catch up on the Python talks, there's a really good way. Nice. It looks like you're gonna have a kind of lightning talk there. So yeah, it's cool. Yeah, very cool. Well then, and

00:34:51 also want to make sure I get the credit for this one, right. Madison, Swain Bowden who we both met I believe at pi cascades.

00:35:00 Share this with us that aiic s image IO, which is used all over biology, biological imaging and microscopy. And that kind of stuff from the Allen Institute on brain Institute, I'm guessing is, was just really so if you're doing anything with like graphics and pictures and file formats and stuff for that, check that out. And yeah, that's it for me. I think Mike, you got one as well. Right at least? Uh, yeah, so yeah, it's PEPFAR 63 was it's I think it's proposed postponed evaluation of annotations. And

00:35:36 basically, there was, there was some, as I think I've mentioned before, you know, I'm a big, I'm a big fan of fast API and pedantic and there was some, some worry, couple months ago that this change would effectively break these projects, and in 310, if it was introduced, and so I just wanted to give a shout out to, you know, to the community for jumping on this and just being really, you know, open minded about this, and basically postponing this a little further so that to that, better decisions can be made on how to navigate this change. So I don't want to go too deep into it, but I read some of the threads on this, and it was just really positive, you know, really positive exchange within the community. And I think it turned out really well. There was like a unanimous decision, I believe, to postpone it, and it saved these projects from having to Well, basically, scramble. Yeah, right. Yeah. Worst case, it was not work. Yeah. Yeah. Let me see if I can give the elevator pitch, there was a proposal in Python 310, I guess 538. And oh, five, sorry, 563. I don't know where that came from 563563, where there is an attempt to simplify and speed up type annotations. And by because right now, if you want to do a type annotation, and if I'm gonna say, I've created a pedantic model is called user and I'm gonna say this thing returns a user, I have to import user at the top. And it was like, well, you're not going to get those evaluated or really dealt with unless you're doing type an annotation analysis. So we're going to treat those as strings, basically. Right? And things like fast API and pedantic and others were going, they would actually get the type information, standard Python style, and then use that to modify behavior, right like to do Oh, it says it's a list of n. So we're going to convert from this list of those, or maybe a list of user we're going to convert these these JSON things to users. But with this change, it would have said, well, it's a string and what is user mean? Right? If you don't know the actual type, where it's coming from, there could be multiple users. It could be a user, it couldn't track down as it been imported, yet all sorts of weirdness around it. So the runtime behavior of these type entity things like hyper pedantic fast API, we're not sure how they were gonna keep working with this being adopted. And it sounds like it's postponed at least till 311 back real Yeah, thanks for bringing this up. That's a good one. All right. Well, kinda ended the show Do we have any jokes?

00:37:59 Got some before you

00:38:01 tell you let me know if it qualifies. This is from Zack rm rf on Twitter says Did you hear about the for Python? He says that robbed a bank three got caught and when question they all stated that the fourth would never be caught couldn't be caught because he knew regex and it was something of an escape artist. Haha.

00:38:23 That's funny. Yeah, I think that's pretty good. Well done. Zack. Thanks for sending that in. Brian. You got anything as well? Yeah, let me go. Pull it up. So rich, not rich, Wilma. McKagan asked about rich and said said hey, if I wrote a book about rich, what should how much money would you pay for it? But also what should it be in the book? Of course, I said it should cover how fast it is to install it kind of get rich quick guide.

00:38:57 Love it. Love it. And I believe the response was something like Get out. Get out.

00:39:02 Definitely. Oh, nice wheels getting a lot of coverage this week. That's beautiful. Good work. Alright, speed of coverage. Yeah. Thanks for being here, Mike. Thank you guys for having me. This is really fun. Yeah, thank you. Thanks for everybody for joining on the live stream as well. I'll thank you for listening to Python bytes. Follow the show on Twitter via at Python bytes. That's Python bytes as in V YT. S and get the full show notes at Python bytes dot f m. If you have a news item you want featured just visit Python by set FM and send it our way. We're always on the lookout for sharing something cool. On behalf of myself and Brian rockin. This is Michael Kennedy. Thank you for listening and sharing this podcast with your friends and colleagues.

