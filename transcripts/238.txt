00:00:00 Hello, and welcome to Python bytes where we deliver Python news and headlines directly to your earbuds. This is Episode 238. Recorded June 15 2021. I'm Michael Kennedy. And I'm Brian rocket. I'm joined now. Hey, Julia, thanks for coming on the show. Yeah, thanks for having me. Yeah, it's great. Why don't you tell folks a bit about yourself? Yeah, so I'm, I'm the head of open source at Saturn crowd and a maintainer of dask. So I split mine, I'm half and half, I spend half my time just doing regular maintenance II stuff on gas. And then half my time doing like engineering and product management on Saturn cloud. Saturn cloud is a data science platform that really specializes in distributed data clusters in Jupiter, and making it really easy for people to get up and going with those things on on AWS. Yeah, dask is really interesting. You know, when I first heard about it, I thought, Okay, this is a, like a grid computing scale out thing, which I probably don't have a lot of use for. But then I was speaking with Matthew Rocklin about it, and it, it has a lot of applicability, even if you have not huge data, huge clusters, right. Like you can say, even on your local machine skill that's out across my cores, or, you know, allow me to work with more data than will fit in RAM on my laptop and stuff like that, right. It's a cool, yeah, yeah, it has like a whole different whole number of different ways of interacting with it, right? Like, there's that there's like, just make this thing go faster by parallelizing. it, there's all the data framing stuff. There's all that gray stuff for one dimensional data. So it's got a it's got a large API. Yeah, cool. And we're gonna touch on a couple of topics that are not all that unrelated to those things, here. And so yeah, speaking of data science, Brian, you want to kick us off? Sure. Um, yeah, the first thing I want to cover is an article called the practical sequel for data analysis. This is by Aki binita. So I, one of the things I like, liked about this is it was kind of talking about the first bit of the article was talking about basically that with, with data science, you've got pandas and in NumPy, and stuff, and you also, often you're dealing with a database, so that,

00:02:10 and SQL on the back end. So there's the first part of the article talks about how some things you can do both in pandas and in, in, in SQL, like SQL queries. It's faster in SQL. So there's a big chunk that's just talking about how that's faster. But then,

00:02:31 but then, you know, he also talks about just basically, there's, there's a lot of benefits to the flexibility and the comfortableness you can have with pandas, though. So trade offs as to where you know, you can, where you're going to push the push too far into SQL or having a split is good. But then he goes through and talks about a whole bunch of great examples of different things like pivot tables, and roll ups and, and choices and different things you can do with either pandas or SQL, and really what his recommendations are for whether it should be in in pandas or in in SQL query, and then how to do those queries. Because, I mean, really, the, the gist of the articles and, and this problem space is people are comfortable with pandas, but they don't really understand SQL queries. So this sort of a good cheat sheet for for, for how to do the queries is, I think, really kind of a cool thing. So yeah, I think it's really neat. And you have these problems, you know how to solve them in one or the other. And I think this compare and contrast is really valuable, right? Like, I know how to take the mean of some column in SQL, but I haven't done it in pandas yet. Let's go see how to do that. Or I'm really good at doing pivot tables in pandas, but boy always kind of avoided joins in SQL. They scared me and then how does that even translate? Right? I think that back and forth is really valuable. Yeah. Yep. And then it comes covers things that I don't even know what they are, like, aggregate expressions. Anyone know what that is? But apparently, that's, that's a thing that people do. I can help you out at aggregate stuff. Just kidding. Julie, what do you think of this? Yeah, no, it seems totally cool. Like, I agree that like the having the having an opinion isn't a sequel that like comparison is super helpful, like, SQL is always super scary to me. And I always end up like googling a bunch of stuff whenever I have to Mangle my SQL. But I know it's so fast. So it's cool to see a way to access that. Yeah, absolutely. This is a good one. Brian, I think a lot of people find it useful. I also want to just give a quick shout out for the past a little bit not too long ago, we caught we talked about efficient SQL on pandas with duck dB, where you actually do the SQL queries against pandas dataframes. So if you're finding that you're trying to do something, and maybe it would be better in SQL, but you don't want to say completely switch all your, your data over to a relational database. You just kind of want to stay in the panda side. But there's that one or two things like this is really cool. This sort of upgrade your data frame to execute SQL with the doctor.

00:05:00 query optimizer is also a kind of a nice intermediary there. Yeah, dask also does some good try not to make everything about dask. But that does some things that are kind of that kind of take some of the ideas from this article of like doing predicate pushdown of like, of pushing down some of the like filters into the read, because because it evaluates easily, it doesn't have to like, grab all the data greedily, upfront, it can like do that later. So you can get some of the benefits. That's cool. And I can also distribute the filter bit, I guess, at that point. Yeah. Nice. I want to talk about the usual suspects. So okay, that was that was a pretty good show, was that Quentin Tarantino or something like that? There's not actually about this. This comes to us from wrestlin port Portnoy. And thank you for sending this in mentioned an article that has this really interesting idea. How do you apply get blame when you encounter a Python traceback? So here's the scenario, your code crashes, and you either print out the trace back, or Python does it for you, because it's just crashed. And normally, it says, here's the value. Here's the line of code. Here's the file it's in. Here's the the next line in the call stack. Here's a line of code. It's in the ideas you can take, get blame, which is a command that says, show me who changed this line of code, or who wrote this line of code, at least touched it last on every single line of code. And I love this whole idea of like, Alright, who did this? And sometimes I'll come across code. I'm like, this is so crappy, like Who did this? Oh, wait, that's me. Okay, well, at least I know, in order to feel about it. But the idea is, what if your trace back on each line where it had an exception could also show who wrote that line of code? Cool.

00:06:43 Yeah, so let's check it out. It's pretty straightforward. This is an article by offer a core aren. And it basically uses two libraries that are themselves both really straightforward. So like, here's a straightforward example of a traceback like trying to pop something off of an empty list, just on this line, in the function pop some, you know, there's this line here and the call stack, and then the next line in this line, the call stack can eventually raise a value error, the empty range, can't pop nothing off, you know, something off of nothing, basically. But this doesn't show you any information about like, maybe who wrote that line. And who wrote this other line up here, right? So what they did is they took a couple of modules, trace back, and then line cache. And it turns out, when trace back shows you this trace back that line, it uses line cache to figure out okay, from this actual, I'm guessing bytecode, that it's going to run this C Python interpreter code, where does it like what line of file that has actually come from? Right? So here's the the insight or the thing, you can actually change what's in the cache. And because it's a cache, once it's figured out what the lines are, it's not going to read it again. So it's like, like a list for each line that you get back. And you can just change the value. So it said, Okay, well, here's like, return random. That's what the line of text was like, No, no, there's nothing to see here move along. If you make that and then you cause it to crash. Again, what comes out is, if you go a little bit further down normal code, normal code, or normal trace back normal trace back then it just instead of the line of code, it says nothing to see here, please move along.

00:08:22 All right, so what are you going to do with that now that you realize like, you can actually change what appears in the trace back, so you write a little regular expression, to go and execute, get blame on the various files, and then to re inject that back into line cache. And so what they do is they just put, if they know, the blame, they just put, you know, like 80 lines, 80 characters up to 80 characters of the line, and then edited on such and such and such date by such and such person. And here's the commit message, right. And so just basically showing not to get blamed when it crashes. Now, you get some really cool stuff like on this slide, it says, This is edited by, you know, many, many days ago by so and so in this git commit, and so on. And what's interesting, like this is already in itself useful, I think. But what's more interesting is other tools use this as well. So for example, if you use p you dB, which is a sort of visual debugger, kind of it's like a command line one that's visual in the sense of like, Emacs is visual, not like pi charm is visual. But it will actually pull up that data. So you can see they jumped into the P debugger. And it's actually showing all the skip blame attribution as well that they've added so yeah, pretty interesting. What do you think? Yeah, I think that was really cool. I mean, I always do give blame whenever I run into something that's weird with the hope that someone else will be able to explain it to me. Who knows about this, or who I talked to about breaking this? Right? Yeah, you could even put like PR numbers and stuff in here. Right? And that'd be pretty cool. Yeah. Yeah, that's super cool. Yeah, one of the things I like I don't really like that the name get blame, but it's there.

00:10:00 But I agree with Julia that the main thing I use it for isn't to try to figure out who broke it. But who to ask about this, this chunk of the code.

00:10:10 I agree. Because usually when you see something that's really confusing or weird, you're like, I know, they didn't just pick the hard way of doing this, because they didn't want to do the easy way. There's some thing that I don't fully understand some edge case. That's crazy here. I'm gonna go talk to that person. So yeah. Also the how long ago it was edited. So if there was something edited yesterday, that's probably the problem. Yeah, exactly. Like in this little screenshot here. Some of these are edited, like 1427 days ago, that's probably not the problem, maybe. But I feel like I have the opposite assumption. Like if something is from six years ago, and it's weird. I'm like, Well, probably things were different back then. And, yeah, yeah. It's no longer applicable to the new data and new research. Yeah, yeah. Oh, that'd be an interesting thing. Also, is to have like a tool that would tell you if something's like over 1000 days old or something like that. You probably should go refactor it to make sure somebody understands that code. Yeah, yeah, for sure. All right, jumping back to the first item really quick. And the live stream Alexander out there. Hey, Alexander says, I wonder if graph databases with Gremlin queries could be more suitable for data science. SQL joins are way harder. Your graph databases are pretty interesting. If you're trying to understand the relationships that may well be better. I don't know, if you got any thoughts on this. I don't know anything around graph databases. And my league.

00:11:31 I didn't have a desire to understand graph databases until I found out that there were Gremlin queries. Now I think, well, Brian, they don't start out as Gremlin queries. They're mogwai inserts. And then if you insert them after midnight, then they become a gremlin query. I mean, come on. We all know how it goes. You definitely don't want to get on what?

00:11:52 Oh, that's an old Show. I'm not sure if everyone's gonna get that reference. But yeah, that was I love that show. Okay. Anyway, let's move on to the next one. The next one, is you Julia. Yeah, so I wanted to highlight Fs spec. So file system spec for people who can't hear letters very well.

00:12:09 So this is the basis for s3, fs fs.

00:12:15 I'm not getting the letters, right. But there's, there's one for GCP. There's one for s3. And basically, it's a file system storage interface are like the basis for a file system.

00:12:28 And so you can do things like you could open just files as you can read, just take a path and open it as a as a as a file object in Python and read it with all the normal like READ WRITE operations.

00:12:42 But from anywhere, so there's all these different ones, for for s3 for GCS. And for for like, even for HTTP, and just basically anything you've you can imagine, anywhere, you can imagine a file being either there's already been one of these written,

00:13:04 it's kind of like a, it's an interface. And then you write different packages on top of it, that are like drivers or some, they have some name for it.

00:13:12 And it allows you to treat the file system as like this interchangeable building block. So you don't get you don't end up writing like Boto three code or something that's like very specific to a specific cloud storage, you write I guess, more general code. And then there's really useful for like, auto free data sets that are hosted on different clouds. But like, though, sometimes you have one cloud, and sometimes we had another but like, basically, it's the same data.

00:13:39 Or if you're at a company, and you want to like switch clouds, it just makes that whole thing. So much easier.

00:13:46 It looks really, really useful, especially for avoiding cloud lock in. Yeah, yeah. And you can always great like, you can always write your own one, if something else pops up, you can write your own implementation. Right. So there's an example here talking about using a file system in the docs that says something to the effect of, well, you want to open up a CSV and feed it off the pandas read CSV. So normally, you would say open CSV file, and then you just say pandas read CSV and give it the File Stream. But what if that's on the internet? What if that's on s3 with authentication? What's that? What if that's, you know, somewhere else, right? And so with this one, you can just say Fs filesystem, spec open, here's a URL, and now that's a stream right? Or that could be a here's an s3 location s3 bucket go get that right. Yeah, yeah. So instead of passing the path directly into the read function, you pass in the file object. And it's, it's, it's really powerful. Like it seems, I guess, I think that we shouldn't need but um, files, like the file locations can get so crazy so quickly. And this just really helps simplify and like make it so you don't have to think about this stuff, which I think is what most people want is what I want. Yeah, for sure.

00:15:00 So like there's a local file system option, but then you could also have an FTP file system. Or you could have something else. Right. All sorts of different options. Yeah.

00:15:10 Yeah. Okay. That's cool. Brian, please. Thank you have any applicability for you? Oh, yeah, definitely I, it's, it's a, that's a great abstraction layer to put in place to just have it reading as if it was a file and have it moved. And also, it helps you to develop tools locally, and then be able to deploy them into a larger space. So it's cool. Yeah, for sure. One of the things that always makes me a little hesitant when I hear people say things like, we're cloud native, like, my, my app is cloud native. That's always code word for me, like, I will never be able to run my app, unless I'm connected to the internet. It's like, it depends on all these services together. And they, there's no way I can recreate that locally. But something like this could allow you to say, well, we're gonna have a local file system version. But then when we go to production, we'll switch to s3 or you don't pick it, pick something. I've always wanted to make it either a T shirt or sticker boat that says not a cloud native, just visiting.

00:16:06 Nice. I also think, Brian, there might be testing opportunities here. Yes, definitely give it a test file system. That'd be cool. Yeah. And like Julia said, swapping things out to just have to have your have your logic not have to care where it's coming from. But But I

00:16:22 guess it would it makes me you'd have to make sure all of the other interfaces, the different storage systems really are equal. But I guess, check, try that out yourself. Yeah, there's like kind of a bucket, right, that looks kind of like a dick today, you can pass which is like storage options. So I think that can that might get a little wonky, depending on what the different backends need. But the general principles are the same. And it also I should have said this originally, but also guys, the FS spec itself can contain logic to do things that are general to all the different libraries like caching and things like that. All the different interesting, like, you could put a caching layer on top of arbitrary things like s3. Yeah, Google Storage and Azure buckets or blob storage. Yeah, yeah. Maybe even save money on bandwidth there. If you can do some caching. Yeah, you can do it right. Yeah, super, super neat. Brian, you're gonna tell us about how to slim down our Docker containers. But before we do, I want to tell people about our sponsor for this episode, brought to you by century. So how would you like to remove a little stress from your life, in addition to just abstracting your file system, maybe tracking down some errors? So do you worry that users may be having difficulties or encountering errors with your app right now? And would you even know it until they send that support email? How much better would it be if you got the error, or performance details sent right away, and with all the call stack, maybe we'll get blame in there. The local variables, the active user, who was logged in, while this happened, all that kind of stuff. So with century, it's not only possible, it's actually really simple. I've used this on century, I've used Sentry on our websites before. So it's on Python bytes, talk Python training, all those different sites. And I've actually had someone encounter an error trying to buy a course over on top by then training, I got the sentry notification, I said, Oh, geez, I can't believe this problem, crept in here. And I fixed it really quick, and started to roll out the fix and actually got an email. They said, Hey, we're having this problem by and of course, I know, I've almost got it fixed. Just give me give me a moment and try again. And they were just like, what, that doesn't make sense. So they were very surprised. So surprise, and delight your users create your central account at Python bytes, FM slash century. And when you sign up, there's a little got a promo code, make sure that you put Python bytes, all one word, all caps with the why in there, and you'll get two free months, plus a bunch of extra features and so on. So also, it really lets them know that you came from us rather than just somewhere else. And that helps support the show a lot. So Python bytes.fm, slash century and promo code Python bytes. Awesome. Thanks for supporting the show century. And Brian, let's talk Docker. Yeah, let's talk Docker. I mean, I'm starting to use Docker more and more, and I liked the experience. But I was interested when this article came up. So it was in June, I saw this article called the the need for slimmer containers. And this is a from somebody, Ivan, Ivan, I'm not going to try his last name. I haven't something. But anyway, it's an interesting discussion. And the idea around the just the original post was that there's now there's now a Docker scan that you can use. So you can you can use darker scan to scan for vulnerabilities in your Docker containers. And this, I haven't thought, Oh, look at some of the standard Python containers that are available. Right? Theoretically, some of the things that are nice is I can just go and say Docker, or in my Docker container and say from Python, colon three, nine, and I don't have to think about how do I install Python? How do I keep it up to date, you know, make sure that PIP is there and that I'll be able and you know, pip install stuff that needs to do build things it has all that stuff will be there, right? So it's

00:20:00 Seems like of course, this is what you want. Yeah, well, and also, just that's kind of the one of the neat things about Docker is I can just say, I have the standard parts. Now I just want to put my custom stuff on top of it. And, and that's great. So what did he find? So he used, so the darker scan apparently uses a third party tool called snake sny k container. And we've covered snake before, not the container version, but we covered snake in Episode 227. But so it's looking for vulnerabilities. And that's a good thing. But he found them in everything. And he found him in all of the the standard Python ones except for Alpine, I guess. And so he didn't really know what to make of it really is just he was just sort of reporting his results, that maybe Alpine is the only one with with with few vulnerabilities. But then, but then this, this went out on Hacker News, and there was a big discussion around it. So he updated the updated the article, which I appreciate with some of the feedback that he got. And so some of the feedback was that these vulnerability checkers sometimes give you false.

00:21:13 And I don't really have enough experience to know what that I know what that means. But I don't have enough experience to know if these really are false positives or their actual vulnerabilities or not. The other thing that was that, that maybe some people suggested that these, these standard ones really aren't updated very much. So I don't really know much about that either. And if they're not, that's kind of a bummer, because I think I think people are relying on them. So I actually just kind of am left with a little bit of a confusion as to what to do. The one of the I want to also mention that the Alpine is currently in his original article, he says Alpine is pretty good for vulnerabilities. But then his follow up says it doesn't. Well, there's a lot of applications that can't run on Alpine because of some issues or another. So anyway, I'm not sure what to make of it. So I was hoping waffle might give us some insight. I did some thinking about this this morning. And in fact, I recently spoke a lot about this over on talk Python. So I had Itamar on the show, and we talked about best practices for Docker packaging. And we talked a lot about both security and package size. So I can try to relay a couple of things from that. So we've got our official image over here, our Python official image, there's actually a bunch of options. As you can see, there's a few

00:22:38 310, beta two Buster or the 310 RC buster, that sounds bad, but I think it's actually good. And I'm just kidding, I know what it is. So these are by default based on Debian and Buster is the latest version of Debian. So you can do a buster, which is like full Debian with 310. Or you can do it 310, slim buster, which is like a slimmed down version of Debian Buster that supports Python three. Okay, so there's a lot going on. Here in terms of the options, one of so the article talks about how Alpine had the fewest security vulnerabilities. And actually, it's so the Python latest if you run this neat package scanner thingy on it, it says there's 364 vulnerabilities. If you just do Python, latest three, nine, and 353. After you run apt update apt upgrade. So have you tried to get the container to update itself, there's still 353 in the that one, I don't use that I use a boon to so I use the aboon two latest and bear version of that one had 31 vulnerabilities. But then if I either install Python through apt or build it through source and put in the necessary foundational bits like build a Central's and stuff to build Python, it goes up to 35 total problems where 28 of them are low seven or medium, nothing major. One thing I thought was weird was I actually ran another step where I said, Okay, let's uninstalled those intermediate tools like gcc and W get and stuff like that, that I needed to get stuff on the machine, but I'm not going to use again. And I took them away. And almost all those warnings were about those tools that I had apt uninstalled. So I don't know why sneak is still showing them. Because if I go into the container and type w get it says, nope, this thing is not installed. Sorry. But it still says the warning is that w get has a vulnerability in it for example, right? So there's like, there's like this over reporting for sure. But I mean, the difference between 28 and 350 is not trivial. Right? Right. So like running apt install Python three type of thing is not you know, it's probably worth it. For example,

00:24:46 when I switched from Python, three, nine to Python three, nine slim buster, it went from 350 to 69. So that's a lot better, right?

00:24:57 It's still not as good as a boon to but it's a lot better.

00:25:00 The steel twice. It sounds better, but it could be like 359 low problems in that sense. Yeah. And critical ones. It totally could it totally could.

00:25:13 If the reporting it if the if we can't trust snake necessarily, then like maybe, you know, if you can't trust your reporting system then like maybe that maybe none of this is means anything, right? Yeah. Yeah, I think one of the things that article originally started out to address was, if you have fewer subsystems, there's no chance the missing subsystem could get hacked, because it's not there. Right. So if there's a vulnerability in SSH, but you literally don't install SSH, who cares. Whereas if you and you just take the full distribution, you may potentially get affected by something you dragged along, and then it went down this rabbit hole of like, Well, let me scan it, and so on. So I want to add one more thing like Alpine did result in the best outcome from the scanner. But there's a lot of issues with Alpine and Python. So for example, there's this Pep here 656. That right now, if I tried to pip install something on Alpine, so especially in the data science world, where things are large, and the compiling takes a lot of steps and so on, the wheels that are built for Linux are built for G lib. C. Let me hold on. I'll look over here I wrote it down. So I know now I didn't write down sorry. There's like I think it's g lib or GC lib, which is the C runtime on like a boon to and Debian. But there's one m USL muscle on Alpine. And the wheels are not built for muscle. They're built for G GC lib. So you can't pip install that you got to download everything and then compile it. And it's like compiling Matlock, matplotlib. And Jupiter from scratch can take a really long time versus just downloading the wheel. And it takes up a lot of space. And there's, there's a bunch of issues and things around that that like make it slightly not Python friendly. That's why there's this pep, pep 656 to allow wheels to be tagged as supporting muscle not GC. As that morning, you want to Brian, are you good is that the takeaway that I'm getting is probably not panic on some of these, but maybe at least pay attention to them. And it is good, like you said to, to remove tools out of your Docker images that you're not using. If you're not using w get in your application, take it off, things like that. Yeah, exactly. I think Julie's point was great, right? It's if you it might be a false positive, but at the same time, if you're not going to use it again, because Docker a lot of times you pip install all your stuff. And then it's kind of ready to run, but you're not going to go and pip install something, again, you're going to do a new Docker build from scratch, right, like one of the final lines could be removed, remove all those intermediate things that could have problems and make it larger and whatnot. Yeah, I thought.

00:27:58 So I've only thought about this from like, package from like image size, right? Like that. Yeah, you want some more images, just because it takes forever to get them around. But um, it's interesting to think about from the vulnerability perspective. And I've always seen it done as you do whatever installation you need. And then you do all these like cleaning steps. But what you said Michael, about like, not ever putting certain things on your image was interesting. I haven't heard that before. Yeah, thanks. I also had Peter McKee from who works at Docker on talk Python a little while, like six months ago or something. And he talks about having these multi step builds something to the effect of doesn't make as much sense with Python, I'll try to put it together. But like, imagine you're building a go library, you could put the go runtime and build tools on a container, build your thing, but the thing you get from go is an actual binary, that's all self contained. You could throw that container away and just copy the output of that into your actual container and never even put all those tools on the actual system that goes to production within Python, that might look something like maybe using PACs to package up all the stuff inside of a virtual environment. And long as Python, the runtime is there, then you can like packs run on your other machine. But you could potentially not even ever install those, which might be good. Yeah, that makes sense. Yeah, there's a lot a lot there that I'd sort of beyond my comfort level. But that's, that's what I thought as I looked at this right. Well, thanks for taking a look. There. You bet. All right. We'd like to talk about gooeys on the show every now and then. And so, and we want to talk about pandas and data frames and data science and all that. So let's put those together. There's this project over here called pandas gooey, and the documentation is sparse. Let's say it's pretty easy. There's a couple of examples are to go I could come down here and I could like do my pandas stuff or create a data frame and I could just import show from the pandas Giri and within my notebook, it will pop open a separate window that then allows me to cruise around and check it out. So it does, you know, you can print out the data frame in

00:30:00 I'm in a notebook, and you'll get kind of a static Excel grid looking thing. And that's nice. But with this, you get a interactive one that lets you sort and select, you can actually copy and paste chunks out of there as if it was Excel and then paste it in other places. It also has a plotting library with like pictures. So I'm gonna go click on the bar graph picture. And then there's, there's a list of all the columns and the things that the bar graph needs. And you can drag and drop. This column is the x axis and this column is the y axis. And I want to group by color and have you know, group by a color it by some other aspect of the data, like groupings and multiple charts, or multiple lines or plots on a chart, all sorts of cool stuff like that. There's a statistics section, there's you can export, import and export, I guess, import CSV files with drag and drop, and there's also search that you can do. So it's a pretty neat, quick way to explore endless.

00:30:55 It's a neat idea, like when you when you first encounter data frame, like you really want to, you really want to just be able to, like look at it without any assumptions. And there's a lot of stuff that like kind of goes towards that with like the dot plot, API and pandas and making that making really accessible to make plots really quickly. But this is like kind of like that step beyond that right of just visualizing it immediately. Yeah, like one thing you get when you view the data frame, as you know, like I said, it looks kind of just like printing df in or just typing df in the notebook. But then on the right, you can see I want to see the filters, and you could type in these filter expressions, these query expressions, and then turn them all like pile them on, you can have little checkboxes to like, optionally turn them off, but not delete them. And then of course, you can sort within there like that. And the graphing, I think the support for the graphing part is really, really helpful. So the fact that you can just go click and say, Oh, I want a box plot, and then the box plot needs these things, you can just drag and drop from the column a year from your data frame definition over and it just live updates. Yeah, I think that really like lets people visualize the data in the way that they want to sometimes rather than like the way they already know how and matplotlib, which I think is what people end up doing, at least for exploratory stuff. Yeah, exactly. You can real quickly switch between a bar a box, a scatterplot, back and forth without having to actually be familiar with how those works. Can you tell if there's a way to export the filter? So is there any? There is I don't think so. At least in the YouTube explainer video, there were some comments like, you know, it'd be awesome. export this as code from here so that I can just turn it back into Python. I didn't see anything like that. But yeah, sometimes gooeys, or I go to weird for me, because of that, you know, like, you end up in this gooey world. And it's not UK, you can't reproduce anything. And I clicked out a whole bunch of stuff, and then it looked great, but don't touch it. Yeah. I can't do it again.

00:33:00 Okay, so to be fair, it is a fairly quick way to, to look at the data and know what you maybe maybe you can't produce that exact plot again, but you know, what the data looks like. And you can use a different plotting mechanism to do that. Yeah. And the visual is pretty clear. Like, okay, well, x is assigned to speed. And we know it's a histogram. And so you could pretty quickly, you know, with some googling and stack overflow and go, alright, how do I matplotlib a histogram and get that going, you know, a huge time saver. Yeah, but so some some sort of export of like, Okay, give me the code to make this plot in my own code. That would be great. Yeah, absolutely. Absolutely. All right, on to the next, but before we get there, I do want to call out just a shout out by piling but Fs speck is sweet, good mentioned. Yeah, I like it as well. Cool. All right. X ray, X ray.

00:33:52 Okay. Um, so x ray is, it's my favorite library. Um, it's a it's like a pandas is a pandas like API.

00:34:02 But it's for n dimensional data. So if you have like, a lot of times people talk about in like geospatial data, where there's lat long time, and others, but also for an image data where there's maybe a bunch of different bands from like satellite imagery, or other disciplines where you just have label data that's not tabular. So the axes like mean something, but there's not just one or two of them, then x ray is like great for that because it lets you do things like you can select a certain subset of time or a certain subset of whatever your dimension is. And you can also aggregate across different dimensions. And you can use the labels directly. So if you don't have a tool like that, I see people doing this a lot with like machine learning workflows, where they'll, they'll be, they'll have like separate like a list of all their they'll have like a list of all their labels and the

00:35:00 They'll have their data and they'll do some manipulation. And they'll try to like reattach them at the end. And it's just, it just turns into a mess. And it's actually just like takes care of that all for you. It's pretty great. And I think that it has applications that have not been fully realized yet. And it's starting to take off in other spaces. But it really comes from this geospatial world. But I think it could be useful for all sorts of people, right? Because geospatial sometimes you have three dimensions, not just two. Yeah, you almost always have three, right?

00:35:33 Right. No, the documentation looks great to the documentation is has like gets Getting Started guides and, and tutorials and videos and galleries and stuff. So definitely check out the documentation. Yeah, I think it got a major, it seems like I looked at it for this too. And it seems like it got a major facelift. So it looks really nice. It also has like potty is supposed to dotplot API, or some some different version of it. That's like the pandas version. But you can plot in different three dimensions or aggregate and then plot. That's as like a really nice way to get the visuals quickly. And then the last thing I wanted to say about is that it's normally backed by NumPy arrays, but it can also be backed by dask arrays or sparse arrays or all sorts of different arrays natively. So it's a it's a really cool, it's another one is like building block things where you can have X rays, and you're labeling and you're indexing and all the nice stuff. And then down inside, it can be NumPy or pupae or Autodesk. How interesting. So it's it can do that juggling and piecing back together that other people are manually doing. And you just have this simple API. And if it has to do that, it'll figure it out. Yeah, yeah. That's pretty cool. Nice. And you talked about cutie pie. And dask? Like, those are some pretty interesting backends for this. Yeah, yeah. Um, the dask. One is, I said q pi. And I'm wondering if maybe it's just like dask. And then q pi. So don't quote me on that.

00:37:07 But yeah, the das one is, is like really integrated with X ray code. So you do like they do just do some special things to make it so that works with parallelizing things, but but from the user experience, it's the same. Yeah, fantastic. And then also noticed, it requires Python three, seven. Really nice to see tools sort of keeping up with the latest Not, not not really old stuff. Well, hopefully it's three, seven and above. Well, yeah, it Yeah.

00:37:33 Well, I mean, I ran into a library, it was an internal thing that that was only three, seven. So I tried it on I'm like, I assumed or above and tried it on three, nine and it like fell over. Like what's going on? It was only three seven. That's weird.

00:37:49 That is weird. That'd be interesting to think about what special features of three, seven there, depending on that broken? Three, eight. Yeah, I said I was thinking like, how do you do that? Without just checking for equal equal three, seven on version? Yeah. So anyway. Yeah. All right. Well, that's it for our six main topics. Brian, you got anything else want to throw out there quickly? Um, yeah, actually. So I, I

00:38:12 didn't have this up. But there was a

00:38:15 on Twitter somebody, like, reacted to me with an emoji. And I didn't, didn't know what they meant. So I looked up, let me let me pop this up. This emoji pedia in it, it was helpful. And you can just you just copy and paste the emoji that somebody uses in there. And it tells you what it means. And the you know, kind of not just what it supposed to mean, but also what people are using it for. Anyway, for somebody that's sort of an old old guy that is out of touch. Sometimes this was helpful.

00:38:50 Anyway, yeah. Sometimes it's like a heart. We know what a heart means. Right? But, you know, like, hands together, it's not necessarily that that's like a thank you sort of bow type of thing. I mean, there's certain ones where you're like, what does that mean? It was like a hands together with like, arrows coming out of the top. And I'm like, I don't know what this is. But apparently, it's just raising hands. Like, like you're saying Hooray for somebody. Okay, that's nice. So okay, it's good. I used to manage a PDA all the time, but I think I use it in the opposite way. I use it to get an emoji to like, put somewhere because I don't have like an emoji keyboard or whatever. Oh, yeah, that would be good too. Um, the other thing I wanted to bring up is I hopefully have some cool news to share tomorrow about the PI test book and the news will show up on a revamped pi test book site. So if you go to pi test book calm, you get redirected to this

00:39:43 Python test comm page where I'll talk about the second edition so hopefully I'll see new news about the second edition coming out tomorrow. And I hear this is a static site magic Yeah, yeah static site and I totally and it goes dark and light this article, but I told

00:40:00 stole from project. So project is as the same. He's got a really nice site. So it's a bunch of great, great, it looked great. And I'm like that that'll work. I'll just do what he's doing. So that's what I did. Yeah. Okay, cool. I think we have exactly the same stack for Saturn cloud site now.

00:40:18 That's cool. Awesome. How about you, Julie, anything else want to give a shout out to? Um, well, I've been really into entry points recently. Um, just like, the concept of them is very cool as Python packages, you can give them almost like COI command types of entry points. Yeah. But the thing that I think it's really cool is like, like, a matplotlib. This is example that that made me first realize about entry points is matplotlib has this dot plot. I think I mentioned this three times now. But you can swap out the back end. So you don't have to have matplotlib. You can use other backends. And all the logic for that is in the other visualization libraries themselves, not in pandas.

00:40:59 So it's just like, you can swap out other things. It's not just for sea lice. Yes. Okay. Yeah, honey. Alright. Yeah, I learned about entry points a year, year and a half ago. And ever since I'm, oh, yeah, this is awesome. I can now create these little commands that'll be part of just my shell. I love it. Yeah. The other thing I wanted to say was GitHub ci is really cool. I think that standalone, but yes, I've been using it. I'm sure people know the Git COI. But what's the story? The GitHub ci? Oh, well, the GitHub ci is makes it. So if you have ever tried to check out a branch on someone else's fork, like if you want to, like evaluate a PR? Yeah, exactly. Yeah, that is the situation where the GitHub seal is really great. Because you can just do like gh checkout PR, or gh, PR Checkout, whatever the number is, and that you're just on their branch then. And if you get push, if you have push access to the branch of your maintainer, and they've allowed it, you can just push directly, and you don't I mean, I was always looking at that, like sequence of commands before. Like, I know, people have like Git aliases and stuff. But um, that Yeah, I'd really recommend checking out if you do a lot of GitHub stuff. Okay, awesome. Yeah, that's great advice. Yeah, I often want to like check out some sort of pull requests. I want to be able to, like, play with it, run their code, and yeah, and it's the best. Yeah. Awesome. All right, I got a couple things to add. By the way. First of all, just that first practical sequel analysis that you talked about, it also is a similar, a similar theme that you were talking about Brian, one of the things I thought was cool, though, as you scroll through, it has a progress bar for reading at the top. And that just made me so happy. I don't know why. That was. That was really neat. Alright, but I have a bunch of here all about it sort of thing. So really quick. Python. beats us got the sent? Yep. Okay. live update. Python 310. Beta two is out if people want to check that out. And you can go download that. It also highlights all the major features like the pipe operator for writing unions and type specifications, and a bunch of other stuff that people might care about. pattern matching is probably a big one. Yeah, go to the completely different. Is that now for something completely different? I love that part. So right about the files.

00:43:13 Yeah. Oh, interesting. ehrenfest paradox concerns the rotation of a rigid disc in the theory of relativity. It's original 1909 formulation presented by Okay, that is unexpected, but very cool. And completely different than irrelevant. Yeah. Yeah. Awesome. Okay. So takeaway 310. Beta two is out. People can check that out. There's also some security patches for Django, so be sure to check that out. One thing that surprised me is the Microsoft install Python from the Windows Store is already like has a 310 beta store install. So okay, that's pretty cool that they're keeping that up to date. It's rated E for everyone. Yeah, even even kids can pip install. Awesome. So Fredrik banks, Bankston sent a message in response to our last show where we talked about the method overloading by type, like if it takes an enter a string it calls different functions. It's also pointed us towards this multi method, other library that is similar so people can check that out. That's cool. Speaking of the GitHub stuff, I've been starting to use PI charm with a 21. Two, early access version, Early Access Program version one, and it's been working fine. So people want to try out the new features. There's a bunch of cool stuff. You have support for Python 310 and new stuff for pi test. I don't remember if this came in here, but one thing that I did learn about that recently that's in there, that's super cool is they have in PI charm. If you log in and ihrm into your GitHub account, there's a pull request section and you can just click it and it'll do those same steps that Julia is talking about, like right there in Python and just go I want to try that that PR before I accept it and just go, you can even have comments. You see the conversation inside there and everything is cool.

00:45:00 Never go to the GitHub again. Exactly. And just forget how to use it, basically. Alright. That's it. That's all the items I got. So yeah, I've got other stuff that's just hanging around from before. Good. All right, well, you want to close it out with a joke. Yeah. Couple of jokes. Always. Alright. So over up jokes, comm slash programmer das jokes, you'll find many bad jokes. Some even that are not very appropriate or whatever. But there's a few that are funny. So I pulled out three here. I'll do the first one. Brian in just a second Julie do the third I guess if you're up for it. Okay. So this one we should have saved for you six months from now. But I asked the programmer what her new year's resolution would be. She answered 1920 by 1080.

00:45:43 That's awesome.

00:45:45 All you got to do the next one.

00:45:49 How does a programmer confuse a math mathematician? I don't know how saying that x equals x plus one.

00:45:59 Julia, okay. Um, why do Python programmers have low self esteem? They're constantly comparing yourself to other.

00:46:09 Also bad. Probably the worst. Sorry, we gave you that one. Okay. I saw this. I saw the one that Brian did. And I was like, oh, it should be x plus equals one. And I was like, no, that ruins a joke.

00:46:22 Exactly. Yeah.

00:46:25 Yeah, actually often do the slow way or the

00:46:31 x equals x plus one. Just to make it more obvious to people reading something. Yeah, yeah. No, I agree. Yeah. At least it's not c++ with x plus plus x.

00:46:43 No, no. We should have that. I'm okay with x plus plus, but not that also plus plus x. The pre flight. Yeah, the pre increment the weird. Yes, exactly, exactly. But I can go for it. x plus plus. Come on. All right. Well, Julia, thanks for joining us this week. And Brian. Thanks as always. It was a pleasure. Thanks, Julie. Yeah.

00:47:05 Bye bye.

