00:00:00 Hello, and welcome to Python bytes where we deliver Python news headlines directly to your earbuds. This is Episode 242. Or to July 14 2021. I'm Michael Kennedy. And I'm Brian aka. Hi, and I'm Al Swaggart. Hey, welcome. Welcome. Before we get to introduction with you just want to say this is brought to you by our courses over talk, Python training and Brian's book. But first, let's just get about you out and tell people who you are, if they don't know, hey, I'm Elle swaggered. I'm mostly known as the author of automate the boring stuff with Python and a bunch of other Python and programming books for beginners. So all my books are released under a Creative Commons license. So it's free to download and share them. You can get them at invent with python.com. Nice. Yeah, yeah. Fantastic. I would say the automate the boring stuff has certainly been well received. Yeah.

00:00:53 For sure, Brian, I'm gonna start it or what? Yeah, I'll just get started. So no, suggest, I saw a tweet by Jeff triplet that mentioned just and as a replacement for make, so I needed to check it out. So it's like makes people who don't know is a thing that you can type, basically type make. And then it automates a bunch of commands. Like, if you got a seriously complicated build link process, it could be embedded into a make file, and then you just type make, and that happens. Right? Right. Right. And it's, I don't, I don't know what the huge history of make really is. But I used it a long time, I've been using it for decades for one of the things that does well is convert, like, if you've got a call your dot c files and convert about dot o files, and then combine your dot o files, all the build process for the C toolchain. But you can do it for you can really do it with any language, but people have like abused it. And so have I even Python projects often use make files.

00:01:53 Because make is often around on Unix like environments in so having makefile around, you can use it just sort of to automate some of your common tasks, like make release or something, to push your to do all the commands you need to do to do a new release of a project or something. But there's problems with it. And so just is a is a replacement for it. And it's, um, it's it did, it's written in rust, so it's pretty fast and clean. But actually, I know I don't know if it's clean, I haven't looked at the source code. But it's really easy to use. And it's not easy. It's got to be better.

00:02:30 Like WAV files. So yeah, I went ahead and installed it both on a Mac and Windows today to try it out. One of the things I really love about it is it's not the main part of it is the trade automates commands, it's not about you can build like that. You can use it to build things and have recipes to make all your dot c files into dot o files if you want. But the real power is to use it in the way we've been abusing make before it because you can do some cool things like one of the problems with make always has been the the route, the rules have to be on the or the recipes have to be defined on the left of the left column, leftmost column. And then you have to, like have a tab for the commands. Well, I mean, often I have my editor setup except for MC files to replace tabs with spaces just works just fine with with spaces, I love that. And also you can you can pass commands, past arguments to commands command line, stuff like that. It's cool. That's super cool. One of the neat things, I don't know where it isn't in the documentation here, oh, you can use arbitrary languages. You can even do like Python command within the just file. So it's a that's cool. You can do some neat things. Also, people listening, you basically declare the languages you want to use. And then you can implement code code like print or console dot log for JavaScript or whatever. Right? This actually seems like a bad example because it's actually listing the the recipe name as the language name. And you don't have to do that. So this Python here could just be foo or something. Oh, I see. So yeah, the thing that's important is shibang. shibang tells tells just which language to use. So this is pretty neat. I've started using it right away, and I think I'm gonna keep using it. It's great. One thing that I got into this, that's interesting, scroll down to where it has like the how to get it. You'll see like a whole bunch of links if you go down that page, more a little more keep going distillation. Yeah, I think so. There's a section Oh, nah, yeah, there you go. There's a bunch of it shows you all these different package managers that will give it to you. So if you want to get it from rust, you can use cargo or a Mac OS there's homebrew and Mac ports. You want it on a Windows they interesting Lee recommend scoop which I've never used. I've only chocolaty so I don't know. I feel like there's like

00:05:00 Ice cream theme just happened for the windows world. But yeah, those are interesting. I was gonna be snarky and say do you require make to install just?

00:05:10 Yeah, so I got no problem using brew install for on my Mac, but I'm not going to install scoop for Windows. I don't have any other need for it. So there is pre built binaries. So I just use the pre built binary for Windows. That worked fine. Yeah, this looks, this looks really great, because of my experience with make has been to just run the basic make command to build something. And if it works, that's great. And if it doesn't, I have no idea what to do. Because I feel like my knowledge of make is sort of like my knowledge of CSS where it's just been built up from little bits of knowledge over the years, and I've never formally sat down and read through all the documentation, 100% JIT learning, like just the time that you need it. Yeah, exactly. Yeah, like I actually I've never really understood why phony targets were needed. And this this discussion in the readme of this of just actually talks about why phony is needed in the first place for make files and why you don't need them are just so kind of interesting. Yeah, very cool. Very cool. For move on to the next item. couple of comments for out there, Teddy. Hey Teddy in the livestream says love the automate the boring stuff that we learned Python, Dean's has always recommended to get started. Great fan. So yeah, that's pretty cool. Awesome. Hey, thanks. I'm, I always love hearing that. But all right, I love to hear from our fans of the show. And so Roman writes, who work on beanie, the belief identic based model query for ODM for MongoDB recommended something else. This time, we already covered Beany, something called strong typing. So this is a decorator this from Felix to C to decorator, which checks whether a function is called with the correct arguments. So if somebody goes and puts type annotations on their code, that's cool. The the editors, like Python will say, you're doing it wrong when you're doing it wrong, or they'll give you autocomplete and information on the arguments and so on. But you know, Python, that's like a hint, right? I'll type hints often, because it's a hint, it is not a requirement. And so if you want to make sure that certain type types match up, basically, you can use this decorator. And there's not a lot to this one. But you go over to the read the docs, there's a stay strong little character there. But the idea is, if you had this thing that was like a multiplier took an A and a B, and you could pass other stuff. But if you passed, like if you could pass like three or four to multiply, but if you pass like hello world, it's just going to try string time string, which there's probably a cool whatt that we could get there. But that's not what happens in Python, we get a typer. Right? If you do a string times a number, you get a pretty interesting outcome. This is something of a whatt. If you're like, Hello, times four, you get Hello, hello, hello, hello four times, which has always been weird when I learned you can multiply strings, it kind of freaked me out, but I've come to find it useful. So what do people do? while they're like, well, this won't stand, we need to check the type. So we're gonna say, if is instance, the first parameter and an int, and is instance, the second one, we can do it otherwise, we're going to report an error. Don't do that. Instead, what you can do is you can use this match typing decorator and you can just say, at match typing. And it's going to take the arguments based on the type hints and validate them. So if you pass in the right one, right, it'll give you an answer. If you pass in something that does not match the type annotations described, it'll say it'll raise a type mismatch exception. And this can be nested down. So for example, one of the examples is it takes a list. And let's see things a list, which is a union of strings, intz, and tuples. So if you give it a list that has either a string int or a tuple, mixed heterogeneously into the arguments, it'll take that just fine. But if you give it some other type, like a list that happens to contain one of the elements is the date time, it'll give you this exception. So it's not just Oh, it took a list. It has, you know, like the transitive sort of property of analyzing the types is finally there. So pretty interesting. What do you think? Yeah, so the difference between this and something like my PI is that this operates at runtime. Right? Right. Exactly. Because you could do all the my PI stuff you want and if people don't run it, well, you're not going to get any information out of it. Right? Yeah, that was something that I was really surprised to learn when I first learned type hinting was that really pythons type hints don't don't really affect your runtime code at all. It's it's just set up for a static source code checkers like my pi. So it doesn't turn Python magically into a static

00:10:00 typed language, it's it's just for these static source tools. Yeah, exactly. That's my bias. And this is kind of the other side of that, right? This is the right. Yeah. So maybe you would use this in the case where you're building a package or library. And it's, you've done everything correctly, but someone else is consuming it potentially incorrectly. And you can't control whether the world uses my PI or not. Right? Yeah, you just wrote a library. And so you could use this on, say, the boundary of your library, not everywhere, just on the boundary, to make sure the stuff that goes in and out is valid. And this would be really helpful for stuff that I work on. Because usually, I'm just sort of writing code ad hoc that sort of does this runtime checking, but it's, it's really nice. I could just throw in a function decorator and just add that capability. And and that's all I have to do. Yeah, absolutely. And yeah, yeah, this is great. Let's, uh, clearly this is adding code. Your code, right? So yeah, I'm curious about the performance. Yeah. So as Teddy, he out there in livestream asked, you know, if there's any potential loss performance, this is running at runtime, I'm gonna say, obviously, I'm certain there is loss per Yes, yeah. Unfortunately, in Python, calling a function is a relatively slow operation. And doing a decorator is effectively calling a function. So it's got to be slower. That's why I would say put it just on the boundaries, you know, something like that. But I mean, the alternative is, if you actually want to do these tests, if you actually want to do that validation, it's an if statement, and multiple is instance of all over the place. Right. So if you've got validation anyway, you're already calling. It's just not on the outside. It's on the inside. Right. So good question. I don't know. Yeah. Another question. from Ben Lindsey. Do you know how this compares with by the antics validate arguments? decorator? I don't know. But I'm a big fan of pedantic and the validate arguments. decorator is exactly the same type of thing that we're talking about. So for example, like, you just put the ad validate arguments. The thing is that I did notice somewhere that yeah, here it is, like this validate arguments, decorator is in beta for whatever that means. It won't be concrete until v2 identic. But that may well be more, more concrete and more formalized than this one, right. Although this is more standalone, right? You don't necessarily, it feels like a little tiny thing that you just plug in on there. pedantic is doing a lot. But I'm a fan of pedantic so. Yeah. Good question, man. All right. Oh, you got the next one, right. Yeah. So I have a new book out. It just came out at the end of June. It's called The Big Book of small Python projects. So a lot of my books have been for people who are total beginners are relatively new to not just Python, but to programming in general. JOHN, people have boring stuff. Yes, yes. Oh, man, so much boring stuff.

00:12:55 Actually, you have books on games and things as well? Yeah, yeah, that's, that's the two approaches I have to tricking people into learning how to program is getting away from Excel. And then also learning how to make video games

00:13:08 seems to be really common pathways into into programming. So I've also noticed that with a lot of beginner tutorials, people learn the syntax, and they learn all the concepts like loops and variables and things like that. But when it comes to actually working on their own projects, they're sort of stuck. And they're just left staring at a blank editor and not really knowing how to proceed from there. And a lot of people will give them usually the the two bits of advice that people get are, oh, you should work on open source projects, or just read the code for open source projects, which is actually pretty terrible advice for beginners, because a lot of open source projects might not be well documented. They're written for professional software engineers. There's, yeah, there's a huge difference between something that is absolutely polished and meant to be used in many situations in the real world. Like, you might learn a lot by working looking at Django, but most of the time, you'll probably just be confused. You're like, why is this so complicated? All it's so complicated, because you know, a million websites use it in weird ways. And that's why it's right. That's not a good learning tool, per se. Yeah, especially for someone who just learned about, you know, how to call functions and how to create classes, and pretty basic things like that. So I spent, I think, I think I was working on this on and off again for about two or three years. But I wanted to create a collection of small little programs, mostly like games, or puzzles, or little simulations, or things like that, where they were all just really simple and easy for beginners to read through. And then they can understand, oh, this is how all of these concepts I learned, get applied to an actual program that does something. So these aren't code snippets. They're not just like tiny little functions or things like this. This is programs that you can actually copy the code yourself and then figure out how they work. So I have about 81 of these products.

00:15:00 All together, they're all under, I set a limit of, of 256 lines of code just as an arbitrary power of eight to set it to. And they are all text based games. So they're a fairly old school looking like a lot of the games that people were programming in basic in the 1980s, and 90s. But the plus side of that is that all of the games are really simple. And you don't have to install additional libraries or modules or things like that, you can pretty much just type the code in. And it just uses the Python standard library. For all of this, I have a few of these programs that use a few other modules as well. But for the most part, you can get pretty far with with just text and just ASCII art. And, and also, even if you already know Python, these programs are great just for ideas of if you want to learn another programming language, and just get used to how things work in that, you know, you could find, you know, the idea for like a blackjack game from this collection of programs, or this like birthday paradox calculator. And all sorts of these little projects right here. So yeah, and and of course of this book is also freely available online at invent with Python comm slash big book, Python. I'm starting to get reviews coming in on Amazon, and they seem to be pretty positive. So I'm really hopeful about people just being able to take the next step in learning to code with this book. Apple. Good. Yeah. And then the the other book that I had that came out

00:16:33 in November, is beyond the basic stuff with Python, which is sort of the follow up book to automate the boring stuff with Python. I had a lot of people who are asking me like, Oh, I really like to automate, what should I read next. And I had like, some things I would tell them like, fluent Python is a really great book. But it's also like 800 pages, or 800 pounds or something. It's it's a really huge book. And the information is great. But it's really intimidating to to take this book is like, okay, read this one next. So I wanted to cover a book that had sort of the best practices for a lot of like software engineers. So there's sections on like, how to name your variables, or how to do code formatting. And I talked about the Black Code formatting tool. I talked about type hints and how to write documentation. I have a very superficial coverage of Git and GitHub and how to use version control. And just you know, and I even dive into like, what exactly does pythonic mean? Spoiler alert. pythonic basically means anything the person you're talking to, wants to to me at the time.

00:17:46 But yeah, just sort of a lot of the things that you don't really get in your typical Hello, world tutorial. A, these are the sort of tidbits that you would pick up with experience over over years of experience, I guess. But I just wanted to collect all of that advice and information and best practices into a single book. So yeah, that's also available online at the infant with python.com. website. Cool. couple of comments. Really shame, john. Dan says beyond the basic stuff was great for learning to do things Python away. And Wow, great to see Mr. swagger. It seems like only yesterday morning, your last book, it be piggies from Oh, hey, Neil. How's it going? Good. Yeah, yeah. Very cool. Congrats on the books. Brian, let's go. Let's talk about something completely different than books.

00:18:34 Like no books? Yes. Let's talk about thanks for popping that up. Yeah. So this was another suggestion. This suggestion came from David Nicholson. Thanks, David. I thought we'd covered this already. But then I looked in, but we haven't. And I looked into it. And it's, and I obviously haven't played with it yet. But okay, so test book is very cool. That's the idea of is to test your Jupyter notebooks. I think we've covered a couple things, ways to do that. But this is kind of a neat perspective. So the perspective of this is, you've got a notebook with maybe let's say functions in it. And you want to check those, you want to make sure that this right, you want to write tests against those functions. Instead of putting the tests in your notebook, put them in like just a test file, and then run it with PI test or unit test or something. And, and so to do that, though, like, let's say, I want to run a function foo. And I want to do it from another file. I've got to get that definition of foo into my test code. And so what test book does is it has a decorator that you can take, you can either put it on your test or a fixture that goes ahead and runs the one of the things you can do is run your notebook before the test runs. And yeah, that's really cool to have a decorator which has a path to that.

00:20:00 IP y and B file and execute equals true. And by the time it gets to your code, it's already going to run that that thing's defined like a function or variables defined within the notebook will just be accessible through the input parameter there. Yep. And the test kit test gets a fixed, you can have a fixture to be able to grab values, references. So you as the example, we're showing right now shows pulling a function in. But I imagine you can pull in really anything, any name that's exists within the notebook to be able to test it.

00:20:33 Some of the neat things that it includes right off the bat is, it's nice that it doesn't, it isn't just pi test, you can use it with unit test, apparently, also with nose but don't do that.

00:20:44 One of the ways things you can do also is in the the original example of decorating a test, it's going to run that notebook. For every test, it's decorated, you might not want that, you might. But if you want to run it all just once, you can put it in a fixture and then return the fixture. That's a cool thing. One reason why you might want to run it multiple times is if if there are interactions between the different parts and you want to completely isolate those tests. Another thing that's built into it is patching. So you don't have to import mark, you can you can patch different parts of your, your Python code, your Python Nope, your notebook code with like, like mock, you can patch it right through this. That's pretty neat. Yeah, that's pretty neat. I like it. Now, what do you think? Nice. Yeah, I haven't had a lot of experience with Jupyter notebooks. But it's, it's sort of becoming the main way that a lot of people are being introduced to Python, especially if they're coming from the sciences or academia. Yep. Yeah. And so getting like sort of a lot of informally trained software engineers up to speed with with like unit testing and other practices like that. It's definitely something I can get behind. Yeah, it's cool. And the getting the ability to call those pieces or interact with those pieces outside the notebook is quite tricky. So this is a neat way to do it. Me. We've got paper mail, but I'm not sure exactly how that folds into testing and stuff like that. Right. Right, actually. Yeah, yeah, I think so. I think it's more like inputs and outputs as a whole notebook, not like let me get ahold of the function in that cell seven, and try to call that. Yeah. Also, the target audience is different. So the target audience for your notebook itself is different than you trying to test your code. So I'm keeping the test code out of the notebook, I think is a nice thing to keep it clean. Yeah, I totally agree. Taking a step back real quick. Neal also asked, Are the small programs in your book owl compatible with micro Python or circuit Python? Probably not.

00:22:47 I don't know, I haven't taken too much of a look at micro Python. But I do try to keep all the source code as simple as possible and not really rely on like the file system or making network connections. Mostly, it's just standard i O, input output streams for text. So you know, if it can run print and input, then likely it can run these programs. Yeah, maybe you just have to make the little lights blink in Morse code. This Yeah, perfect. Nice. Alright. Something that is a little bit mysterious to a lot of folks, I think, partly because it's somewhat discouraged, but not always, is from package import star, right? Well, sometimes it's discouraged, because you probably shouldn't, there probably are situations where you want to do that, like if I've got three sub modules, and I want to take the elements in them, and then like, drop them into the top level Dunder init, for a package so that I can say package name dot items, but not organize them into one giant file, for example, that might be reasonable. The way that you control that is you work on the Dunder all definition at the top of your package, right? And in there, you can say, oh, here are the names of the things that I would like to export if you import star rather than everything, give them these, right. Maybe you define some weird thing called Django. And it's not meant to override Django or something like that. Right? You want to leave that out, too. How do you manage that? Well, there's this project over on GitHub called auto, all auto dash all. And the idea is it somewhat automatically manages the Dunder all variable for Python modules. So there's a couple of ways in which you can do it. You can exclude certain things, you can clearly differentiate what's meant to be treated as an external item and what's meant to be treated as an internal item. You don't have to worry about continuing to update the Dunder all and so on. So you just pip install it. And then the most it seems like the recommended way, I guess, is you would all somewhere in your script at the top level, I get the function or class level.

00:25:00 Right, no tabs base, no spaces, no indentation, you say start all then you write a bunch of code, functions and so on. And then you gain auto all dot start all. Yeah.

00:25:11 Yeah, exactly. If you import it from there, I guess you could even import star from there. But you say start off. And then you write a bunch of code and you say, end all. And basically, between those two markers, those are the things that go into your general variable. There's something about classes that will not work for classes or variables. As I take it back, it will with the start all end all. But there's also another way that that only works on various functions. And that is to put a decorator on to the function, which I think I like this a lot. But the fact that doesn't work with classes, sounds like that should actually be a PR folks. little thing, that extra one, like public class, or I don't know, whatever. But that seems pretty cool. So you just say, at public on a function, and then that will add it to the general. So if you want to export three functions for your module, you just put out public on those. And that way, when you're looking at it, it's like really clear, these are the public functions. And the rest are I mean, you could still from module import name, but not through with all right, yeah. Okay. Anyway, it looks cool, right? Yeah, that is actually a really nice way to just have this automatically taken care of. I mean, ideally, you're not really doing the front module import star all too often. Or rather, ideally, I'm the only person in the entire world that should be allowed to do that. And everybody else will have to do it the proper way. It's a bad idea. Don't do it. Now, yeah, this is really handy. Yeah, Dean out there in livestream says this should work with a context manager. Yeah, I probably should. I think the challenge would be then you'd have like all of your implementation indented, but still pretty cool. Yeah. Well, actually, I'm reminded of one of the places I do do i do do import or, or import star is, is in Dunder init files for packages. Yes, exactly. In those cases, I often do pull in, I've got a couple modules that have my interface, and I pull everything in from there. So those are those are cases where that isn't, it is something that happens, and then we get you then you're faced with. But what if I want to put another function that isn't part of my public interface? And you have to jump through hoops? So I probably use it in those cases. But yeah, I don't think it's broadly applicable. But for the people who are really trying to carefully manage their Thunder all seems nice, straightforward. Simple. Yeah. Yep. All right. out, I think you got the last one, right. Yeah. So I am working on another book.

00:27:37 I have a really bad book writing problem, I keep thinking that this will be the last one. And then I have ideas for 10 or 20, more. But the book that I'm currently working on, and I'm down to the drafts of the last two chapters is a book on recursion. So this is currently my untitled recursion book. But yeah, I gave a talk at northbay, Python, believe in 2018, or 2019. That was an introduction to recursion. And recursion is one of those things where a lot of people find it very intimidating, or even just outright magical. And it's, it's this thing that seems to be like only for advanced programmers or something like that. But I started taking a look at programmers who make a mistake. Yeah, right. Exactly, accidentally. Yeah, just just for some general background. recursion is when you have a function that calls itself and this is that it sounds like it won't work. And oftentimes it won't, you'll you'll get a sort of an infinite loop of recursive function calls, and then it crashes your program. But there are recursive algorithms, where this is a really handy technique and allows you to do really sophisticated things in in not that much code. However, a lot of people find it really confusing. But more than anything, I found that it's just poorly taught. Most people will probably learn this from a computer science professor, or they'll be studying it as a way to prepare for job interviews for the coding section. You know, there's a lot of times where people will be writing out an algorithm on a whiteboard, and their interviewer will say, like, Okay, and now can you do the recursive version of this algorithm? As a quick gotcha. But yeah, there's the short of it is I realized that a lot of times people don't really teach the concept of the call stack. And without explicitly knowing about what a call stack is, and how it works. A lot of what recursion does kind of just seems magical, because you're missing this huge piece. And I found out so many other things about this. And so I thought, Hey, I could write a quick little tutorial on recursive functions and make a talk and then that just kind of ballooned into a giant book now.

00:29:48 Hopefully, with courses, I'm like, oh, that'd be neat little thing to play around with. I spent the last month Yes.

00:29:56 So I'm hoping to have this book's probably done either at the

00:30:00 The end of this year or early next year in 2022. But yeah, so a book that just covers recursive algorithms and and why people find recursion to be so intimidating and how it really isn't, and even how oftentimes, it's actually not the best technique to use. You just want to write straightforward, simple code. But if you really want to show off how smart you are, and annoy your co workers that way, recursion is also really great for that. What I like about it is if you have hierarchical data, it matches that really cleanly. Yes, you want to traverse a tree, but in our like a real simple way. Are you want to work with an algorithm that is like iterative, in the sense, like the previous step, kind of naturally, the answer that leads to the next one, those types of things is like a super elegant answer. Yeah, I found that recursive algorithms are really great when your problem has a tree like structure, and also involves backtracking. Otherwise, there's probably you probably just need a loop, or some iterative way of solving it. We can also come up with a cool job, like the one we had on episode 236. There, there are so many recursive jokes, I actually opened up my talk at northbay Python with just like, okay, we just got to get that out of our systems do the whole, you know, in order to learn about recursion, you first have to learn about recursion, these jokes that we've heard, like millions of times, yeah, people can check out the little cartoon graphic thing on episode 236. Yeah, I was gonna ask you if you've got anything you want to just throw out there at the end? No, I'm just been working a lot. That was just one question. I was just gonna think that maybe Al's book was about a write a book about recursion.

00:31:46 The Making of is something that I've also been thinking,

00:31:50 I feel like a book on metaclasses and meta programming might be very relevant.

00:31:56 Alright, I got a couple things to cover from my extras. Okay. First, I had talked about Oh, my posh Oh, my posh, which I think is a really cool, like, Oh, my z shell type of thing. But for PowerShell. And if he's the new windows terminal, and you get the new PowerShell, seven and set that to be the default, then you get these really beautiful nice prompts, and autocomplete and all those kinds of things. So those are really neat. People can check that out for all the posh shell stuff. But someone was asking for something that would do a thing that is really cool. Like, what if? What if, when I And oh, by the way, is because we gave it a shout out? Right? I was dreaming of something that would automatically activate virtual environments when I see to CD into a structure that contained in the tree somewhere in a virtual environment, which is cool. So they dug around and said, I found this thing called posh dash der E and V, which does that. So as you change into the directory, it will automatically activate virtual environments. Nice. Nice. Yeah. So that's, that's pretty neat. So people can check that out? Is it sort of follow up? Another thing, one of our listeners? Einstein, fitness fincen, I believe was the one who sent it over. Thank you for that just said, Hey, quick shout out your show has been super helpful to us. It's been inspiring a bunch of us scientists. We're here in Iceland, and I believe also at Harvard, if I recall correctly, and they now publish an article using Python sqribble method of determining physiological indo types are basically a sleep apnea study of trying to turn this into more of a continuum rather than yes or no, you have yes or no yes, do or don't have sleep apnea. They're really cool just to see listeners listening to show using some of the packages and doing cool stuff that help people. Just one more follow up to three more follow up section about next one. Really quickly. I've been having such a challenge with email for two years. And I finally, I think, solved it, the beast, I believe, I have had hundreds of emails from years ago that needed action. And finally, I've gotten back to almost everybody down to just a handful of emails, and I'll have them all done. But anyway, I want to recommend two email clients one for the Mac is Newton, pretty cool. And then I'm, I'm gonna give superhuman a try. But it takes a while to get set up on that. If you're out there struggling with email, check those out. And so we've heard about cloud computing, that's where you might run your program in the cloud. You've heard about virtual environment, or sorry, virtual machines is where you might fire up a computer that runs in a container or a virtual hypervisor. And then you can interact with that in like its own little way. But Microsoft apparently I was just reading like 15 minutes before we started, I thought I'd throw this in there. They just reveal not just windows 11. But windows 365, which is basically you buy windows and the thing hosted in the cloud. So you just like a web browser to it or something and then you have a computer with all your files. It's instantly on. So I thought that was kind of interesting. throw that out. There.

00:35:00 Just like office 365 except the entire operating system, the entire computer with all your files like saved there. Yeah, exactly. Probably expensive. I have no idea. Last thing. We talked about flock No. Right? We talked about flock and the vanishing of third party cookies and the stuff that Google is trying to do. And then remember that brand new point, and they received significant feedback that was not totally positive for them. Yeah. So, you know, parallel to that, I think is really interesting is that Apple also had their do not track thing that they put on their phone, which is fine, but I think it just needs to be way more than that. But yeah, so they have that. And would you be surprised that only 25% of the people said, Yes, please track me. I'm actually surprised that 25% of people said yes, like, I, if it's over. It's blowing my mind. Right? Like, yeah, who's who's saying yes, that's exactly. So here's an article Facebook and its advertising, advertisers are panicking. As the majority of iPhone users opt out of tracking, and I saw that 20% of ad spend is now moved away from iPhone and towards Android, because Android doesn't, you know, they're happy to track you. Because that's Google. Yeah. But also, just I think it's very meta and finding, so I have my VPN that has a ad blocker plus cyber, like, basically virus malware detector at the network layer. Notice, there's a big gap in me showing you this article up here that's

00:36:21 trying to show me about the advertisers and my network, my VPN is blocking. I just love it. So anyway, those are all the things that I had to share there. Oh, you got anything else you want to throw out there for everyone? Yeah.

00:36:34 Outside of the books, I'm also working on my open source project called pi auto GUI. This is a GUI automation module for Python, where it's a module that lets your Python scripts control the mouse and keyboard. So if you have some software that you want to automatically click and type things into, you can write a script using pi auto GUI to do that it works on Python two, and three, and also on Windows, Mac OS, and Linux. I feel like I've been neglecting this project for the longest time, but more and more people are using it. So I really want to start adding more and more features, to bring it up to speed with with a lot of other GUI automation libraries that are out there. So if anybody is interested in contributing, I have the GitHub link. And you can also just go Google for pi auto GUI to find more information about that. That's cool. I found out by googling with DuckDuckGo. Yes, I still have a problem saying Google as as the verb. No, I do too. All that finally got over using guys as a general neutral pronoun. But now i'd still have problems saying Google all the time. Yeah. It's all it's all hard. I By the way,

00:37:42 I still have trouble not telling people to MapQuest something.

00:37:47 It's good except those little arrows to move each around on the map. bars on each side are so so clunky, and you got to print the thing out for like five pages and follow the pictures. No, but so one thing I do want to give a quick shout out to the guys I read the docs, Eric and crew over there. Like they have an ad right here. And it says sponsored ads serve f ethically, you know that's based on not tracking in retargeting. That's just, hey, there's something to do with this Python project. So this ad has to do with the context of what is here is just it's relevant to the content. I'm already looking at. Good old, downloading, just like magazines and newspapers and stuff. And it's not about finding Hot singles in my local area.

00:38:29 That's great. Exactly. Alright. Yeah. Cool. Thanks. Thanks all for joining us today. And Brian, as always, thanks for having me. You bet. Thanks, everyone, for listening. Thanks for listening to Python bytes. Follow the show on Twitter via at Python bytes. That's Python bytes as in BYT. s get the full show notes over at Python byte sarafem. If you have a news item we should cover just visit by them by sarafem and click Submit in the nav bar, we're always on the lookout for sharing something cool. If you want to join us for the live recording. Just visit the website and click live stream to get notified of when our next episode goes live. That's usually happening at noon Pacific on Wednesdays over at YouTube. On behalf of myself and Brian rockin This is Michael Kennedy. Thank you for listening and sharing this podcast with your friends and colleagues.

