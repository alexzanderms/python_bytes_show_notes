00:00:00 Hello, and welcome to python bytes where we deliver Python news and headlines directly to your earbuds. This is episode 270. Recorded February 9 2022. I'm Michael Kennedy.

00:00:10 And I'm Brian Aachen.

00:00:12 I'm Dean langsam.

00:00:13 Dean, so great to have you on the show. Thank you so often you helped me with that start in the live chat. Yeah, I know you're a big participant in the show. So we we pulled you in. And now here you are. Welcome.

00:00:26 Thank you. Thank you. I've been a fan. Actually, since episode one. I've been hearing this weekly. And it goes back years, like five years. Yeah, it's about five years. I remember, I moved apartments back then. And I listened to Python. I didn't know Python as well back then. And actually grow with the show. So that's very nice. That's fantastic.

00:00:45 That's incredible. We've heard that from other people. And that's just like mind blowing to me. But yeah, it's cool. Yeah, I

00:00:52 was taking like intro to data science classes in Coursera, while listening to the show, and now, other people call me a senior Python. So that was very nice.

00:01:03 That's fantastic. And it does go fast. Yeah. So awesome. Thank you so much for joining us on the show. It's awesome. Before we get into it, I also want to say this episode is brought to you by data dog, check out their awesome stuff at Python bytes FM slash data dog. I'll tell you more about that later. Right now, Python. I want to hear about a better pi game. Loop. Brian, tell us about it.

00:01:26 Yeah, so um, this is a article from glyph. And this is a PI game is a is a package that's used for for game programming a lot. And it's it I mean, a lot in programming games is definitely I think it's one of the things I tried to do early on when I was a developer. And I think it's something that I think I encourage a lot of new new developers to try out things like simple games, because there's fun to learn coding that way. And it's a anyway, it's a big part of learning, programming and the programming space. And with Python, it's pretty easy with my game. And there's a lot of tutorials out there. But one of the things that glyphed points out is a lot of the tutorials have this sort of simple while one loop, where you the main loop of a game where you just spin and wait for events, and then handle the event or draw things or whatever, and then go back this in draw, you know, keep going. And this just happens forever. While while one loop in programming is a busy loop. And it's generally something that kind of has some issues. So glyph is pointing out that some of the issues with this are that they that it's it's a waste powers, for one, your CPU is just spinning all the time when you're really not going to get events that fast. And then also, there's a there's a thing that I didn't know about called screen tearing, which is when you're drawing the screen at the same time you're writing to the screen buffer,

00:02:58 right? You're not waiting for the V sync 60 100 frames a second, whatever it is, right?

00:03:03 Yeah. So and that can cause glitches in the game. And it doesn't doesn't look as good. Pygame does allow a V sync option. But apparently there's like some problem with that. So we're really there's a the the article walks through both of these, both of these problems, and the V sync fix, but and the problems with that. But the end result really is he's got it's actually interesting, interesting discussion about like, really what's going on in Pygame. And he talks about like that, there's really three jobs going on the drawing and the game logic and the input handling all at once. And so this is a three thing, it's probably a good idea to do maybe async stuff, so things can work together. And in the solution he came up with is still I mean, it's definitely a larger loop. But it's not that big of a loop. More complicated, and it's an async version to have some sleeps in there with some delays, possibly, but a better loop for gaming. And it's it's not that complicated. Actually, if you're learning gaming law programming, hearing about this, these sorts of issues and and trained in learning how to solve it is probably just going to make you a better developer faster. So think it's a good thing to look at this. Yeah,

00:04:26 this looks really interesting. This gaming stuff, you know, it's it's so often very much the same and there's like these core elements like process input, you know, if the keys down or if there's a joystick attached, draw the scene, do the hit detection and AI or game logic. It's almost always the same. Like this looks great as a way to tell me what I should be doing. And maybe the next step would be create a class that I just override, do the AI logic draw the screen and do let that like not even be something I ever see. So this is right for Little bit of a hiding away even this cool stuff.

00:05:03 That's true, maybe, maybe Pygame could extend the a better built in loop to hook into or something. Yeah, yeah,

00:05:11 I always, I always, I not actually used to do a lot of gaming on Python. But I always think about browsers, which are also kind of a loop that runs forever and renders stuff on your screen. And I think, well, the front end guys got it so easy, right? They don't they just write the code and the browser does it for them. And I'm not sure if it works exactly the same. But maybe if someone manages to implement something that's like, just write your game and put it in this thing. Maybe this could attract more people into writing small games in Python?

00:05:48 Yeah, absolutely. And my thought, is, if you just sort of abstract that away, it's just 2d stuff, right? Which it's pretty easy to get into, I just listened to, or watched a Netflix series called high score, which is the history of video games going like way back to the Atari 2600, and asteroid and whatnot. And there's this woman in her talks about how she got so inspired about just text based games. So if you're learning to program, I definitely think games are a fun way. And often, I think people might perceive that as like, well, I've got to write, you know, Angry Birds or something, which is fine. You can write that. And that's super fun. But you can, you can do a lot of stuff with just sort of techspace little fun story, adventure type stuff as well.

00:06:32 I got to check out that Netflix series. That sounds great.

00:06:35 Yeah, yeah,

00:06:36 I was just helping a friend writing like this small game. And he's written this, like the width, one thread and everything for this school project. And then he told me Well, but I'll do a show score, a score that like updates with the game. And then I felt like no, for that, you'll need multiple threads, a PI game loop maybe and stuff like that. So if that could have been easier. And on him while learning Python, this could have been hot. Awesome.

00:07:01 Yeah, absolutely. There's a lot of nice comments out in the live stream. Anthony says I teach Pygame. In my code club after school class, smart kids pi game is great. So it's arcade, which is an alternative and OpenGL based alternative to by game. That's very cool. I do think having something visual for people when they're learning. It just, it reinforces things so much, right? Like writing that API back in that toxic database is great when you see the next three steps down the line, how it's gonna enable something. But when you're getting started, you need quick feedback. Absolutely. All right. Well, let's talk about something else. That's awesome. Here I want to talk about SQL alchemy. SQL alchemy has been getting a lot of attention lately. And that's super cool. Mike Bay released sequel alchemy, two, which was the first async API version. So now you can use async and await with sequel alchemy, which opens up lots of possibilities. Sebastian Ramirez released sequel model, which is like a marriage of gigantic and SQL alchemy, which is also super neat. But there are many other things that you can do with SQL alchemy that are really handy. So as all the awesome lists go, here's one for a curated list of SQL alchemy. Now, first, just a word of warning, from what I can tell, including the PR that I added yesterday, all the way back to the one in June 2020. It doesn't seem to be getting a whole lot of love, which is unfortunate. So it seems like it might be sort of stalled out. But that said, it's still a really good list of things. So I'll pull out a couple that I think are nice here, which ones that I want to highlight. The first one is called continuum, sequel alchemy continuum, and this is versioning. So imagine, you would like to have a history or a record of changes to your database, like maybe this is some sort of financial thing. And if you see changes, you want to be able to say, this person made this change on this date, when they said, you know, update, get the record, make a change, and now called commit on the sequel alchemy session. So what this does, is it will create versions of inserts, updates and deletes it won't store those if there's not actually a change. It supports Olympic migrations, you can revert data objects, and so on. So if you want that sequel alchemy continuum, it's just like one of the many, many, many things in here, which is pretty awesome. Another one I wanted to highlight is UTC. So one of the challenges that people often run into is when you're storing stuff in the database, what dates in particular, what time is that, that the time of the user who might be in a different time zone than the API endpoint that it was running that right so it might be nice to be able to store

00:09:49 zoom like timezone aware things and store them as UTC value so they're always the same, and then you can convert them back to like the time zone, which is pretty cool. Another one is a sequel alchemy. utils is pretty cool. So it's got things like choice type, which I'm guessing is basically noon, but country JSON URL, uu ID, all of these different data types, data ranges, all kinds of stuff, your RM helpers, utility classes, and different things like that. So that's kind of a grab bag of them. I see. One also is called file depot. There's cool stuff for processing images, you've got file depot, which is a framework for easily storing and serving files out of your database on the web, as well as sequel alchemy image attach, which is specifically about storing images in your database. Which by the way, we do Brian on Python bytes. Cool. You know, if you go to the any page, any episode page, and you see like that, that watched it on YouTube, that little thumbnail, we go get that dynamically from YouTube, and then serve it up. So we don't have to depend on YouTube. So anyway, that's pretty cool. Let's see, maybe two more, there's searchable. So if you want to add full text search, to your model, you can add use this and then only supports Postgres, because I'm sure it depends upon some core element there. But you can also do another one from MySQL, as well, which is pretty cool. And then the last one is schema display, which generates basically graphs of your models and how they relate to each other stuff like that, which is kind of nice. What do you what do you think? Cool stuff, right? Yeah. Very cool. Yeah. So if you're really bought into SQL alchemy, you owe it to yourself to just flip through this list to just go like, Wait, it can do that. I had no idea that I could do that, right. And just sort of see what are the other things that people have built on top of here that I think would be super, super helpful. And by the way, my PR, was really to say, there's a layer called then abstractions. And it says, you know, under the thin abstractions, we really should have us some SQL model, because that thing is super popular. Straight out of the gate. Right? So people should check this out. It's already got almost 7000 stars, and it's what a month old or something. That's crazy. Yeah, maybe maybe six weeks, but really, really new. Yeah. And

00:12:16 but the author, I mean,

00:12:19 yeah, exactly. I know. Brandon on the audience says there should be a meta awesome list, like an awesome list of awesome lists. There is sure. And, yeah, quite quite fun. I definitely recommend people check that out. All right, Dean, that brings us your first item. Tell us about it.

00:12:40 Yeah, so at work, I needed to write something that required threading. And I was very afraid of threading at the beginning. Basically, what we needed to do, we have some mechanism, when I'm a data scientist, we need to take many queries at once, and get them as pandas data frames, and save them to disk and later, take all of them and work with them. And instead of writing, like sending them sequentially, I wanted to send a bunch of them together. And the bonus thing I found that is that when you release them to a threading, if you don't lock the threads, or you don't wait for the threads, you can actually see work with the Jupyter Notebook while waiting for the queries. So that was the main main reasoning. And eventually, after I've written most of the code, I got a this blog post called the thread pool executor in Python, the complete guide. So this is basically Jason Brownlee, he's the guy. He's also the guy from machine learning mastery. So I'm very familiar with them. It's in it's a very long blog post. So you could kind of read it as an e book or just access the stuff you need. Because it's like, I know a two minute two hour read maybe. And he explains everything from the beginning explains like water Python threads, how to work with them, then introduces the thread pool executor, which is a more convenient way to use threads. He explains about the life cycle of the like, what to do, what is he do, how to do it, then with a context manager and stuff like that. And eventually what he talks about that other people do not think the when you search for, I know threading to teuer is actually about like the complete lifecycle and then the usage patterns, and then explains about IO bound versus CPU bound and everything. And he finishes off with the common questions. So this is like the the link I've saved because I will forget it in a week. But the next time I need to, I just know I can come back to this, like create the common questions part. And yes, there's a questions, the questions like, How do you stop running

00:14:44 out the hair? Yeah. There is a lot there in this article, is it? Yeah, it's

00:14:48 a lot. It's a lot. But the thing is, you can come back later and just take the stuff you need. Like, I remember, I know I'm working. Then I can ask myself how do you set a chunk size in map? Well, it says there that you don't because that's for Process pool. But then I have another question maybe how do you cancel a running test? And the answer is that so I think that's, that's a good thing to have like to quickly access when you need to. And he finishes off with, like, what's the difference from ice async i o from threading dot thread from process blue executor. So that that is a very helpful guide, very complete. And the entire blog actually explains like it's an entire blog dedicated to threading pool executor and the process pool executor.

00:15:34 I love that it's covering the thread pool and process pools, because it's easy for things to just completely get out of control. You know, as you throw more work at it, stuff can completely back up. So if you just say, create me a new thread and run that and then another place create me more threads. And I got a bunch more oh look, now I have 1000 items, a process create 1000 threads. Each thread takes a lot of context switching to switch between and they take a decent amount of memory and all sorts of stuff right? Through the thread pool, you can say queue up the work and run 10 at a time, similar processes, which sort of sets an upper bound on how much concurrency you can deal with, right? Yeah. Yeah, this is cool. So you talked about solving some problems in Jupyter notebook using this, what in particular were you trying to do? So basically,

00:16:21 I'm a concerned I know, 1000 1000 queries. And once I get like, we have big data, and then they have a query that takes a part of it. Like after maybe some group buys and limitations and stuff like that. And I want to take the data frame and save it. And then once I have the entire data from all the queries, I want to join them, or maybe do some, I don't know, some processing, and then join everything. The thing is after like 10 of those came back, I have a sample of my data that I can work with and then try to manage and then have a code written while the other stuff are still written, I want to have that, like I can play with it. So if I release the, the data things to the to the threads, and they work in the background, the main thread of the Jupyter Notebook is open. And you can start working on the same notebook before then like I used to, like open a notebook that's querying stuff, open a notebook that I'm playing with and like, see that the file paths are the same. So I'm not confused with like some other directory of the other versioning of this data. And now it just works. Oh, that's really and you can also, like add a thread for I know with some visualizations of what's finished what's arrowed what's,

00:17:42 like, everything. Fantastic. And yeah, that sounds really good. I'm sure there's a lot of concurrency and parallelism in the data back end. It's just how do you sort of access that from Python? Right. So how do you issue all those commands? Excellent. All right. Let's see. Brian, anything you want to add before I talk about data dog?

00:18:00 No. Some comments. Like Sam Morley, concurrent futures is a much less painful way to work with them at a higher level. So maybe we can get some an article on concurrent Futures On The upset sometimes.

00:18:14 Yeah, so that the thread pool executor route gets you back futures. And then part of what's explained in the in the blog post is how to work with futures like as completed or sequentially or like you decide your strategy, but you work with the futures.

00:18:32 Nice. Okay, cool. Yeah,

00:18:35 nice. And of course, requisite shout out to unsink, which is all sorts of awesome for this stuff. unified API for direct threads for processes and async I O. But what I want to tell you all about now is data dog data dog is really awesome, you should really have insight into your applications. And that's what data dog brings you. So data dog is real time monitoring that unifies metrics traces logs into one tightly integrated platform. Their APM empowers developers. To identify anomalies and resolve issues, especially around performance, you can begin collecting stack traces, visualize them as flame graphs and organizing them into profile types such as CPU bound, IO bound, and so on. And teams can even search specific profiles and correlate them to distributed traces to, you know, find things across different parts of your infrastructure and micro services and identify slower underperforming code and then make it faster. Plus, you can use the APM live search, you can search across the full stream of all the traces over the last 15 minutes. So try data dog APM for free with a 14 day trial. And then data dog will send you one of these very cute doggy T shirts, which who wouldn't want one of those? Right? So was it I thought I said FM slash data dog or just click the link in your podcast player. You want us to get started? Thanks to the dog and Brian, back to you

00:20:01 back to me. I, I was uh, I'm gonna apologize, whoever tweeted this, but somebody tweeted this out, link to this article and talking about chaining operators. So this is an article by Rodrigo suredbits Serral

00:20:20 pi don'ts. Yeah.

00:20:24 So. So I don't know what the PI doubts are about just, I don't know, maybe you started blogging about things you shouldn't do in Python. But anyway, this article is called chaining comparison operators. And I use chaining all the time. Mostly, I use it for simple things like, Oh, 518, a is less than vehicle less than c. So ranges like, min, you know, my x value is between min and max. Yeah, that's really nice. Yeah. My hit done that like just tip for anybody doing that, always doing less than not, don't do greater than because it's hard to do that good. Anyway. So keeping like that, but this articles talking about other stuff. So so this is pretty easy to think about, like the less than operator. So is less than b less than C? Is that really the same? As is less than b and b is less than c? It is that combination, that's what chained operators are. And the the importance there is, it doesn't really work for some operations. And he gets into like, the equal operator. So you can do a equals b or equal c, which means they're all equal. Great. What about not equal? Does that work the same way? And it doesn't, because if you got like, a is not equal to b is not equal to c, it doesn't mean they're all different. Because A and C still could be the same and have that pass. So this, this sort of if you're working with change expressions, which I think you should, if you're doing complicated things, that's why I like it better than doing a have having a bunch of ands in there. As long as it you can keep it readable. But this article talks through some of the some of the gotchas inside of in things to watch out for like side effects and non constants and things like that. So great discussion of chained operators.

00:22:21 I hadn't even thought of doing this not equal to this seems wrong. It just looks wrong.

00:22:27 Yeah, but in Yeah, don't do change not equal. That's just unless, in even if that's what you meant, that, like is like will be and b is not equal c, but it's okay. For ANC to be equal. That would be a terrible expression, because it's confusing. So don't do that.

00:22:42 It is, yeah. My favorite one of these chains, like X. Seven less than x less than 10. Yeah, something like that. That's nice. My favorite is converting x if x is not none else, why to just x or y? That's, that's so clean and so nice. And I know coming from a C++ background and C sharp, I, I'd never thought that was possible. And that's great. Dino do you think about this?

00:23:10 I love it. I use it a lot. It net didn't always work. I think it's still not working with a panda's data frames are a panda's series and arrays. And I'm I do wait for this to finally work. Arrays when you do an arrays in like in NumPy, or pandas, when do an array is less than some number? It returns a new array with true like a Boolean array with true and false. And last time I checked was a few months ago, but it last time I checked, it didn't work I couldn't do one is less than the series is less than two and get the Boolean array. So I'm waiting for this. But I love the concept. A lot.

00:23:51 Okay, that's no, no, yeah, I really consider the integration into pandas. Yeah. But of course,

00:23:56 I'm not sure how would you implement that with the regular data model of like dander dander, EQ or right or is it something else?

00:24:04 lt LTE? Possibly? I'm not sure either. Yeah, there's probably some magic method. And it might just expand out to less than and then and, you know, like the two the two tests basically, probably does. But cool. We can.

00:24:18 We should ask Brett cannon to do a deep dive into what?

00:24:23 He's pulling apart all the different parts of Python syntax, right? Yeah. All right. I want to give a quick shout out to rich because it's one of our episodes. So we talk about rich. I wasn't gonna talk about Anthony sharp, I didn't have enough information. So I mean, he's the other person who needs a shout out in every show. So I want to talk about this article, highlighting some tools by Martin Hines. Yeah, Martin Heinz, co creating beautiful tracebacks with Python. Don't exception hooks. So two things that I want to point out here one, Python has an exception hook mechanism, which is pretty cool. So what you can Do you can create a function that has this signature of exception type, the actual exception and the trace back to three arguments. And if you have a function like that, you can just go to the SIS and say sis dot accept book equals that function, not calling it, of course, just passing the function as value. And then whenever there's an exception, this will be called by Python. That's pretty cool, right? Yeah. So depending on what you want to do, like, you could say, well, we're gonna store all the errors. Like, let's imagine, here's a scenario where you might make make use of this, I'm going to create an app, and I'm gonna send it out, I'm gonna use PI to AB or pi to exe or just, you know, let people install it somehow. And then when it runs, I want to it's going to run on their computers. But I want to gather up all the exceptions of all the users across the company or the research team or whatever. You could have this submit this error along with other details, right back to a database over an API, right? And then you could do like analytics, like, well, here's the most common error, and so on, of course, you could use century or something like that. But maybe you're trying to gather some specific information. That's different, right? So that's one of the types of things you could do with

00:26:07 this. So I got a question before going. Yeah. So this doesn't catch the exception, it just it it doesn't interrupt the flow. It just, it just happens.

00:26:19 It doesn't, it doesn't catch the exception. It lets you basically change what kind of output comes from Python. So if you just wanted to print out like, here's a file where there was an error, and here's the error message, okay. Like you could do that right, or the type. And then the message I'm just

00:26:36 noting there using the example doesn't rethrow it. So you don't have to do that,

00:26:41 then? No, I don't believe so. And I'm not 100% Sure. I think the app, I think the process still ends. If it's just a regular running a script rather than a web app. I think it still ends. But anyway, sorry, two different kinds of output. Yeah, no, you just don't get the standard print output that Python gives you. Right? So you could say, avoid printing the trace back. If you wanted, you could just say this file on this line had this error. Okay. All right. Okay, so it's easy enough to do, like, for example, they have this function that call they call that caused an error. And all you see when this crashes is there's a trace back, this file this line in this module, here's the error message, right? Instead of the huge stack trace that might scare people. Okay. So I mean, obviously, you can use try and accept, but this is global, right? So even if some libraries calling something and you're not catching it, and like, right, it's, it's catching everywhere. Okay, so then you could do more work about breaking that apart. And they talk about doing that. But the real interesting part is, if you go and look at some options, so there are five, I believe there are five libraries mentioned here that do really cool stuff. For solving this. The first one is by will googans rich library. So you can just go from rich dot traceback import, install, and then say, install, show locals is true. And then this also basically installs one of those global exception hooks. But with the benefit being, when you get the errors, what you get is a nice rich output.

00:28:10 It's super pretty,

00:28:12 it's pretty and it's useful. I mean, it's color highlighted, so you can see where the error happened. But it also will print out in a really nice way with formatting and highlighting that the locals, right, so what what values were passed to that function when it's crashed? Well, here's a little table of those, and so on. So this is, this is really easy to identify, and at the very bottom, like a nice clear way to like, Okay, what happened. So you can do this is a super simple version here. There's also some manual ways to make rich print this type of stuff. Number two is better exceptions, which does similar stuff, you can see that it doesn't quite take over how the look and feel is so much, but it basically colorizes the standard look and feel of errors. So you can see you know, which function which error and so on. So it's pretty good. And there's pretty errors, check out pretty errors. This looks pretty good, right? It's got a lot of like bold and highlights, you can really call out the error messages and the functions involved in the modules involved. Here's one for you, Dean, the built in one the ipython. It has Ultra TV for ultra traceback. And this is pretty nice, right? Actually, ipython. one's pretty good.

00:29:23 Yeah, the the Biden one is really nice. And also, I was planning to talk about it in the extras, but on IPython eight, which is pretty new. They even have this improved with some color coloring of over exactly where the arrow happened. I think this is the 310 parts, or something like that.

00:29:42 Oh, awesome. Yeah, that's cool. Well, we'll hear more about it. And we can talk about IPython eight as well. Yeah, so that's built in kind of if you're already on the data science stack, and then finally, stack printer, which you can give it a trace back and it will print that out. So you sort of do like retching and say set exception hook Give it a theme like darker or whatever. And then it does this pretty nice printout as well. So these are all great. I'm personally liking the rich tracebacks version best, but this is really nice. Yeah, Connor out there in the audience says, Wow, using show Luke would have saved me hours and hours of time. And you and me both.

00:30:20 Yeah, I feel the pain.

00:30:22 I do too. So a lot of times, you're like, I know it crashed and it says none type does not have attribute whatever. But like, why is it none? I need to go back three levels, right? Like, yes, it's so good.

00:30:35 And then you find out he just forgot to return from the function?

00:30:38 Yes, exactly.

00:30:41 I was I was just debugging it test failure the other day. And pi test has the option to to throw a local, you can show locals with a with a crash. Or with a with every failure. And the I forgot that the particular thing I was testing had like variables that were storing 1000 element arrays. This just like went on.

00:31:09 I believe the I believe Rich's has a truncate variables where it'll do an ellipsis or something like that. I think I mean, yeah, I'm not 100% Sure. Because I've been looking at all five of the wills in the chat. We'll have to ask him wills in the chat. Give us a shout out we'll I think I think truncate is out there. Right. I'm not percent sure.

00:31:28 I think about how can I actually. So I talk with databases. And sometimes the errors from the databases are like this big Java stack. Java trace. And then you need to like a lot of go a lot of ups. Sorry, something some noisier. Sorry, you need to go a lot a lot app in the browser to actually see the error. And if I could just shut it down and just give me the the Python stuff.

00:31:56 Yeah, I don't know what setting you set for that. But certainly with this mechanism, you could set it up. So that like if the word Java appears, you just stop. Stop going back. Yeah. And we'll says yes, that's right. Thank you, Brian, for pulling that up. Yeah, you can truncate it. So the printing won't go completely insane. Because it could be gigabytes. I mean, it could be out of control. Right. Yeah. But

00:32:19 I mean, even if they have like, reasonably large limit, sometimes it's just like, Oh, I forgot that huge array was there and it's hard to see stuff. So

00:32:28 yeah, absolutely. All right, over to you, Dean of testing. Brian was talking about testing stuff and looking at the color and so on. Yeah. So I thought,

00:32:37 Brian, this would be up your alley. So it's called ways I use testing as a data scientist. It's by Peter Baumgartner. And I, I'm a data scientist, but I also love testing. The thing about testing with data science is sometimes it's not that clear what what you should test for, right? Because maybe some thought some things we do is test stochastic. And then you could not actually test for stuff or stuff like that. So this blog talks about, like the art of testing, because sometimes like the, it's not clear what you should test and the more experience you get, you can actually see what's coming your way. He talks about like data validation, and he, he's throwing many packages that could help you packages like Panda and great expectations that they think we've talked about before in the in the podcast, and also, like the numpy has some stuff like ease close checks for two numbers that are close to each other, or have they equal a certain data frame equals in pandas data frames. So he talks a lot about that. He also talks about using a cert in your code, like, even if you had some ad hoc stuff of analysis, use assert within the code, don't think about the tests later. Just think like, Where does the where does this thing could hurt me it gives an example. Maybe if I'm trying to join two data frames, and they think they have the same shape, I want to check if they have the same, the same IDs. So that way, I know that the joint works correctly. So he asserts that the land of the ideas is the same within the two data frames. And this is not even like real testing, we would say it doesn't use some testing framework. He just says like write it within your code in then continues to like hypotheses which basically bombards the functions with a lot of ways to actually try try to fail it. It continues with some other packages, and we eventually goes into a PI test, and shows like, how we would work with PI test and with like, an approach that I haven't heard of, but it sounds it sounds good. Arrange, arrange, act, assert, like arrange the data then act on those things you want to check and then just assert if they are equal or almost equal and the thing you wanted to check for.

00:35:09 It's such a such a easy mistake to make like this number equal equal that number. Yep. And it's, but when you do in science or data science,

00:35:19 I'm glad he talks about structure because a lot of people get into testing, get, get these giant tests that do do a little work, test something, do a little more work, test something and then if it breaks, you're not sure what where the failure is. So this sounds fascinating, and actually, not sure how I missed it. But I really want a way to compare an array for almost equal, so I'm gonna have to go read that.

00:35:45 So NumPy and pandas are both have mechanisms for that. It's pretty great. Nice.

00:35:52 Yeah, very nice. I know this will be helpful people, it's really I always wonder about testing data science stuff, and machine learning things and so on where you get small perturbations, but they're fine, right? It's off by 1,000,000th of some unit. But like, that's totally good. Those are equal, but it's, it takes I think, an extra level of thinking about it right? So much people focus on how do you get rid of your dependencies? And how do you make sure that you don't talk to the real database when you do this? So Right. And that's one aspect that people focus on. But this working with, like sciency type stuff, is its own specialty.

00:36:28 Yeah, I think that the entire community is a it's a fairly new community, although it's not as new as liquid. And I'm not sure like, we're on top of how to do tests in machine learning. Like many. We have many packages for debt. We have many theories for death, but I'm not sure like the cute we have, like, actually one solid good way, and maybe we shouldn't have, but it's it's a debate.

00:36:55 Yeah, for sure.

00:36:56 Same with the rest of the software world. So welcome.

00:37:01 Thanks. Yeah, Sam out in the live stream says NumPy has an assert array almost equal in NumPy. Dot testing. Nice. I just learned there's a numpy dot test. And that's cool. Yeah. Awesome. All right, Dean, while you have your screen up, do you have any extras you want to talk about? I know ipython. Eight was a

00:37:19 thing. Yeah. So I buy from eight was released. Like last month, after three years of waiting for a major version. It has a lot of new features. But this is the extra part. So we won't go over them. Just two and a half things I wanted to mention, it says that it's a less code. And I love that, like once you get a better in a programming language, you understand that you shouldn't write more code, you should delete code. And that's what those guys do. And the way they could have done that is by hiring a person through the num focus small development grants. And I think this is important, it's actually being talked a lot about after the love for J stuff. It's been talked about, like, Well, those are three guys worked tirelessly, they have their full time jobs. And they couldn't fix the lock for J stuff, maybe as click quickly as some other guys or two people wanted. But then you realize that they got donations of like, a few $100 within 10 years. And then after the look for JSON, suddenly they got 1000. So this, I think, it shows you how the like, money could help open source stuff. And maybe if you use some packaging company, in some corporate, maybe try and think how you can give back, give back money or even if you give back code if you free up your developers to actually contribute. This is this is awesome. And that the hafting just mentioned because it talks about the traceback. It shows that you can now see, it's like color you can see on the screen, it's called the part where the actually the arrow was, it's colored now. So it's, that's very nice to see, like the example shows you, you add funk, like you had to function three times, but only it fails on just one input of them. So it shows you which of the three times the function field,

00:39:13 right, you call it the same thing like foo of zero plus foo of one plus foo of two, and it's the middle one that failed not just line seven, but the second invocation with the value one or it failed, which that's awesome. Yeah, exactly. And I think what Sorry, I was gonna say the same thing for indexing into what is that a data frame or something like that, like it's, you're chaining together like bracket zero, bracket one, bracket zero, it's the second one, trying to get to the one of zero that that was the one that failed. That's really, those are hard to come back and find if you're not in a debugger, like Well, which one of these failed like great array index out of bounds online three. Well, there's three of those happening. Which one? Yeah, that's cool.

00:39:57 And another thing is, a tweet by Victor stinner is a core Dev. And he says, maybe it's now time to deprecate the standard lib URL lib module. And this is brought out a lot of haters and fans. And I'm not sure what's my opinion yet. I'm not a heavy user of yoga lib. But it opened up a debate like, like we know how to do.

00:40:23 Yeah, yeah, that's really interesting. There are certain things in the standard library, you're like, Yeah, I know what that's there. And you could use it, but you probably shouldn't use it. There's like so many better external choices that are so good, that it would be kind of silly to fight them. Right. That's sort of the recommendation here.

00:40:38 Yeah. But also the like, some people don't like it. They have people there that say like, they don't they hate dependencies. And sometimes you can do most of the work with the standard lib and some of it, which says, like, maybe deprecate the major parts that requests can do. But there are some other parts that are actually really needed. So maybe deprecate half of it.

00:41:04 Yeah, I'm not sure if I'm about deprecating it. But, you know, it's one thing to say, there are better choices, and we as a community recommends, you probably just don't use this. But to deprecate it means that people who would rather go with a dependence, a lower level of dependencies, you're giving them warnings that they shouldn't be doing this when maybe it's unlikely it's going to actually vanish, right?

00:41:27 There's like a fallacy, though, that I think some people have that. If it's in this, if they don't have dependency, and it's in the standard, they're using something in the standard library. It's more solid. But I don't know if there's that many people working on URL URL lib right now and some of the other parts that the maybe people want to stop supporting. There's a that's something very valid, Python still is an open source project. And we can make those decisions.

00:41:55 Yeah, Victor actually says, the folly of all the security issues in yoga. So maybe it's better to use something outside of it.

00:42:05 Yeah, people wanted to say, but there's these issues. Yeah, I wonder if there's a way to go? Well, let's look at some of the libraries that are out there. Try to bring them in, and just use their core to replicate that functionality. Not to say, like, you could just pick on requests, like, bring requests in like vendor a little bit of it in. So it does what your lib does. And just go look, okay, this is the latest, greatest that we got. And everyone's been looking at requests already. I don't know. It'd be interesting. Yeah. And then Brandon out in the audience points out there also may be environments where you can't install dependencies for security reasons. And so having things like URL lib allows you to do more with Python. situation if

00:42:46 there's security problems with URL lib, that anybody

00:42:50 just in some of the functions you don't call those now. Just kidding. Alright, Brian, how about you extras?

00:42:56 What just one extra. I've been a brought this up last week. I'm currently not writing a book. So yes, so I'm, I want to write more blog posts. So one of the things I wanted to make sure that my, my blog, I'm migrated to Python test.com. And, and now it has a blog setting. And I like it looks pretty too, instead of just pulling everything over from my old WordPress blog. I'm trying to edit it. So I'm up through 2012. I'm gonna I'm gonna go oldest to newest and gradually do things bring things in. So that's one of my side projects I'm working on.

00:43:38 Yeah, it's a great side project. Nice. What's that running on? Is that like some static site generator or other hosted thing or it's Hugo

00:43:45 hosted by a free Netlify account?

00:43:48 Yeah, Delphi's pretty awesome. Alright, I got a couple things. I don't give a quick shout out to Brian, Brian. Brandon had the same question. But we got it. I first of all, I have to do my Python short to new version two videos. From there. I got beyond the list comprehension. So basically set in dictionary comprehensions. Fun stuff.

00:44:07 Nice picture.

00:44:09 Thank you. It's a little and it's like it just says screenshot of an animation. And then combining dictionaries to Python 310 ways to title the article. It really should be three, nine, but I kind of want to communicate like if you're on the latest Python, how should you be doing it came out in three, nine the features that are actually in there. Anyway, the pipe stuff, dictionary one pipe dictionary two, pipe dictionary three, which is often and then I wanted to talk about a feature over on pi pi.org. I don't even know how I found this probably just like an accident, like bump the keyboard or something. But if I'm over here, and you just want to search for something, Ford slash, you can search.

00:44:44 What? So the now the browser.

00:44:48 Exactly. So if you're on PI bi.org You want to search for slash? Yes. So that's pretty cool. Yep. All right. That's it for the extras. Nice. I don't even remember But my joke is so that's good. That'd be fine. already. Yeah. All right. Yeah, here we go. Oh yeah, this is another one of these sort of like frustration type of things. That's great. This comes from the programming humor, Twitter account on twitter.com/programming humor, which is there's a lot of good stuff in there some that I really liked, didn't want to necessarily put on the show. But this one is developers really frustrated that they're second in on their lips. They're pulling on their cheeks going ah, I hate this job. I hate my life. Why is this happening to me? Nevermind, I misspelled a variable. Good to go. Yeah, linting Yeah. linting is good. Plenty Indeed. Indeed. If you if you just flip through the programming humor one, it's pretty good. You know this, this eight year old is learning Python after dealing with the syntax bugs. He asked. If the computer knows it's missing a semicolon here. Why wanted added itself? I don't know. I really don't know. Yeah.

00:46:03 Yeah. And like, so he follows up and says what he meant. He meant colon, not semi colon, but so many people are like semicolon when you use a semicolon for Python.

00:46:16 Exactly. There are uses. They are rare, though. All right. Well, fantastic. Blast. Yeah, Jahnavi spoken, but it's good. Right. Okay. A lot of good stuff. I recommend people go flip to that Twitter account. sighs Brian, thank you. As always, it's good to be back with you. It's good to be back. And Dean. Thanks for coming on this side of the presentation and joining us for the show. Thanks for having me. Thanks for listening to Python bytes. Follow the show on Twitter via at Python bytes. That's Python bytes as in BYD s. Get the full show notes over at Python bytes FM. If you have a news item we should cover just visit by them by Sarafem and click submit in the nav bar. We're always on the lookout for sharing something cool. If you want to join us for the live recording, just visit the website and click Live stream to get notified of when our next episode goes live. That's usually happening at noon Pacific on Wednesdays over at YouTube. On behalf of myself and Brian Aachen, this is Michael Kennedy. Thank you for listening and sharing this podcast with your friends and colleagues.

